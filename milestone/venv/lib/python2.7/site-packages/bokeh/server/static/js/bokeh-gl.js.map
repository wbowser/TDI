{"version":3,"sources":["src/js/plugin-prelude.js","build/js/tree/models/glyphs/webgl/base.js","build/js/tree/models/glyphs/webgl/index.js","build/js/tree/models/glyphs/webgl/line.js","build/js/tree/models/glyphs/webgl/main.js","build/js/tree/models/glyphs/webgl/markers.js","src/vendor/gloo/gloo2.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClWA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bokeh-gl.js","sourcesContent":["(function outer(modules, cache, entry) {\n  if (Bokeh != null) {\n    for (var name in modules) {\n      Bokeh.require.modules[name] = modules[name];\n    }\n\n    for (var i = 0; i < entry.length; i++) {\n      var plugin = Bokeh.require(entry[0]);\n      Bokeh.Models.register_models(plugin.models);\n\n      for (var name in plugin) {\n        if (name !== \"models\") {\n          Bokeh[name] = plugin[name];\n        }\n      }\n    }\n  } else {\n    throw new Error(\"Cannot find Bokeh. You have to load it prior to loading plugins.\");\n  }\n})\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar color_1 = require(\"core/util/color\");\nexports.BaseGLGlyph = (function () {\n    BaseGLGlyph.prototype.GLYPH = '';\n    BaseGLGlyph.prototype.VERT = '';\n    BaseGLGlyph.prototype.FRAG = '';\n    function BaseGLGlyph(gl, glyph) {\n        this.gl = gl;\n        this.glyph = glyph;\n        this.nvertices = 0;\n        this.size_changed = false;\n        this.data_changed = false;\n        this.visuals_changed = false;\n        this.init();\n    }\n    BaseGLGlyph.prototype.set_data_changed = function (n) {\n        if (n !== this.nvertices) {\n            this.nvertices = n;\n            this.size_changed = true;\n        }\n        return this.data_changed = true;\n    };\n    BaseGLGlyph.prototype.set_visuals_changed = function () {\n        return this.visuals_changed = true;\n    };\n    BaseGLGlyph.prototype.render = function (ctx, indices, mainglyph) {\n        var dx, dy, ref, ref1, ref2, sx, sy, trans, wx, wy;\n        wx = wy = 1;\n        ref = this.glyph.renderer.map_to_screen([0 * wx, 1 * wx, 2 * wx], [0 * wy, 1 * wy, 2 * wy]), dx = ref[0], dy = ref[1];\n        wx = 100 / Math.min(Math.max(Math.abs(dx[1] - dx[0]), 1e-12), 1e12);\n        wy = 100 / Math.min(Math.max(Math.abs(dy[1] - dy[0]), 1e-12), 1e12);\n        ref1 = this.glyph.renderer.map_to_screen([0 * wx, 1 * wx, 2 * wx], [0 * wy, 1 * wy, 2 * wy]), dx = ref1[0], dy = ref1[1];\n        if (Math.abs((dx[1] - dx[0]) - (dx[2] - dx[1])) > 1e-6 || Math.abs((dy[1] - dy[0]) - (dy[2] - dy[1])) > 1e-6) {\n            return false;\n        }\n        ref2 = [(dx[1] - dx[0]) / wx, (dy[1] - dy[0]) / wy], sx = ref2[0], sy = ref2[1];\n        trans = {\n            pixel_ratio: ctx.pixel_ratio,\n            width: ctx.glcanvas.width,\n            height: ctx.glcanvas.height,\n            dx: dx[0] / sx,\n            dy: dy[0] / sy,\n            sx: sx,\n            sy: sy\n        };\n        this.draw(indices, mainglyph, trans);\n        return true;\n    };\n    return BaseGLGlyph;\n})();\nexports.line_width = function (width) {\n    if (width < 2) {\n        width = Math.sqrt(width * 2);\n    }\n    return width;\n};\nexports.fill_array_with_float = function (n, val) {\n    var a, i, k, ref;\n    a = new Float32Array(n);\n    for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n        a[i] = val;\n    }\n    return a;\n};\nexports.fill_array_with_vec = function (n, m, val) {\n    var a, i, j, k, l, ref, ref1;\n    a = new Float32Array(n * m);\n    for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n        for (j = l = 0, ref1 = m; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n            a[i * m + j] = val[j];\n        }\n    }\n    return a;\n};\nexports.visual_prop_is_singular = function (visual, propname) {\n    return visual[propname].spec.value !== void 0;\n};\nexports.attach_float = function (prog, vbo, att_name, n, visual, name) {\n    var a;\n    if (!visual.doit) {\n        vbo.used = false;\n        return prog.set_attribute(att_name, 'float', [0]);\n    }\n    else if (exports.visual_prop_is_singular(visual, name)) {\n        vbo.used = false;\n        return prog.set_attribute(att_name, 'float', visual[name].value());\n    }\n    else {\n        vbo.used = true;\n        a = new Float32Array(visual.cache[name + '_array']);\n        vbo.set_size(n * 4);\n        vbo.set_data(0, a);\n        return prog.set_attribute(att_name, 'float', vbo);\n    }\n};\nexports.attach_color = function (prog, vbo, att_name, n, visual, prefix) {\n    var a, alphaname, alphas, colorname, colors, i, j, k, l, m, ref, ref1, rgba;\n    m = 4;\n    colorname = prefix + '_color';\n    alphaname = prefix + '_alpha';\n    if (!visual.doit) {\n        vbo.used = false;\n        return prog.set_attribute(att_name, 'vec4', [0, 0, 0, 0]);\n    }\n    else if (exports.visual_prop_is_singular(visual, colorname) && exports.visual_prop_is_singular(visual, alphaname)) {\n        vbo.used = false;\n        rgba = color_1.color2rgba(visual[colorname].value(), visual[alphaname].value());\n        return prog.set_attribute(att_name, 'vec4', rgba);\n    }\n    else {\n        vbo.used = true;\n        if (exports.visual_prop_is_singular(visual, colorname)) {\n            colors = (function () {\n                var k, ref, results;\n                results = [];\n                for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n                    results.push(visual[colorname].value());\n                }\n                return results;\n            })();\n        }\n        else {\n            colors = visual.cache[colorname + '_array'];\n        }\n        if (exports.visual_prop_is_singular(visual, alphaname)) {\n            alphas = exports.fill_array_with_float(n, visual[alphaname].value());\n        }\n        else {\n            alphas = visual.cache[alphaname + '_array'];\n        }\n        a = new Float32Array(n * m);\n        for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            rgba = color_1.color2rgba(colors[i], alphas[i]);\n            for (j = l = 0, ref1 = m; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n                a[i * m + j] = rgba[j];\n            }\n        }\n        vbo.set_size(n * m * 4);\n        vbo.set_data(0, a);\n        return prog.set_attribute(att_name, 'vec4', vbo);\n    }\n};\n","\"use strict\";\n/*\nCopyright notice: many of the awesome techniques and  GLSL code contained in\nthis module are based on work by Nicolas Rougier as part of the Glumpy and\nVispy projects. The algorithms are published in\nhttp://jcgt.org/published/0003/04/01/ and http://jcgt.org/published/0002/02/08/\n\nThis module contains all gl-specific code to add gl support for the glyphs.\nBy implementing it separetely, the GL functionality can be spun off in a\nseparate library.\nOther locations where we work with GL, or prepare for GL-rendering:\n- canvas.coffee\n- plot.coffee\n- glyph.coffee\n- glyph_renderer.coffee\n*/\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./line\"));\n__export(require(\"./markers\"));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DashAtlas, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar gloo2 = require(\"gloo2\");\nvar color_1 = require(\"core/util/color\");\nvar base_1 = require(\"./base\");\nDashAtlas = (function () {\n    function DashAtlas(gl) {\n        this._atlas = {};\n        this._index = 0;\n        this._width = 256;\n        this._height = 256;\n        this.tex = new gloo2.Texture2D(gl);\n        this.tex.set_wrapping(gl.REPEAT, gl.REPEAT);\n        this.tex.set_interpolation(gl.NEAREST, gl.NEAREST);\n        this.tex.set_size([this._height, this._width], gl.RGBA);\n        this.tex.set_data([0, 0], [this._height, this._width], new Uint8Array(this._height * this._width * 4));\n        this.get_atlas_data([1]);\n    }\n    DashAtlas.prototype.get_atlas_data = function (pattern) {\n        var data, findex_period, key, period, ref, x;\n        key = pattern.join('-');\n        findex_period = this._atlas[key];\n        if (findex_period === void 0) {\n            ref = this.make_pattern(pattern), data = ref[0], period = ref[1];\n            this.tex.set_data([this._index, 0], [1, this._width], new Uint8Array((function () {\n                var l, len, results;\n                results = [];\n                for (l = 0, len = data.length; l < len; l++) {\n                    x = data[l];\n                    results.push(x + 10);\n                }\n                return results;\n            })()));\n            this._atlas[key] = [this._index / this._height, period];\n            this._index += 1;\n        }\n        return this._atlas[key];\n    };\n    DashAtlas.prototype.make_pattern = function (pattern) {\n        var C, Z, a, b, c, dash_end, dash_start, dash_type, i, index, j, l, len, n, p, period, q, r, ref, ref1, ref2, v, val, val_at_index, x;\n        if (pattern.length > 1 && pattern.length % 2) {\n            pattern = pattern.concat(pattern);\n        }\n        period = 0;\n        for (l = 0, len = pattern.length; l < len; l++) {\n            v = pattern[l];\n            period += v;\n        }\n        C = [];\n        c = 0;\n        for (i = p = 0, ref = pattern.length + 2; p < ref; i = p += 2) {\n            a = Math.max(0.0001, pattern[i % pattern.length]);\n            b = Math.max(0.0001, pattern[(i + 1) % pattern.length]);\n            C.push.apply(C, [c, c + a]);\n            c += a + b;\n        }\n        n = this._width;\n        Z = new Float32Array(n * 4);\n        for (i = q = 0, ref1 = n; 0 <= ref1 ? q < ref1 : q > ref1; i = 0 <= ref1 ? ++q : --q) {\n            x = period * i / (n - 1);\n            index = 0;\n            val_at_index = 1e16;\n            for (j = r = 0, ref2 = C.length; 0 <= ref2 ? r < ref2 : r > ref2; j = 0 <= ref2 ? ++r : --r) {\n                val = Math.abs(C[j] - x);\n                if (val < val_at_index) {\n                    index = j;\n                    val_at_index = val;\n                }\n            }\n            if (index % 2 === 0) {\n                dash_type = (x <= C[index]) ? +1 : 0;\n                dash_start = C[index];\n                dash_end = C[index + 1];\n            }\n            else {\n                dash_type = (x > C[index]) ? -1 : 0;\n                dash_start = C[index - 1];\n                dash_end = C[index];\n            }\n            Z[i * 4 + 0] = C[index];\n            Z[i * 4 + 1] = dash_type;\n            Z[i * 4 + 2] = dash_start;\n            Z[i * 4 + 3] = dash_end;\n        }\n        return [Z, period];\n    };\n    return DashAtlas;\n})();\nexports.LineGLGlyph = (function (superClass) {\n    extend(LineGLGlyph, superClass);\n    function LineGLGlyph() {\n        return LineGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    LineGLGlyph.prototype.GLYPH = 'line';\n    LineGLGlyph.prototype.JOINS = {\n        'miter': 0,\n        'round': 1,\n        'bevel': 2\n    };\n    LineGLGlyph.prototype.CAPS = {\n        '': 0,\n        'none': 0,\n        '.': 0,\n        'round': 1,\n        ')': 1,\n        '(': 1,\n        'o': 1,\n        'triangle in': 2,\n        '<': 2,\n        'triangle out': 3,\n        '>': 3,\n        'square': 4,\n        '[': 4,\n        ']': 4,\n        '=': 4,\n        'butt': 5,\n        '|': 5\n    };\n    LineGLGlyph.prototype.VERT = \"precision mediump float;\\n\\nconst float PI = 3.14159265358979323846264;\\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\\n\\nuniform float u_pixel_ratio;\\nuniform vec2 u_canvas_size, u_offset;\\nuniform vec2 u_scale_aspect;\\nuniform float u_scale_length;\\n\\nuniform vec4 u_color;\\nuniform float u_antialias;\\nuniform float u_length;\\nuniform float u_linewidth;\\nuniform float u_dash_index;\\nuniform float u_closed;\\n\\nattribute vec2 a_position;\\nattribute vec4 a_tangents;\\nattribute vec2 a_segment;\\nattribute vec2 a_angles;\\nattribute vec2 a_texcoord;\\n\\nvarying vec4  v_color;\\nvarying vec2  v_segment;\\nvarying vec2  v_angles;\\nvarying vec2  v_texcoord;\\nvarying vec2  v_miter;\\nvarying float v_length;\\nvarying float v_linewidth;\\n\\nfloat cross(in vec2 v1, in vec2 v2)\\n{\\n    return v1.x*v2.y - v1.y*v2.x;\\n}\\n\\nfloat signed_distance(in vec2 v1, in vec2 v2, in vec2 v3)\\n{\\n    return cross(v2-v1,v1-v3) / length(v2-v1);\\n}\\n\\nvoid rotate( in vec2 v, in float alpha, out vec2 result )\\n{\\n    float c = cos(alpha);\\n    float s = sin(alpha);\\n    result = vec2( c*v.x - s*v.y,\\n                   s*v.x + c*v.y );\\n}\\n\\nvoid main()\\n{\\n    bool closed = (u_closed > 0.0);\\n\\n    // Attributes and uniforms to varyings\\n    v_color = u_color;\\n    v_linewidth = u_linewidth;\\n    v_segment = a_segment * u_scale_length;\\n    v_length = u_length * u_scale_length;\\n\\n    // Scale to map to pixel coordinates. The original algorithm from the paper\\n    // assumed isotropic scale. We obviously do not have this.\\n    vec2 abs_scale_aspect = abs(u_scale_aspect);\\n    vec2 abs_scale = u_scale_length * abs_scale_aspect;\\n\\n    // Correct angles for aspect ratio\\n    vec2 av;\\n    av = vec2(1.0, tan(a_angles.x)) / abs_scale_aspect;\\n    v_angles.x = atan(av.y, av.x);\\n    av = vec2(1.0, tan(a_angles.y)) / abs_scale_aspect;\\n    v_angles.y = atan(av.y, av.x);\\n\\n    // Thickness below 1 pixel are represented using a 1 pixel thickness\\n    // and a modified alpha\\n    v_color.a = min(v_linewidth, v_color.a);\\n    v_linewidth = max(v_linewidth, 1.0);\\n\\n    // If color is fully transparent we just will discard the fragment anyway\\n    if( v_color.a <= 0.0 ) {\\n        gl_Position = vec4(0.0,0.0,0.0,1.0);\\n        return;\\n    }\\n\\n    // This is the actual half width of the line\\n    float w = ceil(u_antialias+v_linewidth)/2.0;\\n\\n    vec2 position = (a_position + u_offset) * abs_scale;\\n\\n    vec2 t1 = normalize(a_tangents.xy * abs_scale_aspect);  // note the scaling for aspect ratio here\\n    vec2 t2 = normalize(a_tangents.zw * abs_scale_aspect);\\n    float u = a_texcoord.x;\\n    float v = a_texcoord.y;\\n    vec2 o1 = vec2( +t1.y, -t1.x);\\n    vec2 o2 = vec2( +t2.y, -t2.x);\\n\\n    // This is a join\\n    // ----------------------------------------------------------------\\n    if( t1 != t2 ) {\\n        float angle = atan (t1.x*t2.y-t1.y*t2.x, t1.x*t2.x+t1.y*t2.y);  // Angle needs recalculation for some reason\\n        vec2 t  = normalize(t1+t2);\\n        vec2 o  = vec2( + t.y, - t.x);\\n\\n        if ( u_dash_index > 0.0 )\\n        {\\n            // Broken angle\\n            // ----------------------------------------------------------------\\n            if( (abs(angle) > THETA) ) {\\n                position += v * w * o / cos(angle/2.0);\\n                float s = sign(angle);\\n                if( angle < 0.0 ) {\\n                    if( u == +1.0 ) {\\n                        u = v_segment.y + v * w * tan(angle/2.0);\\n                        if( v == 1.0 ) {\\n                            position -= 2.0 * w * t1 / sin(angle);\\n                            u -= 2.0 * w / sin(angle);\\n                        }\\n                    } else {\\n                        u = v_segment.x - v * w * tan(angle/2.0);\\n                        if( v == 1.0 ) {\\n                            position += 2.0 * w * t2 / sin(angle);\\n                            u += 2.0*w / sin(angle);\\n                        }\\n                    }\\n                } else {\\n                    if( u == +1.0 ) {\\n                        u = v_segment.y + v * w * tan(angle/2.0);\\n                        if( v == -1.0 ) {\\n                            position += 2.0 * w * t1 / sin(angle);\\n                            u += 2.0 * w / sin(angle);\\n                        }\\n                    } else {\\n                        u = v_segment.x - v * w * tan(angle/2.0);\\n                        if( v == -1.0 ) {\\n                            position -= 2.0 * w * t2 / sin(angle);\\n                            u -= 2.0*w / sin(angle);\\n                        }\\n                    }\\n                }\\n                // Continuous angle\\n                // ------------------------------------------------------------\\n            } else {\\n                position += v * w * o / cos(angle/2.0);\\n                if( u == +1.0 ) u = v_segment.y;\\n                else            u = v_segment.x;\\n            }\\n        }\\n\\n        // Solid line\\n        // --------------------------------------------------------------------\\n        else\\n        {\\n            position.xy += v * w * o / cos(angle/2.0);\\n            if( angle < 0.0 ) {\\n                if( u == +1.0 ) {\\n                    u = v_segment.y + v * w * tan(angle/2.0);\\n                } else {\\n                    u = v_segment.x - v * w * tan(angle/2.0);\\n                }\\n            } else {\\n                if( u == +1.0 ) {\\n                    u = v_segment.y + v * w * tan(angle/2.0);\\n                } else {\\n                    u = v_segment.x - v * w * tan(angle/2.0);\\n                }\\n            }\\n        }\\n\\n    // This is a line start or end (t1 == t2)\\n    // ------------------------------------------------------------------------\\n    } else {\\n        position += v * w * o1;\\n        if( u == -1.0 ) {\\n            u = v_segment.x - w;\\n            position -= w * t1;\\n        } else {\\n            u = v_segment.y + w;\\n            position += w * t2;\\n        }\\n    }\\n\\n    // Miter distance\\n    // ------------------------------------------------------------------------\\n    vec2 t;\\n    vec2 curr = a_position * abs_scale;\\n    if( a_texcoord.x < 0.0 ) {\\n        vec2 next = curr + t2*(v_segment.y-v_segment.x);\\n\\n        rotate( t1, +v_angles.x/2.0, t);\\n        v_miter.x = signed_distance(curr, curr+t, position);\\n\\n        rotate( t2, +v_angles.y/2.0, t);\\n        v_miter.y = signed_distance(next, next+t, position);\\n    } else {\\n        vec2 prev = curr - t1*(v_segment.y-v_segment.x);\\n\\n        rotate( t1, -v_angles.x/2.0,t);\\n        v_miter.x = signed_distance(prev, prev+t, position);\\n\\n        rotate( t2, -v_angles.y/2.0,t);\\n        v_miter.y = signed_distance(curr, curr+t, position);\\n    }\\n\\n    if (!closed && v_segment.x <= 0.0) {\\n        v_miter.x = 1e10;\\n    }\\n    if (!closed && v_segment.y >= v_length)\\n    {\\n        v_miter.y = 1e10;\\n    }\\n\\n    v_texcoord = vec2( u, v*w );\\n\\n    // Calculate position in device coordinates. Note that we\\n    // already scaled with abs scale above.\\n    vec2 normpos = position * sign(u_scale_aspect);\\n    normpos += 0.5;  // make up for Bokeh's offset\\n    normpos /= u_canvas_size / u_pixel_ratio;  // in 0..1\\n    gl_Position = vec4(normpos*2.0-1.0, 0.0, 1.0);\\n    gl_Position.y *= -1.0;\\n}\\n\";\n    LineGLGlyph.prototype.FRAG_ = \"// Fragment shader that can be convenient during debugging to show the line skeleton.\\nprecision mediump float;\\nuniform vec4  u_color;\\nvoid main () {\\n  gl_FragColor = u_color;\\n}\";\n    LineGLGlyph.prototype.FRAG = \"precision mediump float;\\n\\nconst float PI = 3.14159265358979323846264;\\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\\n\\nuniform sampler2D u_dash_atlas;\\n\\nuniform vec2 u_linecaps;\\nuniform float u_miter_limit;\\nuniform float u_linejoin;\\nuniform float u_antialias;\\nuniform float u_dash_phase;\\nuniform float u_dash_period;\\nuniform float u_dash_index;\\nuniform vec2 u_dash_caps;\\nuniform float u_closed;\\n\\nvarying vec4  v_color;\\nvarying vec2  v_segment;\\nvarying vec2  v_angles;\\nvarying vec2  v_texcoord;\\nvarying vec2  v_miter;\\nvarying float v_length;\\nvarying float v_linewidth;\\n\\n// Compute distance to cap ----------------------------------------------------\\nfloat cap( int type, float dx, float dy, float t, float linewidth )\\n{\\n    float d = 0.0;\\n    dx = abs(dx);\\n    dy = abs(dy);\\n    if      (type == 0)  discard;  // None\\n    else if (type == 1)  d = sqrt(dx*dx+dy*dy);  // Round\\n    else if (type == 3)  d = (dx+abs(dy));  // Triangle in\\n    else if (type == 2)  d = max(abs(dy),(t+dx-abs(dy)));  // Triangle out\\n    else if (type == 4)  d = max(dx,dy);  // Square\\n    else if (type == 5)  d = max(dx+t,dy);  // Butt\\n    return d;\\n}\\n\\n// Compute distance to join -------------------------------------------------\\nfloat join( in int type, in float d, in vec2 segment, in vec2 texcoord, in vec2 miter,\\n           in float linewidth )\\n{\\n    // texcoord.x is distance from start\\n    // texcoord.y is distance from centerline\\n    // segment.x and y indicate the limits (as for texcoord.x) for this segment\\n\\n    float dx = texcoord.x;\\n\\n    // Round join\\n    if( type == 1 ) {\\n        if (dx < segment.x) {\\n            d = max(d,length( texcoord - vec2(segment.x,0.0)));\\n            //d = length( texcoord - vec2(segment.x,0.0));\\n        } else if (dx > segment.y) {\\n            d = max(d,length( texcoord - vec2(segment.y,0.0)));\\n            //d = length( texcoord - vec2(segment.y,0.0));\\n        }\\n    }\\n    // Bevel join\\n    else if ( type == 2 ) {\\n        if (dx < segment.x) {\\n            vec2 x = texcoord - vec2(segment.x,0.0);\\n            d = max(d, max(abs(x.x), abs(x.y)));\\n\\n        } else if (dx > segment.y) {\\n            vec2 x = texcoord - vec2(segment.y,0.0);\\n            d = max(d, max(abs(x.x), abs(x.y)));\\n        }\\n        /*  Original code for bevel which does not work for us\\n        if( (dx < segment.x) ||  (dx > segment.y) )\\n            d = max(d, min(abs(x.x),abs(x.y)));\\n        */\\n    }\\n\\n    return d;\\n}\\n\\nvoid main()\\n{\\n    // If color is fully transparent we just discard the fragment\\n    if( v_color.a <= 0.0 ) {\\n        discard;\\n    }\\n\\n    // Test if dash pattern is the solid one (0)\\n    bool solid =  (u_dash_index == 0.0);\\n\\n    // Test if path is closed\\n    bool closed = (u_closed > 0.0);\\n\\n    vec4 color = v_color;\\n    float dx = v_texcoord.x;\\n    float dy = v_texcoord.y;\\n    float t = v_linewidth/2.0-u_antialias;\\n    float width = 1.0;  //v_linewidth; original code had dashes scale with line width, we do not\\n    float d = 0.0;\\n\\n    vec2 linecaps = u_linecaps;\\n    vec2 dash_caps = u_dash_caps;\\n    float line_start = 0.0;\\n    float line_stop = v_length;\\n\\n    // Apply miter limit; fragments too far into the miter are simply discarded\\n    if( (dx < v_segment.x) || (dx > v_segment.y) ) {\\n        float into_miter = max(v_segment.x - dx, dx - v_segment.y);\\n        if (into_miter > u_miter_limit*v_linewidth/2.0)\\n          discard;\\n    }\\n\\n    // Solid line --------------------------------------------------------------\\n    if( solid ) {\\n        d = abs(dy);\\n        if( (!closed) && (dx < line_start) ) {\\n            d = cap( int(u_linecaps.x), abs(dx), abs(dy), t, v_linewidth );\\n        }\\n        else if( (!closed) &&  (dx > line_stop) ) {\\n            d = cap( int(u_linecaps.y), abs(dx)-line_stop, abs(dy), t, v_linewidth );\\n        }\\n        else {\\n            d = join( int(u_linejoin), abs(dy), v_segment, v_texcoord, v_miter, v_linewidth );\\n        }\\n\\n    // Dash line --------------------------------------------------------------\\n    } else {\\n        float segment_start = v_segment.x;\\n        float segment_stop  = v_segment.y;\\n        float segment_center= (segment_start+segment_stop)/2.0;\\n        float freq          = u_dash_period*width;\\n        float u = mod( dx + u_dash_phase*width, freq);\\n        vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\\n        float dash_center= tex.x * width;\\n        float dash_type  = tex.y;\\n        float _start = tex.z * width;\\n        float _stop  = tex.a * width;\\n        float dash_start = dx - u + _start;\\n        float dash_stop  = dx - u + _stop;\\n\\n        // Compute extents of the first dash (the one relative to v_segment.x)\\n        // Note: this could be computed in the vertex shader\\n        if( (dash_stop < segment_start) && (dash_caps.x != 5.0) ) {\\n            float u = mod(segment_start + u_dash_phase*width, freq);\\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\\n            dash_center= tex.x * width;\\n            //dash_type  = tex.y;\\n            float _start = tex.z * width;\\n            float _stop  = tex.a * width;\\n            dash_start = segment_start - u + _start;\\n            dash_stop = segment_start - u + _stop;\\n        }\\n\\n        // Compute extents of the last dash (the one relatives to v_segment.y)\\n        // Note: This could be computed in the vertex shader\\n        else if( (dash_start > segment_stop)  && (dash_caps.y != 5.0) ) {\\n            float u = mod(segment_stop + u_dash_phase*width, freq);\\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\\n            dash_center= tex.x * width;\\n            //dash_type  = tex.y;\\n            float _start = tex.z * width;\\n            float _stop  = tex.a * width;\\n            dash_start = segment_stop - u + _start;\\n            dash_stop  = segment_stop - u + _stop;\\n        }\\n\\n        // This test if the we are dealing with a discontinuous angle\\n        bool discontinuous = ((dx <  segment_center) && abs(v_angles.x) > THETA) ||\\n                             ((dx >= segment_center) && abs(v_angles.y) > THETA);\\n        //if( dx < line_start) discontinuous = false;\\n        //if( dx > line_stop)  discontinuous = false;\\n\\n        float d_join = join( int(u_linejoin), abs(dy),\\n                            v_segment, v_texcoord, v_miter, v_linewidth );\\n\\n        // When path is closed, we do not have room for linecaps, so we make room\\n        // by shortening the total length\\n        if (closed) {\\n             line_start += v_linewidth/2.0;\\n             line_stop  -= v_linewidth/2.0;\\n        }\\n\\n        // We also need to take antialias area into account\\n        //line_start += u_antialias;\\n        //line_stop  -= u_antialias;\\n\\n        // Check is dash stop is before line start\\n        if( dash_stop <= line_start ) {\\n            discard;\\n        }\\n        // Check is dash start is beyond line stop\\n        if( dash_start >= line_stop ) {\\n            discard;\\n        }\\n\\n        // Check if current dash start is beyond segment stop\\n        if( discontinuous ) {\\n            // Dash start is beyond segment, we discard\\n            if( (dash_start > segment_stop) ) {\\n                discard;\\n                //gl_FragColor = vec4(1.0,0.0,0.0,.25); return;\\n            }\\n\\n            // Dash stop is before segment, we discard\\n            if( (dash_stop < segment_start) ) {\\n                discard;  //gl_FragColor = vec4(0.0,1.0,0.0,.25); return;\\n            }\\n\\n            // Special case for round caps (nicer with this)\\n            if( dash_caps.x == 1.0 ) {\\n                if( (u > _stop) && (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0)) {\\n                    discard;\\n                }\\n            }\\n\\n            // Special case for round caps  (nicer with this)\\n            if( dash_caps.y == 1.0 ) {\\n                if( (u < _start) && (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0)) {\\n                    discard;\\n                }\\n            }\\n\\n            // Special case for triangle caps (in & out) and square\\n            // We make sure the cap stop at crossing frontier\\n            if( (dash_caps.x != 1.0) && (dash_caps.x != 5.0) ) {\\n                if( (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0) ) {\\n                    float a = v_angles.x/2.0;\\n                    float x = (segment_start-dx)*cos(a) - dy*sin(a);\\n                    float y = (segment_start-dx)*sin(a) + dy*cos(a);\\n                    if( x > 0.0 ) discard;\\n                    // We transform the cap into square to avoid holes\\n                    dash_caps.x = 4.0;\\n                }\\n            }\\n\\n            // Special case for triangle caps (in & out) and square\\n            // We make sure the cap stop at crossing frontier\\n            if( (dash_caps.y != 1.0) && (dash_caps.y != 5.0) ) {\\n                if( (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0) ) {\\n                    float a = v_angles.y/2.0;\\n                    float x = (dx-segment_stop)*cos(a) - dy*sin(a);\\n                    float y = (dx-segment_stop)*sin(a) + dy*cos(a);\\n                    if( x > 0.0 ) discard;\\n                    // We transform the caps into square to avoid holes\\n                    dash_caps.y = 4.0;\\n                }\\n            }\\n        }\\n\\n        // Line cap at start\\n        if( (dx < line_start) && (dash_start < line_start) && (dash_stop > line_start) ) {\\n            d = cap( int(linecaps.x), dx-line_start, dy, t, v_linewidth);\\n        }\\n        // Line cap at stop\\n        else if( (dx > line_stop) && (dash_stop > line_stop) && (dash_start < line_stop) ) {\\n            d = cap( int(linecaps.y), dx-line_stop, dy, t, v_linewidth);\\n        }\\n        // Dash cap left - dash_type = -1, 0 or 1, but there may be roundoff errors\\n        else if( dash_type < -0.5 ) {\\n            d = cap( int(dash_caps.y), abs(u-dash_center), dy, t, v_linewidth);\\n            if( (dx > line_start) && (dx < line_stop) )\\n                d = max(d,d_join);\\n        }\\n        // Dash cap right\\n        else if( dash_type > 0.5 ) {\\n            d = cap( int(dash_caps.x), abs(dash_center-u), dy, t, v_linewidth);\\n            if( (dx > line_start) && (dx < line_stop) )\\n                d = max(d,d_join);\\n        }\\n        // Dash body (plain)\\n        else {// if( dash_type > -0.5 &&  dash_type < 0.5) {\\n            d = abs(dy);\\n        }\\n\\n        // Line join\\n        if( (dx > line_start) && (dx < line_stop)) {\\n            if( (dx <= segment_start) && (dash_start <= segment_start)\\n                && (dash_stop >= segment_start) ) {\\n                d = d_join;\\n                // Antialias at outer border\\n                float angle = PI/2.+v_angles.x;\\n                float f = abs( (segment_start - dx)*cos(angle) - dy*sin(angle));\\n                d = max(f,d);\\n            }\\n            else if( (dx > segment_stop) && (dash_start <= segment_stop)\\n                     && (dash_stop >= segment_stop) ) {\\n                d = d_join;\\n                // Antialias at outer border\\n                float angle = PI/2.+v_angles.y;\\n                float f = abs((dx - segment_stop)*cos(angle) - dy*sin(angle));\\n                d = max(f,d);\\n            }\\n            else if( dx < (segment_start - v_linewidth/2.)) {\\n                discard;\\n            }\\n            else if( dx > (segment_stop + v_linewidth/2.)) {\\n                discard;\\n            }\\n        }\\n        else if( dx < (segment_start - v_linewidth/2.)) {\\n            discard;\\n        }\\n        else if( dx > (segment_stop + v_linewidth/2.)) {\\n            discard;\\n        }\\n    }\\n\\n    // Distance to border ------------------------------------------------------\\n    d = d - t;\\n    if( d < 0.0 ) {\\n        gl_FragColor = color;\\n    } else {\\n        d /= u_antialias;\\n        gl_FragColor = vec4(color.rgb, exp(-d*d)*color.a);\\n    }\\n}\";\n    LineGLGlyph.prototype.init = function () {\n        var gl;\n        gl = this.gl;\n        this._scale_aspect = 0;\n        this.prog = new gloo2.Program(gl);\n        this.prog.set_shaders(this.VERT, this.FRAG);\n        this.index_buffer = new gloo2.IndexBuffer(gl);\n        this.vbo_position = new gloo2.VertexBuffer(gl);\n        this.vbo_tangents = new gloo2.VertexBuffer(gl);\n        this.vbo_segment = new gloo2.VertexBuffer(gl);\n        this.vbo_angles = new gloo2.VertexBuffer(gl);\n        this.vbo_texcoord = new gloo2.VertexBuffer(gl);\n        return this.dash_atlas = new DashAtlas(gl);\n    };\n    LineGLGlyph.prototype.draw = function (indices, mainGlyph, trans) {\n        var baked_offset, chunk, chunks, chunksize, i, l, mainGlGlyph, nvertices, offset, p, q, ref, ref1, ref2, results, scale_length, sx, sy, these_indices, uint16_index;\n        mainGlGlyph = mainGlyph.glglyph;\n        if (mainGlGlyph.data_changed) {\n            if (!(isFinite(trans.dx) && isFinite(trans.dy))) {\n                return;\n            }\n            mainGlGlyph._baked_offset = [trans.dx, trans.dy];\n            mainGlGlyph._set_data();\n            mainGlGlyph.data_changed = false;\n        }\n        if (this.visuals_changed) {\n            this._set_visuals();\n            this.visuals_changed = false;\n        }\n        sx = trans.sx;\n        sy = trans.sy;\n        scale_length = Math.sqrt(sx * sx + sy * sy);\n        sx /= scale_length;\n        sy /= scale_length;\n        if (Math.abs(this._scale_aspect - (sy / sx)) > Math.abs(1e-3 * this._scale_aspect)) {\n            mainGlGlyph._update_scale(sx, sy);\n            this._scale_aspect = sy / sx;\n        }\n        this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position);\n        this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents);\n        this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment);\n        this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles);\n        this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord);\n        this.prog.set_uniform('u_length', 'float', [mainGlGlyph.cumsum]);\n        this.prog.set_texture('u_dash_atlas', this.dash_atlas.tex);\n        baked_offset = mainGlGlyph._baked_offset;\n        this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\n        this.prog.set_uniform('u_canvas_size', 'vec2', [trans.width, trans.height]);\n        this.prog.set_uniform('u_offset', 'vec2', [trans.dx - baked_offset[0], trans.dy - baked_offset[1]]);\n        this.prog.set_uniform('u_scale_aspect', 'vec2', [sx, sy]);\n        this.prog.set_uniform('u_scale_length', 'float', [scale_length]);\n        this.I_triangles = mainGlGlyph.I_triangles;\n        if (this.I_triangles.length < 65535) {\n            this.index_buffer.set_size(this.I_triangles.length * 2);\n            this.index_buffer.set_data(0, new Uint16Array(this.I_triangles));\n            return this.prog.draw(this.gl.TRIANGLES, this.index_buffer);\n        }\n        else {\n            indices = this.I_triangles;\n            nvertices = this.I_triangles.length;\n            chunksize = 64008;\n            chunks = [];\n            for (i = l = 0, ref = Math.ceil(nvertices / chunksize); 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {\n                chunks.push([]);\n            }\n            for (i = p = 0, ref1 = indices.length; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {\n                uint16_index = indices[i] % chunksize;\n                chunk = Math.floor(indices[i] / chunksize);\n                chunks[chunk].push(uint16_index);\n            }\n            results = [];\n            for (chunk = q = 0, ref2 = chunks.length; 0 <= ref2 ? q < ref2 : q > ref2; chunk = 0 <= ref2 ? ++q : --q) {\n                these_indices = new Uint16Array(chunks[chunk]);\n                offset = chunk * chunksize * 4;\n                if (these_indices.length === 0) {\n                    continue;\n                }\n                this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position, 0, offset * 2);\n                this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents, 0, offset * 4);\n                this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment, 0, offset * 2);\n                this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles, 0, offset * 2);\n                this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord, 0, offset * 2);\n                this.index_buffer.set_size(these_indices.length * 2);\n                this.index_buffer.set_data(0, these_indices);\n                results.push(this.prog.draw(this.gl.TRIANGLES, this.index_buffer));\n            }\n            return results;\n        }\n    };\n    LineGLGlyph.prototype._set_data = function () {\n        this._bake();\n        this.vbo_position.set_size(this.V_position.length * 4);\n        this.vbo_position.set_data(0, this.V_position);\n        this.vbo_tangents.set_size(this.V_tangents.length * 4);\n        this.vbo_tangents.set_data(0, this.V_tangents);\n        this.vbo_angles.set_size(this.V_angles.length * 4);\n        this.vbo_angles.set_data(0, this.V_angles);\n        this.vbo_texcoord.set_size(this.V_texcoord.length * 4);\n        return this.vbo_texcoord.set_data(0, this.V_texcoord);\n    };\n    LineGLGlyph.prototype._set_visuals = function () {\n        var cap, color, dash_index, dash_pattern, dash_period, join, ref;\n        color = color_1.color2rgba(this.glyph.visuals.line.line_color.value(), this.glyph.visuals.line.line_alpha.value());\n        cap = this.CAPS[this.glyph.visuals.line.line_cap.value()];\n        join = this.JOINS[this.glyph.visuals.line.line_join.value()];\n        this.prog.set_uniform('u_color', 'vec4', color);\n        this.prog.set_uniform('u_linewidth', 'float', [this.glyph.visuals.line.line_width.value()]);\n        this.prog.set_uniform('u_antialias', 'float', [0.9]);\n        this.prog.set_uniform('u_linecaps', 'vec2', [cap, cap]);\n        this.prog.set_uniform('u_linejoin', 'float', [join]);\n        this.prog.set_uniform('u_miter_limit', 'float', [10.0]);\n        dash_pattern = this.glyph.visuals.line.line_dash.value();\n        dash_index = 0;\n        dash_period = 1;\n        if (dash_pattern.length) {\n            ref = this.dash_atlas.get_atlas_data(dash_pattern), dash_index = ref[0], dash_period = ref[1];\n        }\n        this.prog.set_uniform('u_dash_index', 'float', [dash_index]);\n        this.prog.set_uniform('u_dash_phase', 'float', [this.glyph.visuals.line.line_dash_offset.value()]);\n        this.prog.set_uniform('u_dash_period', 'float', [dash_period]);\n        this.prog.set_uniform('u_dash_caps', 'vec2', [cap, cap]);\n        return this.prog.set_uniform('u_closed', 'float', [0]);\n    };\n    LineGLGlyph.prototype._bake = function () {\n        var A, I, T, V_angles, V_angles2, V_position, V_position2, V_tangents, V_tangents2, V_texcoord, V_texcoord2, Vp, Vt, _x, _y, i, i1, j, k, l, m, n, ni, o, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, results, s, t, u, w, y, z;\n        n = this.nvertices;\n        _x = new Float64Array(this.glyph._x);\n        _y = new Float64Array(this.glyph._y);\n        V_position = Vp = new Float32Array(n * 2);\n        V_angles = new Float32Array(n * 2);\n        V_tangents = Vt = new Float32Array(n * 4);\n        V_texcoord = new Float32Array(n * 2);\n        for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {\n            V_position[i * 2 + 0] = _x[i] + this._baked_offset[0];\n            V_position[i * 2 + 1] = _y[i] + this._baked_offset[1];\n        }\n        this.tangents = T = new Float32Array(n * 2 - 2);\n        for (i = p = 0, ref1 = n - 1; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {\n            T[i * 2 + 0] = Vp[(i + 1) * 2 + 0] - Vp[i * 2 + 0];\n            T[i * 2 + 1] = Vp[(i + 1) * 2 + 1] - Vp[i * 2 + 1];\n        }\n        for (i = q = 0, ref2 = n - 1; 0 <= ref2 ? q < ref2 : q > ref2; i = 0 <= ref2 ? ++q : --q) {\n            V_tangents[(i + 1) * 4 + 0] = T[i * 2 + 0];\n            V_tangents[(i + 1) * 4 + 1] = T[i * 2 + 1];\n            V_tangents[i * 4 + 2] = T[i * 2 + 0];\n            V_tangents[i * 4 + 3] = T[i * 2 + 1];\n        }\n        V_tangents[0 * 4 + 0] = T[0];\n        V_tangents[0 * 4 + 1] = T[1];\n        V_tangents[(n - 1) * 4 + 2] = T[(n - 2) * 2 + 0];\n        V_tangents[(n - 1) * 4 + 3] = T[(n - 2) * 2 + 1];\n        A = new Float32Array(n);\n        for (i = r = 0, ref3 = n; 0 <= ref3 ? r < ref3 : r > ref3; i = 0 <= ref3 ? ++r : --r) {\n            A[i] = Math.atan2(Vt[i * 4 + 0] * Vt[i * 4 + 3] - Vt[i * 4 + 1] * Vt[i * 4 + 2], Vt[i * 4 + 0] * Vt[i * 4 + 2] + Vt[i * 4 + 1] * Vt[i * 4 + 3]);\n        }\n        for (i = s = 0, ref4 = n - 1; 0 <= ref4 ? s < ref4 : s > ref4; i = 0 <= ref4 ? ++s : --s) {\n            V_angles[i * 2 + 0] = A[i];\n            V_angles[i * 2 + 1] = A[i + 1];\n        }\n        m = 4 * n - 4;\n        this.V_position = V_position2 = new Float32Array(m * 2);\n        this.V_angles = V_angles2 = new Float32Array(m * 2);\n        this.V_tangents = V_tangents2 = new Float32Array(m * 4);\n        this.V_texcoord = V_texcoord2 = new Float32Array(m * 2);\n        o = 2;\n        for (i = t = 0, ref5 = n; 0 <= ref5 ? t < ref5 : t > ref5; i = 0 <= ref5 ? ++t : --t) {\n            for (j = u = 0; u < 4; j = ++u) {\n                for (k = w = 0; w < 2; k = ++w) {\n                    V_position2[(i * 4 + j - o) * 2 + k] = V_position[i * 2 + k];\n                    V_angles2[(i * 4 + j) * 2 + k] = V_angles[i * 2 + k];\n                }\n                for (k = y = 0; y < 4; k = ++y) {\n                    V_tangents2[(i * 4 + j - o) * 4 + k] = V_tangents[i * 4 + k];\n                }\n            }\n        }\n        for (i = z = 0, ref6 = n; 0 <= ref6 ? z <= ref6 : z >= ref6; i = 0 <= ref6 ? ++z : --z) {\n            V_texcoord2[(i * 4 + 0) * 2 + 0] = -1;\n            V_texcoord2[(i * 4 + 1) * 2 + 0] = -1;\n            V_texcoord2[(i * 4 + 2) * 2 + 0] = +1;\n            V_texcoord2[(i * 4 + 3) * 2 + 0] = +1;\n            V_texcoord2[(i * 4 + 0) * 2 + 1] = -1;\n            V_texcoord2[(i * 4 + 1) * 2 + 1] = +1;\n            V_texcoord2[(i * 4 + 2) * 2 + 1] = -1;\n            V_texcoord2[(i * 4 + 3) * 2 + 1] = +1;\n        }\n        ni = (n - 1) * 6;\n        this.I_triangles = I = new Uint32Array(ni);\n        results = [];\n        for (i = i1 = 0, ref7 = n; 0 <= ref7 ? i1 < ref7 : i1 > ref7; i = 0 <= ref7 ? ++i1 : --i1) {\n            I[i * 6 + 0] = 0 + 4 * i;\n            I[i * 6 + 1] = 1 + 4 * i;\n            I[i * 6 + 2] = 3 + 4 * i;\n            I[i * 6 + 3] = 2 + 4 * i;\n            I[i * 6 + 4] = 0 + 4 * i;\n            results.push(I[i * 6 + 5] = 3 + 4 * i);\n        }\n        return results;\n    };\n    LineGLGlyph.prototype._update_scale = function (sx, sy) {\n        var N, T, V_segment, V_segment2, cumsum, i, j, k, l, m, n, p, q, r, ref, ref1, ref2, s;\n        n = this.nvertices;\n        m = 4 * n - 4;\n        T = this.tangents;\n        N = new Float32Array(n - 1);\n        V_segment = new Float32Array(n * 2);\n        this.V_segment = V_segment2 = new Float32Array(m * 2);\n        for (i = l = 0, ref = n - 1; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {\n            N[i] = Math.sqrt(Math.pow(T[i * 2 + 0] * sx, 2) + Math.pow(T[i * 2 + 1] * sy, 2));\n        }\n        cumsum = 0;\n        for (i = p = 0, ref1 = n - 1; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {\n            cumsum += N[i];\n            V_segment[(i + 1) * 2 + 0] = cumsum;\n            V_segment[i * 2 + 1] = cumsum;\n        }\n        for (i = q = 0, ref2 = n; 0 <= ref2 ? q < ref2 : q > ref2; i = 0 <= ref2 ? ++q : --q) {\n            for (j = r = 0; r < 4; j = ++r) {\n                for (k = s = 0; s < 2; k = ++s) {\n                    V_segment2[(i * 4 + j) * 2 + k] = V_segment[i * 2 + k];\n                }\n            }\n        }\n        this.cumsum = cumsum;\n        this.vbo_segment.set_size(this.V_segment.length * 4);\n        return this.vbo_segment.set_data(0, this.V_segment);\n    };\n    return LineGLGlyph;\n})(base_1.BaseGLGlyph);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"./index\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MarkerGLGlyph, extend = function (child, parent) { for (var key in parent) {\n    if (hasProp.call(parent, key))\n        child[key] = parent[key];\n} function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, hasProp = {}.hasOwnProperty;\nvar gloo2 = require(\"gloo2\");\nvar logging_1 = require(\"core/logging\");\nvar base_1 = require(\"./base\");\nMarkerGLGlyph = (function (superClass) {\n    extend(MarkerGLGlyph, superClass);\n    function MarkerGLGlyph() {\n        return MarkerGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    MarkerGLGlyph.prototype.VERT = \"precision mediump float;\\nconst float SQRT_2 = 1.4142135623730951;\\n//\\nuniform float u_pixel_ratio;\\nuniform vec2 u_canvas_size;\\nuniform vec2 u_offset;\\nuniform vec2 u_scale;\\nuniform float u_antialias;\\n//\\nattribute float a_x;\\nattribute float a_y;\\nattribute float a_size;\\nattribute float a_angle;  // in radians\\nattribute float a_linewidth;\\nattribute vec4  a_fg_color;\\nattribute vec4  a_bg_color;\\n//\\nvarying float v_linewidth;\\nvarying float v_size;\\nvarying vec4  v_fg_color;\\nvarying vec4  v_bg_color;\\nvarying vec2  v_rotation;\\n\\nvoid main (void)\\n{\\n    v_size = a_size * u_pixel_ratio;\\n    v_linewidth = a_linewidth * u_pixel_ratio;\\n    v_fg_color = a_fg_color;\\n    v_bg_color = a_bg_color;\\n    v_rotation = vec2(cos(-a_angle), sin(-a_angle));\\n    // Calculate position - the -0.5 is to correct for canvas origin\\n    vec2 pos = (vec2(a_x, a_y) + u_offset) * u_scale; // in pixels\\n    pos += 0.5;  // make up for Bokeh's offset\\n    pos /= u_canvas_size / u_pixel_ratio;  // in 0..1\\n    gl_Position = vec4(pos*2.0-1.0, 0.0, 1.0);\\n    gl_Position.y *= -1.0;\\n    gl_PointSize = SQRT_2 * v_size + 2.0 * (v_linewidth + 1.5*u_antialias);\\n}\";\n    MarkerGLGlyph.prototype.FRAG = \"precision mediump float;\\nconst float SQRT_2 = 1.4142135623730951;\\nconst float PI = 3.14159265358979323846264;\\n//\\nuniform float u_antialias;\\n//\\nvarying vec4  v_fg_color;\\nvarying vec4  v_bg_color;\\nvarying float v_linewidth;\\nvarying float v_size;\\nvarying vec2  v_rotation;\\n\\nMARKERCODE\\n\\nvec4 outline(float distance, float linewidth, float antialias, vec4 fg_color, vec4 bg_color)\\n{\\n    vec4 frag_color;\\n    float t = linewidth/2.0 - antialias;\\n    float signed_distance = distance;\\n    float border_distance = abs(signed_distance) - t;\\n    float alpha = border_distance/antialias;\\n    alpha = exp(-alpha*alpha);\\n\\n    // If fg alpha is zero, it probably means no outline. To avoid a dark outline\\n    // shining through due to aa, we set the fg color to the bg color. Avoid if (i.e. branching).\\n    float select = float(bool(fg_color.a));\\n    fg_color.rgb = select * fg_color.rgb + (1.0  - select) * bg_color.rgb;\\n    // Similarly, if we want a transparent bg\\n    select = float(bool(bg_color.a));\\n    bg_color.rgb = select * bg_color.rgb + (1.0  - select) * fg_color.rgb;\\n\\n    if( border_distance < 0.0)\\n        frag_color = fg_color;\\n    else if( signed_distance < 0.0 ) {\\n        frag_color = mix(bg_color, fg_color, sqrt(alpha));\\n    } else {\\n        if( abs(signed_distance) < (linewidth/2.0 + antialias) ) {\\n            frag_color = vec4(fg_color.rgb, fg_color.a * alpha);\\n        } else {\\n            discard;\\n        }\\n    }\\n    return frag_color;\\n}\\n\\nvoid main()\\n{\\n    vec2 P = gl_PointCoord.xy - vec2(0.5, 0.5);\\n    P = vec2(v_rotation.x*P.x - v_rotation.y*P.y,\\n             v_rotation.y*P.x + v_rotation.x*P.y);\\n    float point_size = SQRT_2*v_size  + 2.0 * (v_linewidth + 1.5*u_antialias);\\n    float distance = marker(P*point_size, v_size);\\n    gl_FragColor = outline(distance, v_linewidth, u_antialias, v_fg_color, v_bg_color);\\n    //gl_FragColor.rgb *= gl_FragColor.a;  // pre-multiply alpha\\n}\";\n    MarkerGLGlyph.prototype.MARKERCODE = \"<defined in subclasses>\";\n    MarkerGLGlyph.prototype.init = function () {\n        var frag, gl;\n        gl = this.gl;\n        frag = this.FRAG.replace(/MARKERCODE/, this.MARKERCODE);\n        this.last_trans = {};\n        this.prog = new gloo2.Program(gl);\n        this.prog.set_shaders(this.VERT, frag);\n        this.vbo_x = new gloo2.VertexBuffer(gl);\n        this.prog.set_attribute('a_x', 'float', this.vbo_x);\n        this.vbo_y = new gloo2.VertexBuffer(gl);\n        this.prog.set_attribute('a_y', 'float', this.vbo_y);\n        this.vbo_s = new gloo2.VertexBuffer(gl);\n        this.prog.set_attribute('a_size', 'float', this.vbo_s);\n        this.vbo_a = new gloo2.VertexBuffer(gl);\n        this.prog.set_attribute('a_angle', 'float', this.vbo_a);\n        this.vbo_linewidth = new gloo2.VertexBuffer(gl);\n        this.vbo_fg_color = new gloo2.VertexBuffer(gl);\n        this.vbo_bg_color = new gloo2.VertexBuffer(gl);\n        return this.index_buffer = new gloo2.IndexBuffer(gl);\n    };\n    MarkerGLGlyph.prototype.draw = function (indices, mainGlyph, trans) {\n        var baked_offset, chunk, chunks, chunksize, i, j, k, l, mainGlGlyph, nvertices, offset, ref, ref1, ref2, results, s, these_indices, ua, uint16_index;\n        mainGlGlyph = mainGlyph.glglyph;\n        nvertices = mainGlGlyph.nvertices;\n        if (mainGlGlyph.data_changed) {\n            if (!(isFinite(trans.dx) && isFinite(trans.dy))) {\n                return;\n            }\n            mainGlGlyph._baked_offset = [trans.dx, trans.dy];\n            mainGlGlyph._set_data(nvertices);\n            mainGlGlyph.data_changed = false;\n        }\n        else if ((this.glyph._radius != null) && (trans.sx !== this.last_trans.sx || trans.sy !== this.last_trans.sy)) {\n            this.last_trans = trans;\n            this.vbo_s.set_data(0, new Float32Array((function () {\n                var j, len, ref, results;\n                ref = this.glyph.sradius;\n                results = [];\n                for (j = 0, len = ref.length; j < len; j++) {\n                    s = ref[j];\n                    results.push(s * 2);\n                }\n                return results;\n            }).call(this)));\n        }\n        if (this.visuals_changed) {\n            this._set_visuals(nvertices);\n            this.visuals_changed = false;\n        }\n        baked_offset = mainGlGlyph._baked_offset;\n        this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\n        this.prog.set_uniform('u_canvas_size', 'vec2', [trans.width, trans.height]);\n        this.prog.set_uniform('u_offset', 'vec2', [trans.dx - baked_offset[0], trans.dy - baked_offset[1]]);\n        this.prog.set_uniform('u_scale', 'vec2', [trans.sx, trans.sy]);\n        this.prog.set_attribute('a_x', 'float', mainGlGlyph.vbo_x);\n        this.prog.set_attribute('a_y', 'float', mainGlGlyph.vbo_y);\n        this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s);\n        this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a);\n        if (indices.length === 0) {\n        }\n        else if (indices.length === nvertices) {\n            return this.prog.draw(this.gl.POINTS, [0, nvertices]);\n        }\n        else if (nvertices < 65535) {\n            ua = window.navigator.userAgent;\n            if (ua.indexOf(\"MSIE \") + ua.indexOf(\"Trident/\") + ua.indexOf(\"Edge/\") > 0) {\n                logging_1.logger.warn('WebGL warning: IE is known to produce 1px sprites whith selections.');\n            }\n            this.index_buffer.set_size(indices.length * 2);\n            this.index_buffer.set_data(0, new Uint16Array(indices));\n            return this.prog.draw(this.gl.POINTS, this.index_buffer);\n        }\n        else {\n            chunksize = 64000;\n            chunks = [];\n            for (i = j = 0, ref = Math.ceil(nvertices / chunksize); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                chunks.push([]);\n            }\n            for (i = k = 0, ref1 = indices.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n                uint16_index = indices[i] % chunksize;\n                chunk = Math.floor(indices[i] / chunksize);\n                chunks[chunk].push(uint16_index);\n            }\n            results = [];\n            for (chunk = l = 0, ref2 = chunks.length; 0 <= ref2 ? l < ref2 : l > ref2; chunk = 0 <= ref2 ? ++l : --l) {\n                these_indices = new Uint16Array(chunks[chunk]);\n                offset = chunk * chunksize * 4;\n                if (these_indices.length === 0) {\n                    continue;\n                }\n                this.prog.set_attribute('a_x', 'float', mainGlGlyph.vbo_x, 0, offset);\n                this.prog.set_attribute('a_y', 'float', mainGlGlyph.vbo_y, 0, offset);\n                this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s, 0, offset);\n                this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a, 0, offset);\n                if (this.vbo_linewidth.used) {\n                    this.prog.set_attribute('a_linewidth', 'float', this.vbo_linewidth, 0, offset);\n                }\n                if (this.vbo_fg_color.used) {\n                    this.prog.set_attribute('a_fg_color', 'vec4', this.vbo_fg_color, 0, offset * 4);\n                }\n                if (this.vbo_bg_color.used) {\n                    this.prog.set_attribute('a_bg_color', 'vec4', this.vbo_bg_color, 0, offset * 4);\n                }\n                this.index_buffer.set_size(these_indices.length * 2);\n                this.index_buffer.set_data(0, these_indices);\n                results.push(this.prog.draw(this.gl.POINTS, this.index_buffer));\n            }\n            return results;\n        }\n    };\n    MarkerGLGlyph.prototype._set_data = function (nvertices) {\n        var i, j, n, ref, s, xx, yy;\n        n = nvertices * 4;\n        this.vbo_x.set_size(n);\n        this.vbo_y.set_size(n);\n        this.vbo_a.set_size(n);\n        this.vbo_s.set_size(n);\n        xx = new Float64Array(this.glyph._x);\n        yy = new Float64Array(this.glyph._y);\n        for (i = j = 0, ref = nvertices; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n            xx[i] += this._baked_offset[0];\n            yy[i] += this._baked_offset[1];\n        }\n        this.vbo_x.set_data(0, new Float32Array(xx));\n        this.vbo_y.set_data(0, new Float32Array(yy));\n        if (this.glyph._angle != null) {\n            this.vbo_a.set_data(0, new Float32Array(this.glyph._angle));\n        }\n        if (this.glyph._radius != null) {\n            return this.vbo_s.set_data(0, new Float32Array((function () {\n                var k, len, ref1, results;\n                ref1 = this.glyph.sradius;\n                results = [];\n                for (k = 0, len = ref1.length; k < len; k++) {\n                    s = ref1[k];\n                    results.push(s * 2);\n                }\n                return results;\n            }).call(this)));\n        }\n        else {\n            return this.vbo_s.set_data(0, new Float32Array(this.glyph._size));\n        }\n    };\n    MarkerGLGlyph.prototype._set_visuals = function (nvertices) {\n        base_1.attach_float(this.prog, this.vbo_linewidth, 'a_linewidth', nvertices, this.glyph.visuals.line, 'line_width');\n        base_1.attach_color(this.prog, this.vbo_fg_color, 'a_fg_color', nvertices, this.glyph.visuals.line, 'line');\n        base_1.attach_color(this.prog, this.vbo_bg_color, 'a_bg_color', nvertices, this.glyph.visuals.fill, 'fill');\n        return this.prog.set_uniform('u_antialias', 'float', [0.8]);\n    };\n    return MarkerGLGlyph;\n})(base_1.BaseGLGlyph);\nexports.CircleGLGlyph = (function (superClass) {\n    extend(CircleGLGlyph, superClass);\n    function CircleGLGlyph() {\n        return CircleGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    CircleGLGlyph.prototype.GLYPH = 'circle';\n    CircleGLGlyph.prototype.MARKERCODE = \"// --- disc\\nfloat marker(vec2 P, float size)\\n{\\n    return length(P) - size/2.0;\\n}\";\n    return CircleGLGlyph;\n})(MarkerGLGlyph);\nexports.SquareGLGlyph = (function (superClass) {\n    extend(SquareGLGlyph, superClass);\n    function SquareGLGlyph() {\n        return SquareGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    SquareGLGlyph.prototype.GLYPH = 'square';\n    SquareGLGlyph.prototype.MARKERCODE = \"// --- square\\nfloat marker(vec2 P, float size)\\n{\\n    return max(abs(P.x), abs(P.y)) - size/2.0;\\n}\";\n    return SquareGLGlyph;\n})(MarkerGLGlyph);\nexports.AnnulusGLGlyph = (function (superClass) {\n    extend(AnnulusGLGlyph, superClass);\n    function AnnulusGLGlyph() {\n        return AnnulusGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    AnnulusGLGlyph.prototype.GLYPH = 'annulus';\n    AnnulusGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    float r1 = length(P) - size/2.0;\\n    float r2 = length(P) - size/4.0;  // half width\\n    return max(r1, -r2);\\n}\";\n    return AnnulusGLGlyph;\n})(MarkerGLGlyph);\nexports.DiamondGLGlyph = (function (superClass) {\n    extend(DiamondGLGlyph, superClass);\n    function DiamondGLGlyph() {\n        return DiamondGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    DiamondGLGlyph.prototype.GLYPH = 'diamond';\n    DiamondGLGlyph.prototype.MARKERCODE = \"// --- diamond\\nfloat marker(vec2 P, float size)\\n{\\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\\n    float r1 = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\\n    return r1 / SQRT_2;\\n}\";\n    return DiamondGLGlyph;\n})(MarkerGLGlyph);\nexports.TriangleGLGlyph = (function (superClass) {\n    extend(TriangleGLGlyph, superClass);\n    function TriangleGLGlyph() {\n        return TriangleGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    TriangleGLGlyph.prototype.GLYPH = 'triangle';\n    TriangleGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    P.y -= size * 0.3;\\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\\n    float r2 = P.y;\\n    return max(r1 / SQRT_2, r2);  // Instersect diamond with rectangle\\n}\";\n    return TriangleGLGlyph;\n})(MarkerGLGlyph);\nexports.InvertedTriangleGLGlyph = (function (superClass) {\n    extend(InvertedTriangleGLGlyph, superClass);\n    function InvertedTriangleGLGlyph() {\n        return InvertedTriangleGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    InvertedTriangleGLGlyph.prototype.GLYPH = 'invertedtriangle';\n    InvertedTriangleGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    P.y += size * 0.3;\\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\\n    float r2 = - P.y;\\n    return max(r1 / SQRT_2, r2);  // Instersect diamond with rectangle\\n}\";\n    return InvertedTriangleGLGlyph;\n})(MarkerGLGlyph);\nexports.CrossGLGlyph = (function (superClass) {\n    extend(CrossGLGlyph, superClass);\n    function CrossGLGlyph() {\n        return CrossGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    CrossGLGlyph.prototype.GLYPH = 'cross';\n    CrossGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    float square = max(abs(P.x), abs(P.y)) - size / 2.5;  // 2.5 is a tweak\\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of \\\"width\\\" for aa\\n    return max(square, cross);\\n}\";\n    return CrossGLGlyph;\n})(MarkerGLGlyph);\nexports.CircleCrossGLGlyph = (function (superClass) {\n    extend(CircleCrossGLGlyph, superClass);\n    function CircleCrossGLGlyph() {\n        return CircleCrossGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    CircleCrossGLGlyph.prototype.GLYPH = 'circlecross';\n    CircleCrossGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float circle = length(P) - size/2.0;\\n    float c1 = max(circle, s1);\\n    float c2 = max(circle, s2);\\n    float c3 = max(circle, s3);\\n    float c4 = max(circle, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}\";\n    return CircleCrossGLGlyph;\n})(MarkerGLGlyph);\nexports.SquareCrossGLGlyph = (function (superClass) {\n    extend(SquareCrossGLGlyph, superClass);\n    function SquareCrossGLGlyph() {\n        return SquareCrossGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    SquareCrossGLGlyph.prototype.GLYPH = 'squarecross';\n    SquareCrossGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\\n    float c1 = max(square, s1);\\n    float c2 = max(square, s2);\\n    float c3 = max(square, s3);\\n    float c4 = max(square, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}\";\n    return SquareCrossGLGlyph;\n})(MarkerGLGlyph);\nexports.DiamondCrossGLGlyph = (function (superClass) {\n    extend(DiamondCrossGLGlyph, superClass);\n    function DiamondCrossGLGlyph() {\n        return DiamondCrossGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    DiamondCrossGLGlyph.prototype.GLYPH = 'diamondcross';\n    DiamondCrossGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\\n    float diamond = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\\n    diamond /= SQRT_2;\\n    float c1 = max(diamond, s1);\\n    float c2 = max(diamond, s2);\\n    float c3 = max(diamond, s3);\\n    float c4 = max(diamond, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}\";\n    return DiamondCrossGLGlyph;\n})(MarkerGLGlyph);\nexports.XGLGlyph = (function (superClass) {\n    extend(XGLGlyph, superClass);\n    function XGLGlyph() {\n        return XGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    XGLGlyph.prototype.GLYPH = 'x';\n    XGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    float circle = length(P) - size / 1.6;\\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \\\"width\\\" for aa\\n    return max(circle, X);\\n}\";\n    return XGLGlyph;\n})(MarkerGLGlyph);\nexports.CircleXGLGlyph = (function (superClass) {\n    extend(CircleXGLGlyph, superClass);\n    function CircleXGLGlyph() {\n        return CircleXGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    CircleXGLGlyph.prototype.GLYPH = 'circlex';\n    CircleXGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    float x = P.x - P.y;\\n    float y = P.x + P.y;\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float circle = length(P) - size/2.0;\\n    float c1 = max(circle, s1);\\n    float c2 = max(circle, s2);\\n    float c3 = max(circle, s3);\\n    float c4 = max(circle, s4);\\n    // Union\\n    float almost = min(min(min(c1, c2), c3), c4);\\n    // In this case, the X is also outside of the main shape\\n    float Xmask = length(P) - size / 1.6;  // a circle\\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \\\"width\\\" for aa\\n    return min(max(X, Xmask), almost);\\n}\";\n    return CircleXGLGlyph;\n})(MarkerGLGlyph);\nexports.SquareXGLGlyph = (function (superClass) {\n    extend(SquareXGLGlyph, superClass);\n    function SquareXGLGlyph() {\n        return SquareXGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    SquareXGLGlyph.prototype.GLYPH = 'squarex';\n    SquareXGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    float x = P.x - P.y;\\n    float y = P.x + P.y;\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\\n    float c1 = max(square, s1);\\n    float c2 = max(square, s2);\\n    float c3 = max(square, s3);\\n    float c4 = max(square, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}\";\n    return SquareXGLGlyph;\n})(MarkerGLGlyph);\nexports.AsteriskGLGlyph = (function (superClass) {\n    extend(AsteriskGLGlyph, superClass);\n    function AsteriskGLGlyph() {\n        return AsteriskGLGlyph.__super__.constructor.apply(this, arguments);\n    }\n    AsteriskGLGlyph.prototype.GLYPH = 'asterisk';\n    AsteriskGLGlyph.prototype.MARKERCODE = \"float marker(vec2 P, float size)\\n{\\n    // Masks\\n    float diamond = max(abs(SQRT_2 / 2.0 * (P.x - P.y)), abs(SQRT_2 / 2.0 * (P.x + P.y))) - size / (2.0 * SQRT_2);\\n    float square = max(abs(P.x), abs(P.y)) - size / (2.0 * SQRT_2);\\n    // Shapes\\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \\\"width\\\" for aa\\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of \\\"width\\\" for aa\\n    // Result is union of masked shapes\\n    return min(max(X, diamond), max(cross, square));\\n}\";\n    return AsteriskGLGlyph;\n})(MarkerGLGlyph);\n","/* Do not edit, autogenerated by flexx.pyscript */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else if (typeof exports !== 'undefined') {\n        // Node or CommonJS\n        module.exports = factory();\n        if (typeof window === 'undefined') {\n            root.gloo2 = module.exports;  // also create global module in Node\n        }\n    } else {\n        // Browser globals (root is window)\n        root.gloo2 = factory();\n    }\n}(this, function () {\n    var _pyfunc_add = function (a, b) { // nargs: 2\n        if (Array.isArray(a) && Array.isArray(b)) {\n            return a.concat(b);\n        } return a + b;\n    };\n    var _pyfunc_all = function (x) { // nargs: 1\n        for (var i=0; i<x.length; i++) {\n            if (!_pyfunc_truthy(x[i])){return false;}\n        } return true;\n    };\n    var _pyfunc_contains = function contains (a, b) { // nargs: 2\n        if (b == null) {\n        } else if (Array.isArray(b)) {\n            for (var i=0; i<b.length; i++) {if (_pyfunc_equals(a, b[i]))\n                                               return true;}\n            return false;\n        } else if (b.constructor === Object) {\n            for (var k in b) {if (a == k) return true;}\n            return false;\n        } else if (b.constructor == String) {\n            return b.indexOf(a) >= 0;\n        } var e = Error('Not a container: ' + b); e.name='TypeError'; throw e;\n    };\n    var _pyfunc_equals = function equals (a, b) { // nargs: 2\n        if (a == null || b == null) {\n        } else if (Array.isArray(a) && Array.isArray(b)) {\n            var i = 0, iseq = a.length == b.length;\n            while (iseq && i < a.length) {iseq = equals(a[i], b[i]); i+=1;}\n            return iseq;\n        } else if (a.constructor === Object && b.constructor === Object) {\n            var akeys = Object.keys(a), bkeys = Object.keys(b);\n            akeys.sort(); bkeys.sort();\n            var i=0, k, iseq = equals(akeys, bkeys);\n            while (iseq && i < akeys.length) {k=akeys[i]; iseq = equals(a[k], b[k]); i+=1;}\n            return iseq;\n        } return a == b;\n    };\n    var _pyfunc_instantiate = function (ob, args) { // nargs: 2\n        if ((typeof ob === \"undefined\") ||\n                (typeof window !== \"undefined\" && window === ob) ||\n                (typeof global !== \"undefined\" && global === ob))\n                {throw \"Class constructor is called as a function.\";}\n        for (var name in ob) {\n            if (Object[name] === undefined &&\n                typeof ob[name] === 'function' && !ob[name].nobind) {\n                ob[name] = ob[name].bind(ob);\n            }\n        }\n        if (ob.__init__) {\n            ob.__init__.apply(ob, args);\n        }\n    };\n    var _pyfunc_mult = function (a, b) { // nargs: 2\n        if ((typeof a === 'number') + (typeof b === 'number') === 1) {\n            if (a.constructor === String) return _pymeth_repeat.call(a, b);\n            if (b.constructor === String) return _pymeth_repeat.call(b, a);\n            if (Array.isArray(b)) {var t=a; a=b; b=t;}\n            if (Array.isArray(a)) {\n                var res = []; for (var i=0; i<b; i++) res = res.concat(a);\n                return res;\n            }\n        } return a * b;\n    };\n    var _pyfunc_range = function (start, end, step) {\n    var i, res = [];\n        var val = start;\n        var n = (end - start) / step;\n        for (i=0; i<n; i++) {\n            res.push(val);\n            val += step;\n        }\n        return res;\n    };\n    var _pyfunc_truthy = function (v) {\n        if (v === null || typeof v !== \"object\") {return v;}\n        else if (v.length !== undefined) {return v.length ? v : false;}\n        else if (v.byteLength !== undefined) {return v.byteLength ? v : false;}\n        else if (v.constructor !== Object) {return true;}\n        else {return Object.getOwnPropertyNames(v).length ? v : false;}\n    };\n    var _pymeth_append = function (x) { // nargs: 1\n        if (!Array.isArray(this)) return this.append.apply(this, arguments);\n        this.push(x);\n    };\n    var _pymeth_get = function (key, d) { // nargs: 1 2\n        if (this.constructor !== Object) return this.get.apply(this, arguments);\n        if (this[key] !== undefined) {return this[key];}\n        else if (d !== undefined) {return d;}\n        else {return null;}\n    };\n    var _pymeth_keys = function () { // nargs: 0\n        if (typeof this['keys'] === 'function') return this.keys.apply(this, arguments);\n        return Object.keys(this);\n    };\n    var _pymeth_lstrip = function (chars) { // nargs: 0 1\n        if (this.constructor !== String) return this.lstrip.apply(this, arguments);\n        chars = (chars === undefined) ? ' \\t\\r\\n' : chars;\n        for (var i=0; i<this.length; i++) {\n            if (chars.indexOf(this[i]) < 0) return this.slice(i);\n        } return '';\n    };\n    var _pymeth_remove = function (x) { // nargs: 1\n        if (!Array.isArray(this)) return this.remove.apply(this, arguments);\n        for (var i=0; i<this.length; i++) {\n            if (_pyfunc_equals(this[i], x)) {this.splice(i, 1); return;}\n        }\n        var e = Error(x); e.name='ValueError'; throw e;\n    };\n    var _pymeth_repeat = function(count) { // nargs: 0\n        if (this.repeat) return this.repeat(count);\n        if (count < 1) return '';\n        var result = '', pattern = this.valueOf();\n        while (count > 1) {\n            if (count & 1) result += pattern;\n            count >>= 1, pattern += pattern;\n        }\n        return result + pattern;\n    };\n    var _pymeth_startswith = function (x) { // nargs: 1\n        if (this.constructor !== String) return this.startswith.apply(this, arguments);\n        return this.indexOf(x) == 0;\n    };\n    var Buffer, GlooObject, IndexBuffer, Program, Texture2D, Texture3DLike, VertexBuffer, __version__, check_error, console;\n    // PyScript module for gloo2.js - lightweight object oriented GL.\n\n    { /* if this_is_js() */\n    console = window.console;\n    }\n    __version__ = \"0.3\";\n    check_error = function (gl, when) {\n        var e, err, err_3, errors, msg, stub1_seq, stub2_itr;\n        when = (when === undefined) ? \"periodic check\": when;\n        // Check this from time to time to detect GL errors.\n        // \n        //     Parameters\n        //     ----------\n        //     when : str\n        //         Shown in the exception to help the developer determine when\n        //         this check was done.\n        errors = [];\n        while (true) {\n            err = gl.getError();\n            if ((_pyfunc_equals(err, gl.NO_ERROR) || (_pyfunc_truthy(errors) && _pyfunc_equals(err, errors[errors.length -1])))) {\n                break;\n            }\n            _pymeth_append.call(errors, err);\n        }\n        if (errors.length) {\n            msg = \"\";\n            stub1_seq = errors;\n            if ((typeof stub1_seq === \"object\") && (!Array.isArray(stub1_seq))) {\n                stub1_seq = Object.keys(stub1_seq);\n            }\n            for (stub2_itr = 0; stub2_itr < stub1_seq.length; stub2_itr += 1) {\n                e = stub1_seq[stub2_itr];\n                msg=_pyfunc_add(msg, e)\n            }\n            err_3 = new Error('RuntimeError:' + (\"OpenGL got errors (\" + when + \"): \" + msg + \"\")); err_3.name = \"RuntimeError\"; throw err_3;\n        }\n        return null;\n    };\n\n    GlooObject = function () {\n        // Abstract base class for all Gloo classes.\n        _pyfunc_instantiate(this, arguments);\n    }\n    GlooObject.prototype._base_class = Object;\n    GlooObject.prototype._class_name = \"GlooObject\";\n    \n    GlooObject.prototype.__init__ = function (gl) {\n        // Init by passing the webgl context object.\n        this._gl = gl;\n        this.handle = null;\n        this._create();\n        if (!(this.handle !== null)) {throw \"AssertionError: \" + \"this.handle !== null\";}\n        return null;\n    };\n\n    GlooObject.prototype._create = function () {\n        var err_2;\n        err_2 = new Error('NotImplementedError:' + \"\"); err_2.name = \"NotImplementedError\"; throw err_2;\n        return null;\n    };\n\n\n    Program = function () {\n        // The program is the central component to connect gloo objects and shaders.\n        _pyfunc_instantiate(this, arguments);\n    }\n    Program.prototype = Object.create(GlooObject.prototype);\n    Program.prototype._base_class = GlooObject.prototype;\n    Program.prototype._class_name = \"Program\";\n    \n    Program.prototype.UTYPEMAP = {\"float\": \"uniform1fv\", \"vec2\": \"uniform2fv\", \"vec3\": \"uniform3fv\", \"vec4\": \"uniform4fv\", \"int\": \"uniform1iv\", \"ivec2\": \"uniform2iv\", \"ivec3\": \"uniform3iv\", \"ivec4\": \"uniform4iv\", \"bool\": \"uniform1iv\", \"bvec2\": \"uniform2iv\", \"bvec3\": \"uniform3iv\", \"bvec4\": \"uniform4iv\", \"mat2\": \"uniformMatrix2fv\", \"mat3\": \"uniformMatrix3fv\", \"mat4\": \"uniformMatrix4fv\", \"sampler1D\": \"uniform1i\", \"sampler2D\": \"uniform1i\", \"sampler3D\": \"uniform1i\"};\n    Program.prototype.ATYPEMAP = {\"float\": \"vertexAttrib1f\", \"vec2\": \"vertexAttrib2f\", \"vec3\": \"vertexAttrib3f\", \"vec4\": \"vertexAttrib4f\"};\n    Program.prototype.ATYPEINFO = {\"float\": [1, 5126], \"vec2\": [2, 5126], \"vec3\": [3, 5126], \"vec4\": [4, 5126]};\n    Program.prototype._create = function () {\n        this.handle = this._gl.createProgram();\n        this.locations = {};\n        this._unset_variables = [];\n        this._validated = false;\n        this._samplers = {};\n        this._attributes = {};\n        this._known_invalid = [];\n        return null;\n    };\n\n    Program.prototype.delete = function () {\n        // Delete the program.\n        this._gl.deleteProgram(this.handle);\n        return null;\n    };\n\n    Program.prototype.activate = function () {\n        // Activate the program.\n        this._gl.useProgram(this.handle);\n        return null;\n    };\n\n    Program.prototype.deactivate = function () {\n        // Disable the program.\n        this._gl.useProgram(0);\n        return null;\n    };\n\n    Program.prototype.set_shaders = function (vert, frag) {\n        var code, err_3, err_4, errors, frag_handle, gl, handle, i, status, stub3_, tmp, type_, vert_handle;\n        // Set GLSL code for the vertex and fragment shader.\n        // \n        // This function takes care of setting the shading code and\n        // compiling+linking it into a working program object that is ready\n        // to use.\n        // \n        // Parameters\n        // ----------\n        // vert : str\n        //     GLSL code for the vertex shader.\n        // frag : str\n        //     GLSL code for the fragment shader.\n        gl = this._gl;\n        this._linked = false;\n        vert_handle = gl.createShader(gl.VERTEX_SHADER);\n        frag_handle = gl.createShader(gl.FRAGMENT_SHADER);\n        tmp = [[vert, vert_handle, \"vertex\"], [frag, frag_handle, \"fragment\"]];\n        for (i = 0; i < 2; i += 1) {\n            stub3_ = tmp[i];\n            code = stub3_[0];handle = stub3_[1];type_ = stub3_[2];\n            gl.shaderSource(handle, code);\n            gl.compileShader(handle);\n            status = gl.getShaderParameter(handle, gl.COMPILE_STATUS);\n            if ((!_pyfunc_truthy(status))) {\n                errors = gl.getShaderInfoLog(handle);\n                err_4 = new Error('RuntimeError:' + (_pyfunc_add(((\"errors in \" + type_) + \" shader:\\n\"), errors))); err_4.name = \"RuntimeError\"; throw err_4;\n            }\n        }\n        gl.attachShader(this.handle, vert_handle);\n        gl.attachShader(this.handle, frag_handle);\n        gl.linkProgram(this.handle);\n        if ((!_pyfunc_truthy(gl.getProgramParameter(this.handle, gl.LINK_STATUS)))) {\n            err_3 = new Error('RuntimeError:' + (\"Program link error:\\n\" + gl.getProgramInfoLog(this.handle))); err_3.name = \"RuntimeError\"; throw err_3;\n        }\n        this._unset_variables = this._get_active_attributes_and_uniforms();\n        gl.detachShader(this.handle, vert_handle);\n        gl.detachShader(this.handle, frag_handle);\n        gl.deleteShader(vert_handle);\n        gl.deleteShader(frag_handle);\n        this._known_invalid = [];\n        this._linked = true;\n        return null;\n    };\n\n    Program.prototype._get_active_attributes_and_uniforms = function () {\n        var attributes, ca, container, count, cu, getActive, getLocation, gl, i, info, j, m, name, regex, stub4_, stub5_seq, stub6_itr, uniforms, x;\n        // Retrieve active attributes and uniforms to be able to check that\n        // all uniforms/attributes are set by the user.\n        gl = this._gl;\n        this.locations = {};\n        regex = new window.RegExp(\"(\\\\w+)\\\\s*(\\\\[(\\\\d+)\\\\])\\\\s*\");\n        cu = gl.getProgramParameter(this.handle, gl.ACTIVE_UNIFORMS);\n        ca = gl.getProgramParameter(this.handle, gl.ACTIVE_ATTRIBUTES);\n        attributes = [];\n        uniforms = [];\n        stub5_seq = [[attributes, ca, gl.getActiveAttrib, gl.getAttribLocation], [uniforms, cu, gl.getActiveUniform, gl.getUniformLocation]];\n        if ((typeof stub5_seq === \"object\") && (!Array.isArray(stub5_seq))) {\n            stub5_seq = Object.keys(stub5_seq);\n        }\n        for (stub6_itr = 0; stub6_itr < stub5_seq.length; stub6_itr += 1) {\n            x = stub5_seq[stub6_itr];\n            stub4_ = x;\n            container = stub4_[0];count = stub4_[1];getActive = stub4_[2];getLocation = stub4_[3];\n            for (i = 0; i < count; i += 1) {\n                info = getActive.call(gl, this.handle, i);\n                name = info.name;\n                m = name.match(regex);\n                if (_pyfunc_truthy(m)) {\n                    name = m[1];\n                    for (j = 0; j < info.size; j += 1) {\n                        _pymeth_append.call(container, ([\"\" + name + \"[\" + j + \"]\", info.type]));\n                    }\n                } else {\n                    _pymeth_append.call(container, [name, info.type]);\n                }\n                this.locations[name] = getLocation.call(gl, this.handle, name);\n            }\n        }\n        return _pyfunc_add(((function list_comprehenson () {var res = [];var v, iter0, i0;iter0 = attributes;if ((typeof iter0 === \"object\") && (!Array.isArray(iter0))) {iter0 = Object.keys(iter0);}for (i0=0; i0<iter0.length; i0++) {v = iter0[i0];{res.push(v[0]);}}return res;}).apply(this)), ((function list_comprehenson () {var res = [];var v, iter0, i0;iter0 = uniforms;if ((typeof iter0 === \"object\") && (!Array.isArray(iter0))) {iter0 = Object.keys(iter0);}for (i0=0; i0<iter0.length; i0++) {v = iter0[i0];{res.push(v[0]);}}return res;}).apply(this)));\n    };\n\n    Program.prototype.set_texture = function (name, value) {\n        var err_3, handle, unit;\n        // Set a texture sampler.\n        // \n        // A texture is a 2 dimensional grid of colors/intensities that\n        // can be applied to a face (or used for other means by providing\n        // a regular grid of data).\n        // \n        // Parameters\n        // ----------\n        // name : str\n        //     The name by which the texture is known in the GLSL code.\n        // value : Texture2D\n        //     The gloo Texture2D object to bind.\n        if ((!_pyfunc_truthy(this._linked))) {\n            err_3 = new Error('RuntimeError:' + \"Cannot set uniform when program has no code\"); err_3.name = \"RuntimeError\"; throw err_3;\n        }\n        handle = _pymeth_get.call(this.locations, name, (-1));\n        if (_pyfunc_truthy(handle < 0)) {\n            if ((!_pyfunc_contains(name, this._known_invalid))) {\n                _pymeth_append.call(this._known_invalid, name);\n                console.log(\"Variable \" + name + \" is not an active texture\");\n            }\n            return null;\n        }\n        if (_pyfunc_contains(name, this._unset_variables)) {\n            _pymeth_remove.call(this._unset_variables, name);\n        }\n        this.activate();\n        if (true) {\n            unit = _pymeth_keys.call(this._samplers).length;\n            if (_pyfunc_contains(name, this._samplers)) {\n                unit = this._samplers[name][this._samplers[name].length -1];\n            }\n            this._samplers[name] = [value._target, value.handle, unit];\n            this._gl.uniform1i(handle, unit);\n        }\n        return null;\n    };\n\n    Program.prototype.set_uniform = function (name, type_, value) {\n        var a_type, count, err_3, funcname, handle, j, name_;\n        // Set a uniform value.\n        // \n        // A uniform is a value that is global to both the vertex and\n        // fragment shader.\n        // \n        // Parameters\n        // ----------\n        // name : str\n        //     The name by which the uniform is known in the GLSL code.\n        // type_ : str\n        //     The type of the uniform, e.g. 'float', 'vec2', etc.\n        // value : list of scalars\n        //     The value for the uniform. Should be a list even for type float.\n        if ((!_pyfunc_truthy(this._linked))) {\n            err_3 = new Error('RuntimeError:' + \"Cannot set uniform when program has no code\"); err_3.name = \"RuntimeError\"; throw err_3;\n        }\n        handle = _pymeth_get.call(this.locations, name, (-1));\n        if (_pyfunc_truthy(handle < 0)) {\n            if ((!_pyfunc_contains(name, this._known_invalid))) {\n                _pymeth_append.call(this._known_invalid, name);\n                console.log(\"Variable \" + name + \" is not an active uniform\");\n            }\n            return null;\n        }\n        if (_pyfunc_contains(name, this._unset_variables)) {\n            _pymeth_remove.call(this._unset_variables, name);\n        }\n        count = 1;\n        if ((!_pymeth_startswith.call(type_, \"mat\"))) {\n            a_type = _pymeth_get.call({\"int\": \"float\", \"bool\": \"float\"}, type_, _pymeth_lstrip.call(type_, \"ib\"));\n            count = Math.floor(value.length/(this.ATYPEINFO[a_type][0]));\n        }\n        if (_pyfunc_truthy(count > 1)) {\n            for (j = 0; j < count; j += 1) {\n                if ((_pyfunc_contains((\"\" + name + \"[\" + j + \"]\"), this._unset_variables))) {\n                    name_ = \"\" + name + \"[\" + j + \"]\";\n                    if (_pyfunc_contains(name_, this._unset_variables)) {\n                        _pymeth_remove.call(this._unset_variables, name_);\n                    }\n                }\n            }\n        }\n        funcname = this.UTYPEMAP[type_];\n        this.activate();\n        if (_pymeth_startswith.call(type_, \"mat\")) {\n            this._gl[funcname](handle, false, value);\n        } else {\n            this._gl[funcname](handle, value);\n        }\n        return null;\n    };\n\n    Program.prototype.set_attribute = function (name, type_, value, stride, offset) {\n        var args, err_3, funcname, gtype, handle, is_vbo, size, stub7_;\n        stride = (stride === undefined) ? 0: stride;\n        offset = (offset === undefined) ? 0: offset;\n        // Set an attribute value. \n        // \n        // An attribute represents per-vertex data and can only be used\n        // in the vertex shader.\n        // \n        // Parameters\n        // ----------\n        // name : str\n        //     The name by which the attribute is known in the GLSL code.\n        // type_ : str\n        //     The type of the attribute, e.g. 'float', 'vec2', etc.\n        // value : VertexBuffer, array\n        //     If value is a VertexBuffer, it is used (with stride and offset)\n        //     for the vertex data. If value is an array, its used to set\n        //     the value of all vertices (similar to a uniform).\n        // stide : int, default 0\n        //     The stride to \"sample\" the vertex data inside the buffer. Unless\n        //     multiple vertex data are packed into a single buffer, this should\n        //     be zero.\n        // offset : int, default 0\n        //     The offset to \"sample\" the vertex data inside the buffer. Unless\n        //     multiple vertex data are packed into a single buffer, or only\n        //     a part of the data must be used, this should probably be zero.\n        if ((!_pyfunc_truthy(this._linked))) {\n            err_3 = new Error('RuntimeError:' + \"Cannot set attribute when program has no code\"); err_3.name = \"RuntimeError\"; throw err_3;\n        }\n        is_vbo = value instanceof VertexBuffer;\n        handle = _pymeth_get.call(this.locations, name, (-1));\n        if (_pyfunc_truthy(handle < 0)) {\n            if ((!_pyfunc_contains(name, this._known_invalid))) {\n                _pymeth_append.call(this._known_invalid, name);\n                if ((_pyfunc_truthy(is_vbo) && _pyfunc_truthy(offset > 0))) {\n                } else {\n                    console.log(\"Variable \" + name + \" is not an active attribute\");\n                }\n            }\n            return null;\n        }\n        if (_pyfunc_contains(name, this._unset_variables)) {\n            _pymeth_remove.call(this._unset_variables, name);\n        }\n        this.activate();\n        if ((!_pyfunc_truthy(is_vbo))) {\n            funcname = this.ATYPEMAP[type_];\n            this._attributes[name] = [0, handle, funcname, value];\n        } else {\n            stub7_ = this.ATYPEINFO[type_];\n            size = stub7_[0];gtype = stub7_[1];\n            funcname = \"vertexAttribPointer\";\n            args = [size, gtype, this._gl.FALSE, stride, offset];\n            this._attributes[name] = [value.handle, handle, funcname, args];\n        }\n        return null;\n    };\n\n    Program.prototype._pre_draw = function () {\n        var args, attr_handle, funcname, stub10_, stub11_seq, stub8_, stub9_seq, tex_handle, tex_target, unit, vbo_handle, x;\n        // Prepare for drawing.\n        this.activate();\n        stub9_seq = this._samplers;\n        for (x in stub9_seq) {\n            if (!stub9_seq.hasOwnProperty(x)){ continue; }\n            x = stub9_seq[x];\n            stub8_ = x;\n            tex_target = stub8_[0];tex_handle = stub8_[1];unit = stub8_[2];\n            this._gl.activeTexture(_pyfunc_add(this._gl.TEXTURE0, unit));\n            this._gl.bindTexture(tex_target, tex_handle);\n        }\n        stub11_seq = this._attributes;\n        for (x in stub11_seq) {\n            if (!stub11_seq.hasOwnProperty(x)){ continue; }\n            x = stub11_seq[x];\n            stub10_ = x;\n            vbo_handle = stub10_[0];attr_handle = stub10_[1];funcname = stub10_[2];args = stub10_[3];\n            if (_pyfunc_truthy(vbo_handle)) {\n                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, vbo_handle);\n                this._gl.enableVertexAttribArray(attr_handle);\n                this._gl[funcname].apply(this._gl, [].concat([attr_handle], args));\n            } else {\n                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, null);\n                this._gl.disableVertexAttribArray(attr_handle);\n                this._gl[funcname].apply(this._gl, [].concat([attr_handle], args));\n            }\n        }\n        if ((!_pyfunc_truthy(this._validated))) {\n            this._validated = true;\n            this._validate();\n        }\n        return null;\n    };\n\n    Program.prototype._validate = function () {\n        var err_3;\n        if (this._unset_variables.length) {\n            console.log(\"Program has unset variables: \" + this._unset_variables + \"\");\n        }\n        this._gl.validateProgram(this.handle);\n        if ((!_pyfunc_truthy(this._gl.getProgramParameter(this.handle, this._gl.VALIDATE_STATUS)))) {\n            console.log(this._gl.getProgramInfoLog(this.handle));\n            err_3 = new Error('RuntimeError:' + \"Program validation error\"); err_3.name = \"RuntimeError\"; throw err_3;\n        }\n        return null;\n    };\n\n    Program.prototype.draw = function (mode, selection) {\n        var count, err_3, first, gtype, stub12_;\n        // Draw the current visualization defined by the program.\n        // \n        // Parameters\n        // ----------\n        // mode : GL enum\n        //     Can be POINTS, LINES, LINE_LOOP, LINE_STRIP, LINE_FAN, TRIANGLES\n        // selection : 2-element tuple or IndexBuffer\n        //     The selection to draw, specified either as (first, count) or an\n        //     IndexBuffer object.\n        if ((!_pyfunc_truthy(this._linked))) {\n            err_3 = new Error('RuntimeError:' + \"Cannot draw program if code has not been set\"); err_3.name = \"RuntimeError\"; throw err_3;\n        }\n        check_error(this._gl, \"before draw\");\n        if (_pyfunc_truthy(selection instanceof IndexBuffer)) {\n            this._pre_draw();\n            selection.activate();\n            count = selection._buffer_size / 2;\n            gtype = this._gl.UNSIGNED_SHORT;\n            this._gl.drawElements(mode, count, gtype, 0);\n            selection.deactivate();\n        } else {\n            stub12_ = selection;\n            first = stub12_[0];count = stub12_[1];\n            if (_pyfunc_truthy(count)) {\n                this._pre_draw();\n                this._gl.drawArrays(mode, first, count);\n            }\n        }\n        check_error(this._gl, \"after draw\");\n        return null;\n    };\n\n\n    Buffer = function () {\n        // Base buffer class for vertex data or index data.\n        _pyfunc_instantiate(this, arguments);\n    }\n    Buffer.prototype = Object.create(GlooObject.prototype);\n    Buffer.prototype._base_class = GlooObject.prototype;\n    Buffer.prototype._class_name = \"Buffer\";\n    \n    Buffer.prototype._target = null;\n    Buffer.prototype._usage = 35048;\n    Buffer.prototype._create = function () {\n        this.handle = this._gl.createBuffer();\n        this._buffer_size = 0;\n        return null;\n    };\n\n    Buffer.prototype.delete = function () {\n        // Delete the buffer.\n        this._gl.deleteBuffer(this.handle);\n        return null;\n    };\n\n    Buffer.prototype.activate = function () {\n        // Activete the buffer.\n        this._gl.bindBuffer(this._target, this.handle);\n        return null;\n    };\n\n    Buffer.prototype.deactivate = function () {\n        // Disable the buffer.\n        this._gl.bindBuffer(this._target, null);\n        return null;\n    };\n\n    Buffer.prototype.set_size = function (nbytes) {\n        // Set the size of the buffer in bytes.\n        // \n        // Parameters\n        // ----------\n        // nbytes : int\n        //     The number of bytes that the buffer needs to hold.\n        if ((!_pyfunc_equals(nbytes, this._buffer_size))) {\n            this.activate();\n            this._gl.bufferData(this._target, nbytes, this._usage);\n            this._buffer_size = nbytes;\n        }\n        return null;\n    };\n\n    Buffer.prototype.set_data = function (offset, data) {\n        // Set the buffer data.\n        // \n        // Parameters\n        // ----------\n        // offset : int\n        //     The offset in bytes for the new data.\n        // data : typed array\n        //     The data to upload.\n        this.activate();\n        this._gl.bufferSubData(this._target, offset, data);\n        return null;\n    };\n\n\n    VertexBuffer = function () {\n        // A buffer for vertex data.\n        _pyfunc_instantiate(this, arguments);\n    }\n    VertexBuffer.prototype = Object.create(Buffer.prototype);\n    VertexBuffer.prototype._base_class = Buffer.prototype;\n    VertexBuffer.prototype._class_name = \"VertexBuffer\";\n    \n    VertexBuffer.prototype._target = 34962;\n\n    IndexBuffer = function () {\n        // A buffer for index data.\n        _pyfunc_instantiate(this, arguments);\n    }\n    IndexBuffer.prototype = Object.create(Buffer.prototype);\n    IndexBuffer.prototype._base_class = Buffer.prototype;\n    IndexBuffer.prototype._class_name = \"IndexBuffer\";\n    \n    IndexBuffer.prototype._target = 34963;\n\n    Texture2D = function () {\n        // A 2 dimensional regular grid.\n        _pyfunc_instantiate(this, arguments);\n    }\n    Texture2D.prototype = Object.create(GlooObject.prototype);\n    Texture2D.prototype._base_class = GlooObject.prototype;\n    Texture2D.prototype._class_name = \"Texture2D\";\n    \n    Texture2D.prototype._target = 3553;\n    Texture2D.prototype._types = {\"Int8Array\": 5120, \"Uint8Array\": 5121, \"Int16Array\": 5122, \"Uint16Array\": 5123, \"Int32Array\": 5124, \"Uint32Array\": 5125, \"Float32Array\": 5126};\n    Texture2D.prototype._create = function () {\n        this.handle = this._gl.createTexture();\n        this._shape_format = null;\n        return null;\n    };\n\n    Texture2D.prototype.delete = function () {\n        // Delete the texture.\n        this._gl.deleteTexture(this.handle);\n        return null;\n    };\n\n    Texture2D.prototype.activate = function () {\n        // Activate the texture.\n        this._gl.bindTexture(this._target, this.handle);\n        return null;\n    };\n\n    Texture2D.prototype.deactivate = function () {\n        // Disable the texture.\n        this._gl.bindTexture(this._target, 0);\n        return null;\n    };\n\n    Texture2D.prototype._get_alignment = function (width) {\n        var alignment, alignments, stub13_seq, stub14_itr;\n        // Determines a textures byte alignment. If the width isn't a\n        //         power of 2 we need to adjust the byte alignment of the image.\n        //         The image height is unimportant.\n        // \n        //         www.opengl.org/wiki/Common_Mistakes#Texture_upload_and_pixel_reads\n        alignments = [4, 8, 2, 1];\n        stub13_seq = alignments;\n        if ((typeof stub13_seq === \"object\") && (!Array.isArray(stub13_seq))) {\n            stub13_seq = Object.keys(stub13_seq);\n        }\n        for (stub14_itr = 0; stub14_itr < stub13_seq.length; stub14_itr += 1) {\n            alignment = stub13_seq[stub14_itr];\n            if ((_pyfunc_equals((width % alignment), 0))) {\n                return alignment;\n            }\n        }\n        return null;\n    };\n\n    Texture2D.prototype.set_wrapping = function (wrap_s, wrap_t) {\n        // Set the texture wrapping mode.\n        // \n        // Parameters\n        // ----------\n        // wrap_s : GL enum\n        //     The mode to wrap the x dimension. Valid values are REPEAT\n        //     CLAMP_TO_EDGE MIRRORED_REPEAT\n        // wrap_t : GL enum\n        //     The mode to wrap the y dimension. Same options as for wrap_s.\n        this.activate();\n        this._gl.texParameterf(this._target, this._gl.TEXTURE_WRAP_S, wrap_s);\n        this._gl.texParameterf(this._target, this._gl.TEXTURE_WRAP_T, wrap_t);\n        return null;\n    };\n\n    Texture2D.prototype.set_interpolation = function (min, mag) {\n        // Set the texture interpolation mode\n        // \n        // Parameters\n        // ----------\n        // min : GL enum\n        //     The interpolation mode when minifying (i.e. zoomed out). Valid\n        //     values are LINEAR and NEAREST.\n        // max : GL enum\n        //     The interpolation mode when magnifying (i.e. zoomed in). Valid\n        //     values are LINEAR, NEAREST, NEAREST_MIPMAP_NEAREST,\n        //     LINEAR_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_LINEAR.\n        this.activate();\n        this._gl.texParameterf(this._target, this._gl.TEXTURE_MIN_FILTER, min);\n        this._gl.texParameterf(this._target, this._gl.TEXTURE_MAG_FILTER, mag);\n        return null;\n    };\n\n    Texture2D.prototype.set_size = function (shape, format) {\n        var height, stub15_, width;\n        // Set the size of the 2D texture.\n        // \n        // Parameters\n        // ----------\n        // shape : tuple of ints\n        //     The shape of the data to upload\n        // format : GL enum\n        //     The format of the texture data. Can be LUMINANCE, LUMINANCE_ALPHA,\n        //     RGB, and RGBA.\n        stub15_ = shape;\n        height = stub15_[0];width = stub15_[1];\n        if ((!_pyfunc_equals([height, width, format], this._shape_format))) {\n            this._shape_format = [height, width, format];\n            this.activate();\n            this._gl.texImage2D(this._target, 0, format, width, height, 0, format, this._gl.UNSIGNED_BYTE, null);\n        }\n        this.u_shape = [height, width];\n        return null;\n    };\n\n    Texture2D.prototype.set_data = function (offset, shape, data) {\n        var _, alignment, err_3, format, gtype, height, stub16_, stub17_, width, x, y;\n        // Set the 2D texture data.\n        // \n        // Parameters\n        // ----------\n        // offset : tuple of ints\n        //     Offset in pixels for each dimension.\n        // shape : tuple of ints\n        //     The shape of the data to upload\n        // data : typed array\n        //     The actual pixel data. Can be of any type, but on the GPU the\n        //     dat is stored in 8 bit precision.\n        if (_pyfunc_equals(shape.length, 2)) {\n            shape = [shape[0], shape[1], 1];\n        }\n        this.activate();\n        format = this._shape_format[2];\n        stub16_ = shape;\n        height = stub16_[0];width = stub16_[1];_ = stub16_[2];\n        stub17_ = offset;\n        y = stub17_[0];x = stub17_[1];\n        gtype = _pymeth_get.call(this._types, data.constructor.name, null);\n        if ((gtype === null)) {\n            err_3 = new Error('ValueError:' + (\"Type \" + data.constructor.name + \" not allowed for texture\")); err_3.name = \"ValueError\"; throw err_3;\n        }\n        alignment = this._get_alignment(_pyfunc_mult(shape[shape.length -2], shape[shape.length -1]));\n        if ((!_pyfunc_equals(alignment, 4))) {\n            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, alignment);\n        }\n        this._gl.texSubImage2D(this._target, 0, x, y, width, height, format, gtype, data);\n        if ((!_pyfunc_equals(alignment, 4))) {\n            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 4);\n        }\n        return null;\n    };\n\n\n    Texture3DLike = function () {\n        // A 2D texture with support to simulate a 3D texture.\n        // \n        // To use this class, use set_size() and set_data() as if it was a 3D\n        // texture. Add the GLSL_SAMPLE_NEAREST or GLSL_SAMPLE_LINEAR to the\n        // shader to add the sample3D() function that can be used instead of\n        // texture2D(). This function needs ``shape`` and ``tiles`` arguments\n        // which can be set via uniforms, using the ``u_shape`` and ``u_tiles``\n        // attributes of this object.\n        _pyfunc_instantiate(this, arguments);\n    }\n    Texture3DLike.prototype = Object.create(Texture2D.prototype);\n    Texture3DLike.prototype._base_class = Texture2D.prototype;\n    Texture3DLike.prototype._class_name = \"Texture3DLike\";\n    \n    Texture3DLike.prototype.GLSL_SAMPLE_NEAREST = \"\\n        vec4 sample3D(sampler2D tex, vec3 texcoord, vec3 shape, vec2 tiles) {\\n            shape.xyz = shape.zyx;  // silly row-major convention\\n            float nrows = tiles.y, ncols = tiles.x;\\n            // Don't let adjacent frames be interpolated into this one\\n            texcoord.x = min(texcoord.x * shape.x, shape.x - 0.5);\\n            texcoord.x = max(0.5, texcoord.x) / shape.x;\\n            texcoord.y = min(texcoord.y * shape.y, shape.y - 0.5);\\n            texcoord.y = max(0.5, texcoord.y) / shape.y;\\n\\n            float zindex = floor(texcoord.z * shape.z);\\n\\n            // Do a lookup in the 2D texture\\n            float u = (mod(zindex, ncols) + texcoord.x) / ncols;\\n            float v = (floor(zindex / ncols) + texcoord.y) / nrows;\\n\\n            return texture2D(tex, vec2(u,v));\\n        }\\n    \";\n    Texture3DLike.prototype.GLSL_SAMPLE_LINEAR = \"\\n        vec4 sample3D(sampler2D tex, vec3 texcoord, vec3 shape, vec2 tiles) {\\n            shape.xyz = shape.zyx;  // silly row-major convention\\n            float nrows = tiles.y, ncols = tiles.x;\\n            // Don't let adjacent frames be interpolated into this one\\n            texcoord.x = min(texcoord.x * shape.x, shape.x - 0.5);\\n            texcoord.x = max(0.5, texcoord.x) / shape.x;\\n            texcoord.y = min(texcoord.y * shape.y, shape.y - 0.5);\\n            texcoord.y = max(0.5, texcoord.y) / shape.y;\\n\\n            float z = texcoord.z * shape.z;\\n            float zindex1 = floor(z);\\n            float u1 = (mod(zindex1, ncols) + texcoord.x) / ncols;\\n            float v1 = (floor(zindex1 / ncols) + texcoord.y) / nrows;\\n\\n            float zindex2 = zindex1 + 1.0;\\n            float u2 = (mod(zindex2, ncols) + texcoord.x) / ncols;\\n            float v2 = (floor(zindex2 / ncols) + texcoord.y) / nrows;\\n\\n            vec4 s1 = texture2D(tex, vec2(u1, v1));\\n            vec4 s2 = texture2D(tex, vec2(u2, v2));\\n\\n            return s1 * (zindex2 - z) + s2 * (z - zindex1);\\n        }\\n    \";\n    Texture3DLike.prototype._get_tile_info = function (shape) {\n        var err_3, max_size, ncols, nrows;\n        max_size = this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE);\n        nrows = Math.floor(max_size/shape[1]);\n        nrows = Math.min(nrows, shape[0]);\n        ncols = window.Math.ceil(shape[0] / nrows);\n        if (_pyfunc_truthy(_pyfunc_mult(ncols, shape[2]) > max_size)) {\n            err_3 = new Error('RuntimeError:' + (\"Cannot fit 3D data with shape \" + shape + \" onto simulated 2D texture.\")); err_3.name = \"RuntimeError\"; throw err_3;\n        }\n        return [nrows, ncols];\n    };\n\n    Texture3DLike.prototype.set_size = function (shape, format) {\n        var ncols, nrows, sim_shape, stub18_;\n        // Set the size of the 3D texture.\n        // \n        // Parameters\n        // ----------\n        // shape : tuple of ints\n        //     The shape of the data to upload\n        // format : GL enum\n        //     The format of the texture data. Can be LUMINANCE, LUMINANCE_ALPHA,\n        //     RGB, and RGBA.\n        stub18_ = this._get_tile_info(shape);\n        nrows = stub18_[0];ncols = stub18_[1];\n        sim_shape = [_pyfunc_mult(shape[1], nrows), _pyfunc_mult(shape[2], ncols)];\n        Texture3DLike.prototype._base_class.set_size.call(this, sim_shape, format);\n        this.u_shape = [shape[0], shape[1], shape[2]];\n        this.u_tiles = [ncols, nrows];\n        return null;\n    };\n\n    Texture3DLike.prototype.set_data = function (offset, shape, data) {\n        var Type, col, elements_per_tile, err_3, ncols, nrows, row, sim_shape, stub19_, stub20_, tile, z, zeros;\n        // Set the 3D texture data.\n        // \n        // Parameters\n        // ----------\n        // offset : tuple of ints\n        //     Offset in pixels for each dimension.\n        // shape : tuple of ints\n        //     The shape of the data to upload\n        // data : typed array\n        //     The actual pixel data. Can be of any type, but on the GPU the\n        //     dat is stored in 8 bit precision.\n        if (_pyfunc_equals(shape.length, 3)) {\n            shape = [shape[0], shape[1], shape[2], 1];\n        }\n        if ((!(_pyfunc_all(((function list_comprehenson () {var res = [];var i, iter0, i0;iter0 = offset;if ((typeof iter0 === \"object\") && (!Array.isArray(iter0))) {iter0 = Object.keys(iter0);}for (i0=0; i0<iter0.length; i0++) {i = iter0[i0];{res.push(_pyfunc_equals(i, 0));}}return res;}).apply(this)))))) {\n            err_3 = new Error('ValueError:' + \"Texture3DLike does not support nonzero offset (for now)\"); err_3.name = \"ValueError\"; throw err_3;\n        }\n        stub19_ = this._get_tile_info(shape);\n        nrows = stub19_[0];ncols = stub19_[1];\n        sim_shape = [_pyfunc_mult(shape[1], nrows), _pyfunc_mult(shape[2], ncols), shape[3]];\n        if (_pyfunc_equals(ncols, 1)) {\n            Texture3DLike.prototype._base_class.set_data.call(this, [0, 0], sim_shape, data);\n        } else {\n            Type = data.constructor;\n            zeros = new Type(_pyfunc_mult(_pyfunc_mult(sim_shape[0], sim_shape[1]), sim_shape[2]));\n            Texture3DLike.prototype._base_class.set_data.call(this, [0, 0], sim_shape, zeros);\n            for (z = 0; z < shape[0]; z += 1) {\n                stub20_ = [Math.floor(z/ncols), z % ncols];\n                row = stub20_[0];col = stub20_[1];\n                elements_per_tile = Math.floor(data.length/shape[0]);\n                tile = data.slice(_pyfunc_mult(z, elements_per_tile),_pyfunc_mult((z + 1), elements_per_tile));\n                Texture3DLike.prototype._base_class.set_data.call(this, [_pyfunc_mult(row, shape[1]), _pyfunc_mult(col, shape[2])], shape.slice(1), tile);\n            }\n        }\n        return null;\n    };\n\n\n    return {\"Buffer\": Buffer, \"GlooObject\": GlooObject, \"IndexBuffer\": IndexBuffer, \"Program\": Program, \"Texture2D\": Texture2D, \"Texture3DLike\": Texture3DLike, \"VertexBuffer\": VertexBuffer, \"check_error\": check_error, \"console\": console};\n}));\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RyYXZpcy9idWlsZC9ib2tlaC9ib2tlaC9ib2tlaGpzL3NyYy9qcy9wbHVnaW4tcHJlbHVkZS5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy93ZWJnbC9iYXNlLmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL3dlYmdsL2luZGV4LmpzIiwiYnVpbGQvanMvdHJlZS9tb2RlbHMvZ2x5cGhzL3dlYmdsL2xpbmUuanMiLCJidWlsZC9qcy90cmVlL21vZGVscy9nbHlwaHMvd2ViZ2wvbWFpbi5qcyIsImJ1aWxkL2pzL3RyZWUvbW9kZWxzL2dseXBocy93ZWJnbC9tYXJrZXJzLmpzIiwic3JjL3ZlbmRvci9nbG9vL2dsb28yLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xXQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIG91dGVyKG1vZHVsZXMsIGNhY2hlLCBlbnRyeSkge1xuICBpZiAoQm9rZWggIT0gbnVsbCkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbW9kdWxlcykge1xuICAgICAgQm9rZWgucmVxdWlyZS5tb2R1bGVzW25hbWVdID0gbW9kdWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGx1Z2luID0gQm9rZWgucmVxdWlyZShlbnRyeVswXSk7XG4gICAgICBCb2tlaC5Nb2RlbHMucmVnaXN0ZXJfbW9kZWxzKHBsdWdpbi5tb2RlbHMpO1xuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHBsdWdpbikge1xuICAgICAgICBpZiAobmFtZSAhPT0gXCJtb2RlbHNcIikge1xuICAgICAgICAgIEJva2VoW25hbWVdID0gcGx1Z2luW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIEJva2VoLiBZb3UgaGF2ZSB0byBsb2FkIGl0IHByaW9yIHRvIGxvYWRpbmcgcGx1Z2lucy5cIik7XG4gIH1cbn0pXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb2xvcl8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9jb2xvclwiKTtcbmV4cG9ydHMuQmFzZUdMR2x5cGggPSAoZnVuY3Rpb24gKCkge1xuICAgIEJhc2VHTEdseXBoLnByb3RvdHlwZS5HTFlQSCA9ICcnO1xuICAgIEJhc2VHTEdseXBoLnByb3RvdHlwZS5WRVJUID0gJyc7XG4gICAgQmFzZUdMR2x5cGgucHJvdG90eXBlLkZSQUcgPSAnJztcbiAgICBmdW5jdGlvbiBCYXNlR0xHbHlwaChnbCwgZ2x5cGgpIHtcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB0aGlzLmdseXBoID0gZ2x5cGg7XG4gICAgICAgIHRoaXMubnZlcnRpY2VzID0gMDtcbiAgICAgICAgdGhpcy5zaXplX2NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kYXRhX2NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52aXN1YWxzX2NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIEJhc2VHTEdseXBoLnByb3RvdHlwZS5zZXRfZGF0YV9jaGFuZ2VkID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKG4gIT09IHRoaXMubnZlcnRpY2VzKSB7XG4gICAgICAgICAgICB0aGlzLm52ZXJ0aWNlcyA9IG47XG4gICAgICAgICAgICB0aGlzLnNpemVfY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YV9jaGFuZ2VkID0gdHJ1ZTtcbiAgICB9O1xuICAgIEJhc2VHTEdseXBoLnByb3RvdHlwZS5zZXRfdmlzdWFsc19jaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXN1YWxzX2NoYW5nZWQgPSB0cnVlO1xuICAgIH07XG4gICAgQmFzZUdMR2x5cGgucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjdHgsIGluZGljZXMsIG1haW5nbHlwaCkge1xuICAgICAgICB2YXIgZHgsIGR5LCByZWYsIHJlZjEsIHJlZjIsIHN4LCBzeSwgdHJhbnMsIHd4LCB3eTtcbiAgICAgICAgd3ggPSB3eSA9IDE7XG4gICAgICAgIHJlZiA9IHRoaXMuZ2x5cGgucmVuZGVyZXIubWFwX3RvX3NjcmVlbihbMCAqIHd4LCAxICogd3gsIDIgKiB3eF0sIFswICogd3ksIDEgKiB3eSwgMiAqIHd5XSksIGR4ID0gcmVmWzBdLCBkeSA9IHJlZlsxXTtcbiAgICAgICAgd3ggPSAxMDAgLyBNYXRoLm1pbihNYXRoLm1heChNYXRoLmFicyhkeFsxXSAtIGR4WzBdKSwgMWUtMTIpLCAxZTEyKTtcbiAgICAgICAgd3kgPSAxMDAgLyBNYXRoLm1pbihNYXRoLm1heChNYXRoLmFicyhkeVsxXSAtIGR5WzBdKSwgMWUtMTIpLCAxZTEyKTtcbiAgICAgICAgcmVmMSA9IHRoaXMuZ2x5cGgucmVuZGVyZXIubWFwX3RvX3NjcmVlbihbMCAqIHd4LCAxICogd3gsIDIgKiB3eF0sIFswICogd3ksIDEgKiB3eSwgMiAqIHd5XSksIGR4ID0gcmVmMVswXSwgZHkgPSByZWYxWzFdO1xuICAgICAgICBpZiAoTWF0aC5hYnMoKGR4WzFdIC0gZHhbMF0pIC0gKGR4WzJdIC0gZHhbMV0pKSA+IDFlLTYgfHwgTWF0aC5hYnMoKGR5WzFdIC0gZHlbMF0pIC0gKGR5WzJdIC0gZHlbMV0pKSA+IDFlLTYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZWYyID0gWyhkeFsxXSAtIGR4WzBdKSAvIHd4LCAoZHlbMV0gLSBkeVswXSkgLyB3eV0sIHN4ID0gcmVmMlswXSwgc3kgPSByZWYyWzFdO1xuICAgICAgICB0cmFucyA9IHtcbiAgICAgICAgICAgIHBpeGVsX3JhdGlvOiBjdHgucGl4ZWxfcmF0aW8sXG4gICAgICAgICAgICB3aWR0aDogY3R4LmdsY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBjdHguZ2xjYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgZHg6IGR4WzBdIC8gc3gsXG4gICAgICAgICAgICBkeTogZHlbMF0gLyBzeSxcbiAgICAgICAgICAgIHN4OiBzeCxcbiAgICAgICAgICAgIHN5OiBzeVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRyYXcoaW5kaWNlcywgbWFpbmdseXBoLCB0cmFucyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIEJhc2VHTEdseXBoO1xufSkoKTtcbmV4cG9ydHMubGluZV93aWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICAgIGlmICh3aWR0aCA8IDIpIHtcbiAgICAgICAgd2lkdGggPSBNYXRoLnNxcnQod2lkdGggKiAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xufTtcbmV4cG9ydHMuZmlsbF9hcnJheV93aXRoX2Zsb2F0ID0gZnVuY3Rpb24gKG4sIHZhbCkge1xuICAgIHZhciBhLCBpLCBrLCByZWY7XG4gICAgYSA9IG5ldyBGbG9hdDMyQXJyYXkobik7XG4gICAgZm9yIChpID0gayA9IDAsIHJlZiA9IG47IDAgPD0gcmVmID8gayA8IHJlZiA6IGsgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrayA6IC0taykge1xuICAgICAgICBhW2ldID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG5leHBvcnRzLmZpbGxfYXJyYXlfd2l0aF92ZWMgPSBmdW5jdGlvbiAobiwgbSwgdmFsKSB7XG4gICAgdmFyIGEsIGksIGosIGssIGwsIHJlZiwgcmVmMTtcbiAgICBhID0gbmV3IEZsb2F0MzJBcnJheShuICogbSk7XG4gICAgZm9yIChpID0gayA9IDAsIHJlZiA9IG47IDAgPD0gcmVmID8gayA8IHJlZiA6IGsgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrayA6IC0taykge1xuICAgICAgICBmb3IgKGogPSBsID0gMCwgcmVmMSA9IG07IDAgPD0gcmVmMSA/IGwgPCByZWYxIDogbCA+IHJlZjE7IGogPSAwIDw9IHJlZjEgPyArK2wgOiAtLWwpIHtcbiAgICAgICAgICAgIGFbaSAqIG0gKyBqXSA9IHZhbFtqXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG5leHBvcnRzLnZpc3VhbF9wcm9wX2lzX3Npbmd1bGFyID0gZnVuY3Rpb24gKHZpc3VhbCwgcHJvcG5hbWUpIHtcbiAgICByZXR1cm4gdmlzdWFsW3Byb3BuYW1lXS5zcGVjLnZhbHVlICE9PSB2b2lkIDA7XG59O1xuZXhwb3J0cy5hdHRhY2hfZmxvYXQgPSBmdW5jdGlvbiAocHJvZywgdmJvLCBhdHRfbmFtZSwgbiwgdmlzdWFsLCBuYW1lKSB7XG4gICAgdmFyIGE7XG4gICAgaWYgKCF2aXN1YWwuZG9pdCkge1xuICAgICAgICB2Ym8udXNlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcHJvZy5zZXRfYXR0cmlidXRlKGF0dF9uYW1lLCAnZmxvYXQnLCBbMF0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBvcnRzLnZpc3VhbF9wcm9wX2lzX3Npbmd1bGFyKHZpc3VhbCwgbmFtZSkpIHtcbiAgICAgICAgdmJvLnVzZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHByb2cuc2V0X2F0dHJpYnV0ZShhdHRfbmFtZSwgJ2Zsb2F0JywgdmlzdWFsW25hbWVdLnZhbHVlKCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmJvLnVzZWQgPSB0cnVlO1xuICAgICAgICBhID0gbmV3IEZsb2F0MzJBcnJheSh2aXN1YWwuY2FjaGVbbmFtZSArICdfYXJyYXknXSk7XG4gICAgICAgIHZiby5zZXRfc2l6ZShuICogNCk7XG4gICAgICAgIHZiby5zZXRfZGF0YSgwLCBhKTtcbiAgICAgICAgcmV0dXJuIHByb2cuc2V0X2F0dHJpYnV0ZShhdHRfbmFtZSwgJ2Zsb2F0JywgdmJvKTtcbiAgICB9XG59O1xuZXhwb3J0cy5hdHRhY2hfY29sb3IgPSBmdW5jdGlvbiAocHJvZywgdmJvLCBhdHRfbmFtZSwgbiwgdmlzdWFsLCBwcmVmaXgpIHtcbiAgICB2YXIgYSwgYWxwaGFuYW1lLCBhbHBoYXMsIGNvbG9ybmFtZSwgY29sb3JzLCBpLCBqLCBrLCBsLCBtLCByZWYsIHJlZjEsIHJnYmE7XG4gICAgbSA9IDQ7XG4gICAgY29sb3JuYW1lID0gcHJlZml4ICsgJ19jb2xvcic7XG4gICAgYWxwaGFuYW1lID0gcHJlZml4ICsgJ19hbHBoYSc7XG4gICAgaWYgKCF2aXN1YWwuZG9pdCkge1xuICAgICAgICB2Ym8udXNlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcHJvZy5zZXRfYXR0cmlidXRlKGF0dF9uYW1lLCAndmVjNCcsIFswLCAwLCAwLCAwXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cG9ydHMudmlzdWFsX3Byb3BfaXNfc2luZ3VsYXIodmlzdWFsLCBjb2xvcm5hbWUpICYmIGV4cG9ydHMudmlzdWFsX3Byb3BfaXNfc2luZ3VsYXIodmlzdWFsLCBhbHBoYW5hbWUpKSB7XG4gICAgICAgIHZiby51c2VkID0gZmFsc2U7XG4gICAgICAgIHJnYmEgPSBjb2xvcl8xLmNvbG9yMnJnYmEodmlzdWFsW2NvbG9ybmFtZV0udmFsdWUoKSwgdmlzdWFsW2FscGhhbmFtZV0udmFsdWUoKSk7XG4gICAgICAgIHJldHVybiBwcm9nLnNldF9hdHRyaWJ1dGUoYXR0X25hbWUsICd2ZWM0JywgcmdiYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2Ym8udXNlZCA9IHRydWU7XG4gICAgICAgIGlmIChleHBvcnRzLnZpc3VhbF9wcm9wX2lzX3Npbmd1bGFyKHZpc3VhbCwgY29sb3JuYW1lKSkge1xuICAgICAgICAgICAgY29sb3JzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaywgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBrID0gMCwgcmVmID0gbjsgMCA8PSByZWYgPyBrIDwgcmVmIDogayA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytrIDogLS1rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2aXN1YWxbY29sb3JuYW1lXS52YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29sb3JzID0gdmlzdWFsLmNhY2hlW2NvbG9ybmFtZSArICdfYXJyYXknXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwb3J0cy52aXN1YWxfcHJvcF9pc19zaW5ndWxhcih2aXN1YWwsIGFscGhhbmFtZSkpIHtcbiAgICAgICAgICAgIGFscGhhcyA9IGV4cG9ydHMuZmlsbF9hcnJheV93aXRoX2Zsb2F0KG4sIHZpc3VhbFthbHBoYW5hbWVdLnZhbHVlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWxwaGFzID0gdmlzdWFsLmNhY2hlW2FscGhhbmFtZSArICdfYXJyYXknXTtcbiAgICAgICAgfVxuICAgICAgICBhID0gbmV3IEZsb2F0MzJBcnJheShuICogbSk7XG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYgPSBuOyAwIDw9IHJlZiA/IGsgPCByZWYgOiBrID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2sgOiAtLWspIHtcbiAgICAgICAgICAgIHJnYmEgPSBjb2xvcl8xLmNvbG9yMnJnYmEoY29sb3JzW2ldLCBhbHBoYXNbaV0pO1xuICAgICAgICAgICAgZm9yIChqID0gbCA9IDAsIHJlZjEgPSBtOyAwIDw9IHJlZjEgPyBsIDwgcmVmMSA6IGwgPiByZWYxOyBqID0gMCA8PSByZWYxID8gKytsIDogLS1sKSB7XG4gICAgICAgICAgICAgICAgYVtpICogbSArIGpdID0gcmdiYVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2Ym8uc2V0X3NpemUobiAqIG0gKiA0KTtcbiAgICAgICAgdmJvLnNldF9kYXRhKDAsIGEpO1xuICAgICAgICByZXR1cm4gcHJvZy5zZXRfYXR0cmlidXRlKGF0dF9uYW1lLCAndmVjNCcsIHZibyk7XG4gICAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLypcbkNvcHlyaWdodCBub3RpY2U6IG1hbnkgb2YgdGhlIGF3ZXNvbWUgdGVjaG5pcXVlcyBhbmQgIEdMU0wgY29kZSBjb250YWluZWQgaW5cbnRoaXMgbW9kdWxlIGFyZSBiYXNlZCBvbiB3b3JrIGJ5IE5pY29sYXMgUm91Z2llciBhcyBwYXJ0IG9mIHRoZSBHbHVtcHkgYW5kXG5WaXNweSBwcm9qZWN0cy4gVGhlIGFsZ29yaXRobXMgYXJlIHB1Ymxpc2hlZCBpblxuaHR0cDovL2pjZ3Qub3JnL3B1Ymxpc2hlZC8wMDAzLzA0LzAxLyBhbmQgaHR0cDovL2pjZ3Qub3JnL3B1Ymxpc2hlZC8wMDAyLzAyLzA4L1xuXG5UaGlzIG1vZHVsZSBjb250YWlucyBhbGwgZ2wtc3BlY2lmaWMgY29kZSB0byBhZGQgZ2wgc3VwcG9ydCBmb3IgdGhlIGdseXBocy5cbkJ5IGltcGxlbWVudGluZyBpdCBzZXBhcmV0ZWx5LCB0aGUgR0wgZnVuY3Rpb25hbGl0eSBjYW4gYmUgc3B1biBvZmYgaW4gYVxuc2VwYXJhdGUgbGlicmFyeS5cbk90aGVyIGxvY2F0aW9ucyB3aGVyZSB3ZSB3b3JrIHdpdGggR0wsIG9yIHByZXBhcmUgZm9yIEdMLXJlbmRlcmluZzpcbi0gY2FudmFzLmNvZmZlZVxuLSBwbG90LmNvZmZlZVxuLSBnbHlwaC5jb2ZmZWVcbi0gZ2x5cGhfcmVuZGVyZXIuY29mZmVlXG4qL1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2xpbmVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vbWFya2Vyc1wiKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEYXNoQXRsYXMsIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBnbG9vMiA9IHJlcXVpcmUoXCJnbG9vMlwiKTtcbnZhciBjb2xvcl8xID0gcmVxdWlyZShcImNvcmUvdXRpbC9jb2xvclwiKTtcbnZhciBiYXNlXzEgPSByZXF1aXJlKFwiLi9iYXNlXCIpO1xuRGFzaEF0bGFzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXNoQXRsYXMoZ2wpIHtcbiAgICAgICAgdGhpcy5fYXRsYXMgPSB7fTtcbiAgICAgICAgdGhpcy5faW5kZXggPSAwO1xuICAgICAgICB0aGlzLl93aWR0aCA9IDI1NjtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gMjU2O1xuICAgICAgICB0aGlzLnRleCA9IG5ldyBnbG9vMi5UZXh0dXJlMkQoZ2wpO1xuICAgICAgICB0aGlzLnRleC5zZXRfd3JhcHBpbmcoZ2wuUkVQRUFULCBnbC5SRVBFQVQpO1xuICAgICAgICB0aGlzLnRleC5zZXRfaW50ZXJwb2xhdGlvbihnbC5ORUFSRVNULCBnbC5ORUFSRVNUKTtcbiAgICAgICAgdGhpcy50ZXguc2V0X3NpemUoW3RoaXMuX2hlaWdodCwgdGhpcy5fd2lkdGhdLCBnbC5SR0JBKTtcbiAgICAgICAgdGhpcy50ZXguc2V0X2RhdGEoWzAsIDBdLCBbdGhpcy5faGVpZ2h0LCB0aGlzLl93aWR0aF0sIG5ldyBVaW50OEFycmF5KHRoaXMuX2hlaWdodCAqIHRoaXMuX3dpZHRoICogNCkpO1xuICAgICAgICB0aGlzLmdldF9hdGxhc19kYXRhKFsxXSk7XG4gICAgfVxuICAgIERhc2hBdGxhcy5wcm90b3R5cGUuZ2V0X2F0bGFzX2RhdGEgPSBmdW5jdGlvbiAocGF0dGVybikge1xuICAgICAgICB2YXIgZGF0YSwgZmluZGV4X3BlcmlvZCwga2V5LCBwZXJpb2QsIHJlZiwgeDtcbiAgICAgICAga2V5ID0gcGF0dGVybi5qb2luKCctJyk7XG4gICAgICAgIGZpbmRleF9wZXJpb2QgPSB0aGlzLl9hdGxhc1trZXldO1xuICAgICAgICBpZiAoZmluZGV4X3BlcmlvZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZWYgPSB0aGlzLm1ha2VfcGF0dGVybihwYXR0ZXJuKSwgZGF0YSA9IHJlZlswXSwgcGVyaW9kID0gcmVmWzFdO1xuICAgICAgICAgICAgdGhpcy50ZXguc2V0X2RhdGEoW3RoaXMuX2luZGV4LCAwXSwgWzEsIHRoaXMuX3dpZHRoXSwgbmV3IFVpbnQ4QXJyYXkoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbCwgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGwgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgbCA8IGxlbjsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBkYXRhW2xdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeCArIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KSgpKSk7XG4gICAgICAgICAgICB0aGlzLl9hdGxhc1trZXldID0gW3RoaXMuX2luZGV4IC8gdGhpcy5faGVpZ2h0LCBwZXJpb2RdO1xuICAgICAgICAgICAgdGhpcy5faW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYXRsYXNba2V5XTtcbiAgICB9O1xuICAgIERhc2hBdGxhcy5wcm90b3R5cGUubWFrZV9wYXR0ZXJuID0gZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICAgICAgdmFyIEMsIFosIGEsIGIsIGMsIGRhc2hfZW5kLCBkYXNoX3N0YXJ0LCBkYXNoX3R5cGUsIGksIGluZGV4LCBqLCBsLCBsZW4sIG4sIHAsIHBlcmlvZCwgcSwgciwgcmVmLCByZWYxLCByZWYyLCB2LCB2YWwsIHZhbF9hdF9pbmRleCwgeDtcbiAgICAgICAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gMSAmJiBwYXR0ZXJuLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLmNvbmNhdChwYXR0ZXJuKTtcbiAgICAgICAgfVxuICAgICAgICBwZXJpb2QgPSAwO1xuICAgICAgICBmb3IgKGwgPSAwLCBsZW4gPSBwYXR0ZXJuLmxlbmd0aDsgbCA8IGxlbjsgbCsrKSB7XG4gICAgICAgICAgICB2ID0gcGF0dGVybltsXTtcbiAgICAgICAgICAgIHBlcmlvZCArPSB2O1xuICAgICAgICB9XG4gICAgICAgIEMgPSBbXTtcbiAgICAgICAgYyA9IDA7XG4gICAgICAgIGZvciAoaSA9IHAgPSAwLCByZWYgPSBwYXR0ZXJuLmxlbmd0aCArIDI7IHAgPCByZWY7IGkgPSBwICs9IDIpIHtcbiAgICAgICAgICAgIGEgPSBNYXRoLm1heCgwLjAwMDEsIHBhdHRlcm5baSAlIHBhdHRlcm4ubGVuZ3RoXSk7XG4gICAgICAgICAgICBiID0gTWF0aC5tYXgoMC4wMDAxLCBwYXR0ZXJuWyhpICsgMSkgJSBwYXR0ZXJuLmxlbmd0aF0pO1xuICAgICAgICAgICAgQy5wdXNoLmFwcGx5KEMsIFtjLCBjICsgYV0pO1xuICAgICAgICAgICAgYyArPSBhICsgYjtcbiAgICAgICAgfVxuICAgICAgICBuID0gdGhpcy5fd2lkdGg7XG4gICAgICAgIFogPSBuZXcgRmxvYXQzMkFycmF5KG4gKiA0KTtcbiAgICAgICAgZm9yIChpID0gcSA9IDAsIHJlZjEgPSBuOyAwIDw9IHJlZjEgPyBxIDwgcmVmMSA6IHEgPiByZWYxOyBpID0gMCA8PSByZWYxID8gKytxIDogLS1xKSB7XG4gICAgICAgICAgICB4ID0gcGVyaW9kICogaSAvIChuIC0gMSk7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICB2YWxfYXRfaW5kZXggPSAxZTE2O1xuICAgICAgICAgICAgZm9yIChqID0gciA9IDAsIHJlZjIgPSBDLmxlbmd0aDsgMCA8PSByZWYyID8gciA8IHJlZjIgOiByID4gcmVmMjsgaiA9IDAgPD0gcmVmMiA/ICsrciA6IC0tcikge1xuICAgICAgICAgICAgICAgIHZhbCA9IE1hdGguYWJzKENbal0gLSB4KTtcbiAgICAgICAgICAgICAgICBpZiAodmFsIDwgdmFsX2F0X2luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gajtcbiAgICAgICAgICAgICAgICAgICAgdmFsX2F0X2luZGV4ID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkYXNoX3R5cGUgPSAoeCA8PSBDW2luZGV4XSkgPyArMSA6IDA7XG4gICAgICAgICAgICAgICAgZGFzaF9zdGFydCA9IENbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGRhc2hfZW5kID0gQ1tpbmRleCArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGFzaF90eXBlID0gKHggPiBDW2luZGV4XSkgPyAtMSA6IDA7XG4gICAgICAgICAgICAgICAgZGFzaF9zdGFydCA9IENbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICBkYXNoX2VuZCA9IENbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgWltpICogNCArIDBdID0gQ1tpbmRleF07XG4gICAgICAgICAgICBaW2kgKiA0ICsgMV0gPSBkYXNoX3R5cGU7XG4gICAgICAgICAgICBaW2kgKiA0ICsgMl0gPSBkYXNoX3N0YXJ0O1xuICAgICAgICAgICAgWltpICogNCArIDNdID0gZGFzaF9lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtaLCBwZXJpb2RdO1xuICAgIH07XG4gICAgcmV0dXJuIERhc2hBdGxhcztcbn0pKCk7XG5leHBvcnRzLkxpbmVHTEdseXBoID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKExpbmVHTEdseXBoLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBMaW5lR0xHbHlwaCgpIHtcbiAgICAgICAgcmV0dXJuIExpbmVHTEdseXBoLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMaW5lR0xHbHlwaC5wcm90b3R5cGUuR0xZUEggPSAnbGluZSc7XG4gICAgTGluZUdMR2x5cGgucHJvdG90eXBlLkpPSU5TID0ge1xuICAgICAgICAnbWl0ZXInOiAwLFxuICAgICAgICAncm91bmQnOiAxLFxuICAgICAgICAnYmV2ZWwnOiAyXG4gICAgfTtcbiAgICBMaW5lR0xHbHlwaC5wcm90b3R5cGUuQ0FQUyA9IHtcbiAgICAgICAgJyc6IDAsXG4gICAgICAgICdub25lJzogMCxcbiAgICAgICAgJy4nOiAwLFxuICAgICAgICAncm91bmQnOiAxLFxuICAgICAgICAnKSc6IDEsXG4gICAgICAgICcoJzogMSxcbiAgICAgICAgJ28nOiAxLFxuICAgICAgICAndHJpYW5nbGUgaW4nOiAyLFxuICAgICAgICAnPCc6IDIsXG4gICAgICAgICd0cmlhbmdsZSBvdXQnOiAzLFxuICAgICAgICAnPic6IDMsXG4gICAgICAgICdzcXVhcmUnOiA0LFxuICAgICAgICAnWyc6IDQsXG4gICAgICAgICddJzogNCxcbiAgICAgICAgJz0nOiA0LFxuICAgICAgICAnYnV0dCc6IDUsXG4gICAgICAgICd8JzogNVxuICAgIH07XG4gICAgTGluZUdMR2x5cGgucHJvdG90eXBlLlZFUlQgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbmNvbnN0IGZsb2F0IFBJID0gMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDtcXG5jb25zdCBmbG9hdCBUSEVUQSA9IDE1LjAgKiAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0LzE4MC4wO1xcblxcbnVuaWZvcm0gZmxvYXQgdV9waXhlbF9yYXRpbztcXG51bmlmb3JtIHZlYzIgdV9jYW52YXNfc2l6ZSwgdV9vZmZzZXQ7XFxudW5pZm9ybSB2ZWMyIHVfc2NhbGVfYXNwZWN0O1xcbnVuaWZvcm0gZmxvYXQgdV9zY2FsZV9sZW5ndGg7XFxuXFxudW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxudW5pZm9ybSBmbG9hdCB1X2FudGlhbGlhcztcXG51bmlmb3JtIGZsb2F0IHVfbGVuZ3RoO1xcbnVuaWZvcm0gZmxvYXQgdV9saW5ld2lkdGg7XFxudW5pZm9ybSBmbG9hdCB1X2Rhc2hfaW5kZXg7XFxudW5pZm9ybSBmbG9hdCB1X2Nsb3NlZDtcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfdGFuZ2VudHM7XFxuYXR0cmlidXRlIHZlYzIgYV9zZWdtZW50O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfYW5nbGVzO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4Y29vcmQ7XFxuXFxudmFyeWluZyB2ZWM0ICB2X2NvbG9yO1xcbnZhcnlpbmcgdmVjMiAgdl9zZWdtZW50O1xcbnZhcnlpbmcgdmVjMiAgdl9hbmdsZXM7XFxudmFyeWluZyB2ZWMyICB2X3RleGNvb3JkO1xcbnZhcnlpbmcgdmVjMiAgdl9taXRlcjtcXG52YXJ5aW5nIGZsb2F0IHZfbGVuZ3RoO1xcbnZhcnlpbmcgZmxvYXQgdl9saW5ld2lkdGg7XFxuXFxuZmxvYXQgY3Jvc3MoaW4gdmVjMiB2MSwgaW4gdmVjMiB2MilcXG57XFxuICAgIHJldHVybiB2MS54KnYyLnkgLSB2MS55KnYyLng7XFxufVxcblxcbmZsb2F0IHNpZ25lZF9kaXN0YW5jZShpbiB2ZWMyIHYxLCBpbiB2ZWMyIHYyLCBpbiB2ZWMyIHYzKVxcbntcXG4gICAgcmV0dXJuIGNyb3NzKHYyLXYxLHYxLXYzKSAvIGxlbmd0aCh2Mi12MSk7XFxufVxcblxcbnZvaWQgcm90YXRlKCBpbiB2ZWMyIHYsIGluIGZsb2F0IGFscGhhLCBvdXQgdmVjMiByZXN1bHQgKVxcbntcXG4gICAgZmxvYXQgYyA9IGNvcyhhbHBoYSk7XFxuICAgIGZsb2F0IHMgPSBzaW4oYWxwaGEpO1xcbiAgICByZXN1bHQgPSB2ZWMyKCBjKnYueCAtIHMqdi55LFxcbiAgICAgICAgICAgICAgICAgICBzKnYueCArIGMqdi55ICk7XFxufVxcblxcbnZvaWQgbWFpbigpXFxue1xcbiAgICBib29sIGNsb3NlZCA9ICh1X2Nsb3NlZCA+IDAuMCk7XFxuXFxuICAgIC8vIEF0dHJpYnV0ZXMgYW5kIHVuaWZvcm1zIHRvIHZhcnlpbmdzXFxuICAgIHZfY29sb3IgPSB1X2NvbG9yO1xcbiAgICB2X2xpbmV3aWR0aCA9IHVfbGluZXdpZHRoO1xcbiAgICB2X3NlZ21lbnQgPSBhX3NlZ21lbnQgKiB1X3NjYWxlX2xlbmd0aDtcXG4gICAgdl9sZW5ndGggPSB1X2xlbmd0aCAqIHVfc2NhbGVfbGVuZ3RoO1xcblxcbiAgICAvLyBTY2FsZSB0byBtYXAgdG8gcGl4ZWwgY29vcmRpbmF0ZXMuIFRoZSBvcmlnaW5hbCBhbGdvcml0aG0gZnJvbSB0aGUgcGFwZXJcXG4gICAgLy8gYXNzdW1lZCBpc290cm9waWMgc2NhbGUuIFdlIG9idmlvdXNseSBkbyBub3QgaGF2ZSB0aGlzLlxcbiAgICB2ZWMyIGFic19zY2FsZV9hc3BlY3QgPSBhYnModV9zY2FsZV9hc3BlY3QpO1xcbiAgICB2ZWMyIGFic19zY2FsZSA9IHVfc2NhbGVfbGVuZ3RoICogYWJzX3NjYWxlX2FzcGVjdDtcXG5cXG4gICAgLy8gQ29ycmVjdCBhbmdsZXMgZm9yIGFzcGVjdCByYXRpb1xcbiAgICB2ZWMyIGF2O1xcbiAgICBhdiA9IHZlYzIoMS4wLCB0YW4oYV9hbmdsZXMueCkpIC8gYWJzX3NjYWxlX2FzcGVjdDtcXG4gICAgdl9hbmdsZXMueCA9IGF0YW4oYXYueSwgYXYueCk7XFxuICAgIGF2ID0gdmVjMigxLjAsIHRhbihhX2FuZ2xlcy55KSkgLyBhYnNfc2NhbGVfYXNwZWN0O1xcbiAgICB2X2FuZ2xlcy55ID0gYXRhbihhdi55LCBhdi54KTtcXG5cXG4gICAgLy8gVGhpY2tuZXNzIGJlbG93IDEgcGl4ZWwgYXJlIHJlcHJlc2VudGVkIHVzaW5nIGEgMSBwaXhlbCB0aGlja25lc3NcXG4gICAgLy8gYW5kIGEgbW9kaWZpZWQgYWxwaGFcXG4gICAgdl9jb2xvci5hID0gbWluKHZfbGluZXdpZHRoLCB2X2NvbG9yLmEpO1xcbiAgICB2X2xpbmV3aWR0aCA9IG1heCh2X2xpbmV3aWR0aCwgMS4wKTtcXG5cXG4gICAgLy8gSWYgY29sb3IgaXMgZnVsbHkgdHJhbnNwYXJlbnQgd2UganVzdCB3aWxsIGRpc2NhcmQgdGhlIGZyYWdtZW50IGFueXdheVxcbiAgICBpZiggdl9jb2xvci5hIDw9IDAuMCApIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgwLjAsMC4wLDAuMCwxLjApO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8vIFRoaXMgaXMgdGhlIGFjdHVhbCBoYWxmIHdpZHRoIG9mIHRoZSBsaW5lXFxuICAgIGZsb2F0IHcgPSBjZWlsKHVfYW50aWFsaWFzK3ZfbGluZXdpZHRoKS8yLjA7XFxuXFxuICAgIHZlYzIgcG9zaXRpb24gPSAoYV9wb3NpdGlvbiArIHVfb2Zmc2V0KSAqIGFic19zY2FsZTtcXG5cXG4gICAgdmVjMiB0MSA9IG5vcm1hbGl6ZShhX3RhbmdlbnRzLnh5ICogYWJzX3NjYWxlX2FzcGVjdCk7ICAvLyBub3RlIHRoZSBzY2FsaW5nIGZvciBhc3BlY3QgcmF0aW8gaGVyZVxcbiAgICB2ZWMyIHQyID0gbm9ybWFsaXplKGFfdGFuZ2VudHMuencgKiBhYnNfc2NhbGVfYXNwZWN0KTtcXG4gICAgZmxvYXQgdSA9IGFfdGV4Y29vcmQueDtcXG4gICAgZmxvYXQgdiA9IGFfdGV4Y29vcmQueTtcXG4gICAgdmVjMiBvMSA9IHZlYzIoICt0MS55LCAtdDEueCk7XFxuICAgIHZlYzIgbzIgPSB2ZWMyKCArdDIueSwgLXQyLngpO1xcblxcbiAgICAvLyBUaGlzIGlzIGEgam9pblxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIGlmKCB0MSAhPSB0MiApIHtcXG4gICAgICAgIGZsb2F0IGFuZ2xlID0gYXRhbiAodDEueCp0Mi55LXQxLnkqdDIueCwgdDEueCp0Mi54K3QxLnkqdDIueSk7ICAvLyBBbmdsZSBuZWVkcyByZWNhbGN1bGF0aW9uIGZvciBzb21lIHJlYXNvblxcbiAgICAgICAgdmVjMiB0ICA9IG5vcm1hbGl6ZSh0MSt0Mik7XFxuICAgICAgICB2ZWMyIG8gID0gdmVjMiggKyB0LnksIC0gdC54KTtcXG5cXG4gICAgICAgIGlmICggdV9kYXNoX2luZGV4ID4gMC4wIClcXG4gICAgICAgIHtcXG4gICAgICAgICAgICAvLyBCcm9rZW4gYW5nbGVcXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgICAgICAgICAgaWYoIChhYnMoYW5nbGUpID4gVEhFVEEpICkge1xcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSB2ICogdyAqIG8gLyBjb3MoYW5nbGUvMi4wKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgcyA9IHNpZ24oYW5nbGUpO1xcbiAgICAgICAgICAgICAgICBpZiggYW5nbGUgPCAwLjAgKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiggdSA9PSArMS4wICkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHUgPSB2X3NlZ21lbnQueSArIHYgKiB3ICogdGFuKGFuZ2xlLzIuMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHYgPT0gMS4wICkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSAyLjAgKiB3ICogdDEgLyBzaW4oYW5nbGUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1IC09IDIuMCAqIHcgLyBzaW4oYW5nbGUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHZfc2VnbWVudC54IC0gdiAqIHcgKiB0YW4oYW5nbGUvMi4wKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggdiA9PSAxLjAgKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDIuMCAqIHcgKiB0MiAvIHNpbihhbmdsZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgKz0gMi4wKncgLyBzaW4oYW5nbGUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmKCB1ID09ICsxLjAgKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHZfc2VnbWVudC55ICsgdiAqIHcgKiB0YW4oYW5nbGUvMi4wKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggdiA9PSAtMS4wICkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyLjAgKiB3ICogdDEgLyBzaW4oYW5nbGUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ICs9IDIuMCAqIHcgLyBzaW4oYW5nbGUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHZfc2VnbWVudC54IC0gdiAqIHcgKiB0YW4oYW5nbGUvMi4wKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggdiA9PSAtMS4wICkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSAyLjAgKiB3ICogdDIgLyBzaW4oYW5nbGUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1IC09IDIuMCp3IC8gc2luKGFuZ2xlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLy8gQ29udGludW91cyBhbmdsZVxcbiAgICAgICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSB2ICogdyAqIG8gLyBjb3MoYW5nbGUvMi4wKTtcXG4gICAgICAgICAgICAgICAgaWYoIHUgPT0gKzEuMCApIHUgPSB2X3NlZ21lbnQueTtcXG4gICAgICAgICAgICAgICAgZWxzZSAgICAgICAgICAgIHUgPSB2X3NlZ21lbnQueDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBTb2xpZCBsaW5lXFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAgICAgZWxzZVxcbiAgICAgICAge1xcbiAgICAgICAgICAgIHBvc2l0aW9uLnh5ICs9IHYgKiB3ICogbyAvIGNvcyhhbmdsZS8yLjApO1xcbiAgICAgICAgICAgIGlmKCBhbmdsZSA8IDAuMCApIHtcXG4gICAgICAgICAgICAgICAgaWYoIHUgPT0gKzEuMCApIHtcXG4gICAgICAgICAgICAgICAgICAgIHUgPSB2X3NlZ21lbnQueSArIHYgKiB3ICogdGFuKGFuZ2xlLzIuMCk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB1ID0gdl9zZWdtZW50LnggLSB2ICogdyAqIHRhbihhbmdsZS8yLjApO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgaWYoIHUgPT0gKzEuMCApIHtcXG4gICAgICAgICAgICAgICAgICAgIHUgPSB2X3NlZ21lbnQueSArIHYgKiB3ICogdGFuKGFuZ2xlLzIuMCk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB1ID0gdl9zZWdtZW50LnggLSB2ICogdyAqIHRhbihhbmdsZS8yLjApO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAvLyBUaGlzIGlzIGEgbGluZSBzdGFydCBvciBlbmQgKHQxID09IHQyKVxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHBvc2l0aW9uICs9IHYgKiB3ICogbzE7XFxuICAgICAgICBpZiggdSA9PSAtMS4wICkge1xcbiAgICAgICAgICAgIHUgPSB2X3NlZ21lbnQueCAtIHc7XFxuICAgICAgICAgICAgcG9zaXRpb24gLT0gdyAqIHQxO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB1ID0gdl9zZWdtZW50LnkgKyB3O1xcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IHcgKiB0MjtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBNaXRlciBkaXN0YW5jZVxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgdmVjMiB0O1xcbiAgICB2ZWMyIGN1cnIgPSBhX3Bvc2l0aW9uICogYWJzX3NjYWxlO1xcbiAgICBpZiggYV90ZXhjb29yZC54IDwgMC4wICkge1xcbiAgICAgICAgdmVjMiBuZXh0ID0gY3VyciArIHQyKih2X3NlZ21lbnQueS12X3NlZ21lbnQueCk7XFxuXFxuICAgICAgICByb3RhdGUoIHQxLCArdl9hbmdsZXMueC8yLjAsIHQpO1xcbiAgICAgICAgdl9taXRlci54ID0gc2lnbmVkX2Rpc3RhbmNlKGN1cnIsIGN1cnIrdCwgcG9zaXRpb24pO1xcblxcbiAgICAgICAgcm90YXRlKCB0MiwgK3ZfYW5nbGVzLnkvMi4wLCB0KTtcXG4gICAgICAgIHZfbWl0ZXIueSA9IHNpZ25lZF9kaXN0YW5jZShuZXh0LCBuZXh0K3QsIHBvc2l0aW9uKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHZlYzIgcHJldiA9IGN1cnIgLSB0MSoodl9zZWdtZW50Lnktdl9zZWdtZW50LngpO1xcblxcbiAgICAgICAgcm90YXRlKCB0MSwgLXZfYW5nbGVzLngvMi4wLHQpO1xcbiAgICAgICAgdl9taXRlci54ID0gc2lnbmVkX2Rpc3RhbmNlKHByZXYsIHByZXYrdCwgcG9zaXRpb24pO1xcblxcbiAgICAgICAgcm90YXRlKCB0MiwgLXZfYW5nbGVzLnkvMi4wLHQpO1xcbiAgICAgICAgdl9taXRlci55ID0gc2lnbmVkX2Rpc3RhbmNlKGN1cnIsIGN1cnIrdCwgcG9zaXRpb24pO1xcbiAgICB9XFxuXFxuICAgIGlmICghY2xvc2VkICYmIHZfc2VnbWVudC54IDw9IDAuMCkge1xcbiAgICAgICAgdl9taXRlci54ID0gMWUxMDtcXG4gICAgfVxcbiAgICBpZiAoIWNsb3NlZCAmJiB2X3NlZ21lbnQueSA+PSB2X2xlbmd0aClcXG4gICAge1xcbiAgICAgICAgdl9taXRlci55ID0gMWUxMDtcXG4gICAgfVxcblxcbiAgICB2X3RleGNvb3JkID0gdmVjMiggdSwgdip3ICk7XFxuXFxuICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpbiBkZXZpY2UgY29vcmRpbmF0ZXMuIE5vdGUgdGhhdCB3ZVxcbiAgICAvLyBhbHJlYWR5IHNjYWxlZCB3aXRoIGFicyBzY2FsZSBhYm92ZS5cXG4gICAgdmVjMiBub3JtcG9zID0gcG9zaXRpb24gKiBzaWduKHVfc2NhbGVfYXNwZWN0KTtcXG4gICAgbm9ybXBvcyArPSAwLjU7ICAvLyBtYWtlIHVwIGZvciBCb2tlaCdzIG9mZnNldFxcbiAgICBub3JtcG9zIC89IHVfY2FudmFzX3NpemUgLyB1X3BpeGVsX3JhdGlvOyAgLy8gaW4gMC4uMVxcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQobm9ybXBvcyoyLjAtMS4wLCAwLjAsIDEuMCk7XFxuICAgIGdsX1Bvc2l0aW9uLnkgKj0gLTEuMDtcXG59XFxuXCI7XG4gICAgTGluZUdMR2x5cGgucHJvdG90eXBlLkZSQUdfID0gXCIvLyBGcmFnbWVudCBzaGFkZXIgdGhhdCBjYW4gYmUgY29udmVuaWVudCBkdXJpbmcgZGVidWdnaW5nIHRvIHNob3cgdGhlIGxpbmUgc2tlbGV0b24uXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSB2ZWM0ICB1X2NvbG9yO1xcbnZvaWQgbWFpbiAoKSB7XFxuICBnbF9GcmFnQ29sb3IgPSB1X2NvbG9yO1xcbn1cIjtcbiAgICBMaW5lR0xHbHlwaC5wcm90b3R5cGUuRlJBRyA9IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxuY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0O1xcbmNvbnN0IGZsb2F0IFRIRVRBID0gMTUuMCAqIDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQvMTgwLjA7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdV9kYXNoX2F0bGFzO1xcblxcbnVuaWZvcm0gdmVjMiB1X2xpbmVjYXBzO1xcbnVuaWZvcm0gZmxvYXQgdV9taXRlcl9saW1pdDtcXG51bmlmb3JtIGZsb2F0IHVfbGluZWpvaW47XFxudW5pZm9ybSBmbG9hdCB1X2FudGlhbGlhcztcXG51bmlmb3JtIGZsb2F0IHVfZGFzaF9waGFzZTtcXG51bmlmb3JtIGZsb2F0IHVfZGFzaF9wZXJpb2Q7XFxudW5pZm9ybSBmbG9hdCB1X2Rhc2hfaW5kZXg7XFxudW5pZm9ybSB2ZWMyIHVfZGFzaF9jYXBzO1xcbnVuaWZvcm0gZmxvYXQgdV9jbG9zZWQ7XFxuXFxudmFyeWluZyB2ZWM0ICB2X2NvbG9yO1xcbnZhcnlpbmcgdmVjMiAgdl9zZWdtZW50O1xcbnZhcnlpbmcgdmVjMiAgdl9hbmdsZXM7XFxudmFyeWluZyB2ZWMyICB2X3RleGNvb3JkO1xcbnZhcnlpbmcgdmVjMiAgdl9taXRlcjtcXG52YXJ5aW5nIGZsb2F0IHZfbGVuZ3RoO1xcbnZhcnlpbmcgZmxvYXQgdl9saW5ld2lkdGg7XFxuXFxuLy8gQ29tcHV0ZSBkaXN0YW5jZSB0byBjYXAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbmZsb2F0IGNhcCggaW50IHR5cGUsIGZsb2F0IGR4LCBmbG9hdCBkeSwgZmxvYXQgdCwgZmxvYXQgbGluZXdpZHRoIClcXG57XFxuICAgIGZsb2F0IGQgPSAwLjA7XFxuICAgIGR4ID0gYWJzKGR4KTtcXG4gICAgZHkgPSBhYnMoZHkpO1xcbiAgICBpZiAgICAgICh0eXBlID09IDApICBkaXNjYXJkOyAgLy8gTm9uZVxcbiAgICBlbHNlIGlmICh0eXBlID09IDEpICBkID0gc3FydChkeCpkeCtkeSpkeSk7ICAvLyBSb3VuZFxcbiAgICBlbHNlIGlmICh0eXBlID09IDMpICBkID0gKGR4K2FicyhkeSkpOyAgLy8gVHJpYW5nbGUgaW5cXG4gICAgZWxzZSBpZiAodHlwZSA9PSAyKSAgZCA9IG1heChhYnMoZHkpLCh0K2R4LWFicyhkeSkpKTsgIC8vIFRyaWFuZ2xlIG91dFxcbiAgICBlbHNlIGlmICh0eXBlID09IDQpICBkID0gbWF4KGR4LGR5KTsgIC8vIFNxdWFyZVxcbiAgICBlbHNlIGlmICh0eXBlID09IDUpICBkID0gbWF4KGR4K3QsZHkpOyAgLy8gQnV0dFxcbiAgICByZXR1cm4gZDtcXG59XFxuXFxuLy8gQ29tcHV0ZSBkaXN0YW5jZSB0byBqb2luIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5mbG9hdCBqb2luKCBpbiBpbnQgdHlwZSwgaW4gZmxvYXQgZCwgaW4gdmVjMiBzZWdtZW50LCBpbiB2ZWMyIHRleGNvb3JkLCBpbiB2ZWMyIG1pdGVyLFxcbiAgICAgICAgICAgaW4gZmxvYXQgbGluZXdpZHRoIClcXG57XFxuICAgIC8vIHRleGNvb3JkLnggaXMgZGlzdGFuY2UgZnJvbSBzdGFydFxcbiAgICAvLyB0ZXhjb29yZC55IGlzIGRpc3RhbmNlIGZyb20gY2VudGVybGluZVxcbiAgICAvLyBzZWdtZW50LnggYW5kIHkgaW5kaWNhdGUgdGhlIGxpbWl0cyAoYXMgZm9yIHRleGNvb3JkLngpIGZvciB0aGlzIHNlZ21lbnRcXG5cXG4gICAgZmxvYXQgZHggPSB0ZXhjb29yZC54O1xcblxcbiAgICAvLyBSb3VuZCBqb2luXFxuICAgIGlmKCB0eXBlID09IDEgKSB7XFxuICAgICAgICBpZiAoZHggPCBzZWdtZW50LngpIHtcXG4gICAgICAgICAgICBkID0gbWF4KGQsbGVuZ3RoKCB0ZXhjb29yZCAtIHZlYzIoc2VnbWVudC54LDAuMCkpKTtcXG4gICAgICAgICAgICAvL2QgPSBsZW5ndGgoIHRleGNvb3JkIC0gdmVjMihzZWdtZW50LngsMC4wKSk7XFxuICAgICAgICB9IGVsc2UgaWYgKGR4ID4gc2VnbWVudC55KSB7XFxuICAgICAgICAgICAgZCA9IG1heChkLGxlbmd0aCggdGV4Y29vcmQgLSB2ZWMyKHNlZ21lbnQueSwwLjApKSk7XFxuICAgICAgICAgICAgLy9kID0gbGVuZ3RoKCB0ZXhjb29yZCAtIHZlYzIoc2VnbWVudC55LDAuMCkpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIC8vIEJldmVsIGpvaW5cXG4gICAgZWxzZSBpZiAoIHR5cGUgPT0gMiApIHtcXG4gICAgICAgIGlmIChkeCA8IHNlZ21lbnQueCkge1xcbiAgICAgICAgICAgIHZlYzIgeCA9IHRleGNvb3JkIC0gdmVjMihzZWdtZW50LngsMC4wKTtcXG4gICAgICAgICAgICBkID0gbWF4KGQsIG1heChhYnMoeC54KSwgYWJzKHgueSkpKTtcXG5cXG4gICAgICAgIH0gZWxzZSBpZiAoZHggPiBzZWdtZW50LnkpIHtcXG4gICAgICAgICAgICB2ZWMyIHggPSB0ZXhjb29yZCAtIHZlYzIoc2VnbWVudC55LDAuMCk7XFxuICAgICAgICAgICAgZCA9IG1heChkLCBtYXgoYWJzKHgueCksIGFicyh4LnkpKSk7XFxuICAgICAgICB9XFxuICAgICAgICAvKiAgT3JpZ2luYWwgY29kZSBmb3IgYmV2ZWwgd2hpY2ggZG9lcyBub3Qgd29yayBmb3IgdXNcXG4gICAgICAgIGlmKCAoZHggPCBzZWdtZW50LngpIHx8ICAoZHggPiBzZWdtZW50LnkpIClcXG4gICAgICAgICAgICBkID0gbWF4KGQsIG1pbihhYnMoeC54KSxhYnMoeC55KSkpO1xcbiAgICAgICAgKi9cXG4gICAgfVxcblxcbiAgICByZXR1cm4gZDtcXG59XFxuXFxudm9pZCBtYWluKClcXG57XFxuICAgIC8vIElmIGNvbG9yIGlzIGZ1bGx5IHRyYW5zcGFyZW50IHdlIGp1c3QgZGlzY2FyZCB0aGUgZnJhZ21lbnRcXG4gICAgaWYoIHZfY29sb3IuYSA8PSAwLjAgKSB7XFxuICAgICAgICBkaXNjYXJkO1xcbiAgICB9XFxuXFxuICAgIC8vIFRlc3QgaWYgZGFzaCBwYXR0ZXJuIGlzIHRoZSBzb2xpZCBvbmUgKDApXFxuICAgIGJvb2wgc29saWQgPSAgKHVfZGFzaF9pbmRleCA9PSAwLjApO1xcblxcbiAgICAvLyBUZXN0IGlmIHBhdGggaXMgY2xvc2VkXFxuICAgIGJvb2wgY2xvc2VkID0gKHVfY2xvc2VkID4gMC4wKTtcXG5cXG4gICAgdmVjNCBjb2xvciA9IHZfY29sb3I7XFxuICAgIGZsb2F0IGR4ID0gdl90ZXhjb29yZC54O1xcbiAgICBmbG9hdCBkeSA9IHZfdGV4Y29vcmQueTtcXG4gICAgZmxvYXQgdCA9IHZfbGluZXdpZHRoLzIuMC11X2FudGlhbGlhcztcXG4gICAgZmxvYXQgd2lkdGggPSAxLjA7ICAvL3ZfbGluZXdpZHRoOyBvcmlnaW5hbCBjb2RlIGhhZCBkYXNoZXMgc2NhbGUgd2l0aCBsaW5lIHdpZHRoLCB3ZSBkbyBub3RcXG4gICAgZmxvYXQgZCA9IDAuMDtcXG5cXG4gICAgdmVjMiBsaW5lY2FwcyA9IHVfbGluZWNhcHM7XFxuICAgIHZlYzIgZGFzaF9jYXBzID0gdV9kYXNoX2NhcHM7XFxuICAgIGZsb2F0IGxpbmVfc3RhcnQgPSAwLjA7XFxuICAgIGZsb2F0IGxpbmVfc3RvcCA9IHZfbGVuZ3RoO1xcblxcbiAgICAvLyBBcHBseSBtaXRlciBsaW1pdDsgZnJhZ21lbnRzIHRvbyBmYXIgaW50byB0aGUgbWl0ZXIgYXJlIHNpbXBseSBkaXNjYXJkZWRcXG4gICAgaWYoIChkeCA8IHZfc2VnbWVudC54KSB8fCAoZHggPiB2X3NlZ21lbnQueSkgKSB7XFxuICAgICAgICBmbG9hdCBpbnRvX21pdGVyID0gbWF4KHZfc2VnbWVudC54IC0gZHgsIGR4IC0gdl9zZWdtZW50LnkpO1xcbiAgICAgICAgaWYgKGludG9fbWl0ZXIgPiB1X21pdGVyX2xpbWl0KnZfbGluZXdpZHRoLzIuMClcXG4gICAgICAgICAgZGlzY2FyZDtcXG4gICAgfVxcblxcbiAgICAvLyBTb2xpZCBsaW5lIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIGlmKCBzb2xpZCApIHtcXG4gICAgICAgIGQgPSBhYnMoZHkpO1xcbiAgICAgICAgaWYoICghY2xvc2VkKSAmJiAoZHggPCBsaW5lX3N0YXJ0KSApIHtcXG4gICAgICAgICAgICBkID0gY2FwKCBpbnQodV9saW5lY2Fwcy54KSwgYWJzKGR4KSwgYWJzKGR5KSwgdCwgdl9saW5ld2lkdGggKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYoICghY2xvc2VkKSAmJiAgKGR4ID4gbGluZV9zdG9wKSApIHtcXG4gICAgICAgICAgICBkID0gY2FwKCBpbnQodV9saW5lY2Fwcy55KSwgYWJzKGR4KS1saW5lX3N0b3AsIGFicyhkeSksIHQsIHZfbGluZXdpZHRoICk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBkID0gam9pbiggaW50KHVfbGluZWpvaW4pLCBhYnMoZHkpLCB2X3NlZ21lbnQsIHZfdGV4Y29vcmQsIHZfbWl0ZXIsIHZfbGluZXdpZHRoICk7XFxuICAgICAgICB9XFxuXFxuICAgIC8vIERhc2ggbGluZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZmxvYXQgc2VnbWVudF9zdGFydCA9IHZfc2VnbWVudC54O1xcbiAgICAgICAgZmxvYXQgc2VnbWVudF9zdG9wICA9IHZfc2VnbWVudC55O1xcbiAgICAgICAgZmxvYXQgc2VnbWVudF9jZW50ZXI9IChzZWdtZW50X3N0YXJ0K3NlZ21lbnRfc3RvcCkvMi4wO1xcbiAgICAgICAgZmxvYXQgZnJlcSAgICAgICAgICA9IHVfZGFzaF9wZXJpb2Qqd2lkdGg7XFxuICAgICAgICBmbG9hdCB1ID0gbW9kKCBkeCArIHVfZGFzaF9waGFzZSp3aWR0aCwgZnJlcSk7XFxuICAgICAgICB2ZWM0IHRleCA9IHRleHR1cmUyRCh1X2Rhc2hfYXRsYXMsIHZlYzIodS9mcmVxLCB1X2Rhc2hfaW5kZXgpKSAqIDI1NS4wIC0xMC4wOyAgLy8gY29udmVyc2lvbiB0byBpbnQtbGlrZVxcbiAgICAgICAgZmxvYXQgZGFzaF9jZW50ZXI9IHRleC54ICogd2lkdGg7XFxuICAgICAgICBmbG9hdCBkYXNoX3R5cGUgID0gdGV4Lnk7XFxuICAgICAgICBmbG9hdCBfc3RhcnQgPSB0ZXgueiAqIHdpZHRoO1xcbiAgICAgICAgZmxvYXQgX3N0b3AgID0gdGV4LmEgKiB3aWR0aDtcXG4gICAgICAgIGZsb2F0IGRhc2hfc3RhcnQgPSBkeCAtIHUgKyBfc3RhcnQ7XFxuICAgICAgICBmbG9hdCBkYXNoX3N0b3AgID0gZHggLSB1ICsgX3N0b3A7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIGV4dGVudHMgb2YgdGhlIGZpcnN0IGRhc2ggKHRoZSBvbmUgcmVsYXRpdmUgdG8gdl9zZWdtZW50LngpXFxuICAgICAgICAvLyBOb3RlOiB0aGlzIGNvdWxkIGJlIGNvbXB1dGVkIGluIHRoZSB2ZXJ0ZXggc2hhZGVyXFxuICAgICAgICBpZiggKGRhc2hfc3RvcCA8IHNlZ21lbnRfc3RhcnQpICYmIChkYXNoX2NhcHMueCAhPSA1LjApICkge1xcbiAgICAgICAgICAgIGZsb2F0IHUgPSBtb2Qoc2VnbWVudF9zdGFydCArIHVfZGFzaF9waGFzZSp3aWR0aCwgZnJlcSk7XFxuICAgICAgICAgICAgdmVjNCB0ZXggPSB0ZXh0dXJlMkQodV9kYXNoX2F0bGFzLCB2ZWMyKHUvZnJlcSwgdV9kYXNoX2luZGV4KSkgKiAyNTUuMCAtMTAuMDsgIC8vIGNvbnZlcnNpb24gdG8gaW50LWxpa2VcXG4gICAgICAgICAgICBkYXNoX2NlbnRlcj0gdGV4LnggKiB3aWR0aDtcXG4gICAgICAgICAgICAvL2Rhc2hfdHlwZSAgPSB0ZXgueTtcXG4gICAgICAgICAgICBmbG9hdCBfc3RhcnQgPSB0ZXgueiAqIHdpZHRoO1xcbiAgICAgICAgICAgIGZsb2F0IF9zdG9wICA9IHRleC5hICogd2lkdGg7XFxuICAgICAgICAgICAgZGFzaF9zdGFydCA9IHNlZ21lbnRfc3RhcnQgLSB1ICsgX3N0YXJ0O1xcbiAgICAgICAgICAgIGRhc2hfc3RvcCA9IHNlZ21lbnRfc3RhcnQgLSB1ICsgX3N0b3A7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBDb21wdXRlIGV4dGVudHMgb2YgdGhlIGxhc3QgZGFzaCAodGhlIG9uZSByZWxhdGl2ZXMgdG8gdl9zZWdtZW50LnkpXFxuICAgICAgICAvLyBOb3RlOiBUaGlzIGNvdWxkIGJlIGNvbXB1dGVkIGluIHRoZSB2ZXJ0ZXggc2hhZGVyXFxuICAgICAgICBlbHNlIGlmKCAoZGFzaF9zdGFydCA+IHNlZ21lbnRfc3RvcCkgICYmIChkYXNoX2NhcHMueSAhPSA1LjApICkge1xcbiAgICAgICAgICAgIGZsb2F0IHUgPSBtb2Qoc2VnbWVudF9zdG9wICsgdV9kYXNoX3BoYXNlKndpZHRoLCBmcmVxKTtcXG4gICAgICAgICAgICB2ZWM0IHRleCA9IHRleHR1cmUyRCh1X2Rhc2hfYXRsYXMsIHZlYzIodS9mcmVxLCB1X2Rhc2hfaW5kZXgpKSAqIDI1NS4wIC0xMC4wOyAgLy8gY29udmVyc2lvbiB0byBpbnQtbGlrZVxcbiAgICAgICAgICAgIGRhc2hfY2VudGVyPSB0ZXgueCAqIHdpZHRoO1xcbiAgICAgICAgICAgIC8vZGFzaF90eXBlICA9IHRleC55O1xcbiAgICAgICAgICAgIGZsb2F0IF9zdGFydCA9IHRleC56ICogd2lkdGg7XFxuICAgICAgICAgICAgZmxvYXQgX3N0b3AgID0gdGV4LmEgKiB3aWR0aDtcXG4gICAgICAgICAgICBkYXNoX3N0YXJ0ID0gc2VnbWVudF9zdG9wIC0gdSArIF9zdGFydDtcXG4gICAgICAgICAgICBkYXNoX3N0b3AgID0gc2VnbWVudF9zdG9wIC0gdSArIF9zdG9wO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gVGhpcyB0ZXN0IGlmIHRoZSB3ZSBhcmUgZGVhbGluZyB3aXRoIGEgZGlzY29udGludW91cyBhbmdsZVxcbiAgICAgICAgYm9vbCBkaXNjb250aW51b3VzID0gKChkeCA8ICBzZWdtZW50X2NlbnRlcikgJiYgYWJzKHZfYW5nbGVzLngpID4gVEhFVEEpIHx8XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGR4ID49IHNlZ21lbnRfY2VudGVyKSAmJiBhYnModl9hbmdsZXMueSkgPiBUSEVUQSk7XFxuICAgICAgICAvL2lmKCBkeCA8IGxpbmVfc3RhcnQpIGRpc2NvbnRpbnVvdXMgPSBmYWxzZTtcXG4gICAgICAgIC8vaWYoIGR4ID4gbGluZV9zdG9wKSAgZGlzY29udGludW91cyA9IGZhbHNlO1xcblxcbiAgICAgICAgZmxvYXQgZF9qb2luID0gam9pbiggaW50KHVfbGluZWpvaW4pLCBhYnMoZHkpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2X3NlZ21lbnQsIHZfdGV4Y29vcmQsIHZfbWl0ZXIsIHZfbGluZXdpZHRoICk7XFxuXFxuICAgICAgICAvLyBXaGVuIHBhdGggaXMgY2xvc2VkLCB3ZSBkbyBub3QgaGF2ZSByb29tIGZvciBsaW5lY2Fwcywgc28gd2UgbWFrZSByb29tXFxuICAgICAgICAvLyBieSBzaG9ydGVuaW5nIHRoZSB0b3RhbCBsZW5ndGhcXG4gICAgICAgIGlmIChjbG9zZWQpIHtcXG4gICAgICAgICAgICAgbGluZV9zdGFydCArPSB2X2xpbmV3aWR0aC8yLjA7XFxuICAgICAgICAgICAgIGxpbmVfc3RvcCAgLT0gdl9saW5ld2lkdGgvMi4wO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIHRha2UgYW50aWFsaWFzIGFyZWEgaW50byBhY2NvdW50XFxuICAgICAgICAvL2xpbmVfc3RhcnQgKz0gdV9hbnRpYWxpYXM7XFxuICAgICAgICAvL2xpbmVfc3RvcCAgLT0gdV9hbnRpYWxpYXM7XFxuXFxuICAgICAgICAvLyBDaGVjayBpcyBkYXNoIHN0b3AgaXMgYmVmb3JlIGxpbmUgc3RhcnRcXG4gICAgICAgIGlmKCBkYXNoX3N0b3AgPD0gbGluZV9zdGFydCApIHtcXG4gICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gQ2hlY2sgaXMgZGFzaCBzdGFydCBpcyBiZXlvbmQgbGluZSBzdG9wXFxuICAgICAgICBpZiggZGFzaF9zdGFydCA+PSBsaW5lX3N0b3AgKSB7XFxuICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgZGFzaCBzdGFydCBpcyBiZXlvbmQgc2VnbWVudCBzdG9wXFxuICAgICAgICBpZiggZGlzY29udGludW91cyApIHtcXG4gICAgICAgICAgICAvLyBEYXNoIHN0YXJ0IGlzIGJleW9uZCBzZWdtZW50LCB3ZSBkaXNjYXJkXFxuICAgICAgICAgICAgaWYoIChkYXNoX3N0YXJ0ID4gc2VnbWVudF9zdG9wKSApIHtcXG4gICAgICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgICAgICAgICAgLy9nbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwwLjAsMC4wLC4yNSk7IHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy8gRGFzaCBzdG9wIGlzIGJlZm9yZSBzZWdtZW50LCB3ZSBkaXNjYXJkXFxuICAgICAgICAgICAgaWYoIChkYXNoX3N0b3AgPCBzZWdtZW50X3N0YXJ0KSApIHtcXG4gICAgICAgICAgICAgICAgZGlzY2FyZDsgIC8vZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsMS4wLDAuMCwuMjUpOyByZXR1cm47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3Igcm91bmQgY2FwcyAobmljZXIgd2l0aCB0aGlzKVxcbiAgICAgICAgICAgIGlmKCBkYXNoX2NhcHMueCA9PSAxLjAgKSB7XFxuICAgICAgICAgICAgICAgIGlmKCAodSA+IF9zdG9wKSAmJiAoZGFzaF9zdG9wID4gc2VnbWVudF9zdG9wICkgICYmIChhYnModl9hbmdsZXMueSkgPCBQSS8yLjApKSB7XFxuICAgICAgICAgICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3Igcm91bmQgY2FwcyAgKG5pY2VyIHdpdGggdGhpcylcXG4gICAgICAgICAgICBpZiggZGFzaF9jYXBzLnkgPT0gMS4wICkge1xcbiAgICAgICAgICAgICAgICBpZiggKHUgPCBfc3RhcnQpICYmIChkYXNoX3N0YXJ0IDwgc2VnbWVudF9zdGFydCApICAmJiAoYWJzKHZfYW5nbGVzLngpIDwgUEkvMi4wKSkge1xcbiAgICAgICAgICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHRyaWFuZ2xlIGNhcHMgKGluICYgb3V0KSBhbmQgc3F1YXJlXFxuICAgICAgICAgICAgLy8gV2UgbWFrZSBzdXJlIHRoZSBjYXAgc3RvcCBhdCBjcm9zc2luZyBmcm9udGllclxcbiAgICAgICAgICAgIGlmKCAoZGFzaF9jYXBzLnggIT0gMS4wKSAmJiAoZGFzaF9jYXBzLnggIT0gNS4wKSApIHtcXG4gICAgICAgICAgICAgICAgaWYoIChkYXNoX3N0YXJ0IDwgc2VnbWVudF9zdGFydCApICAmJiAoYWJzKHZfYW5nbGVzLngpIDwgUEkvMi4wKSApIHtcXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGEgPSB2X2FuZ2xlcy54LzIuMDtcXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHggPSAoc2VnbWVudF9zdGFydC1keCkqY29zKGEpIC0gZHkqc2luKGEpO1xcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgeSA9IChzZWdtZW50X3N0YXJ0LWR4KSpzaW4oYSkgKyBkeSpjb3MoYSk7XFxuICAgICAgICAgICAgICAgICAgICBpZiggeCA+IDAuMCApIGRpc2NhcmQ7XFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB0cmFuc2Zvcm0gdGhlIGNhcCBpbnRvIHNxdWFyZSB0byBhdm9pZCBob2xlc1xcbiAgICAgICAgICAgICAgICAgICAgZGFzaF9jYXBzLnggPSA0LjA7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciB0cmlhbmdsZSBjYXBzIChpbiAmIG91dCkgYW5kIHNxdWFyZVxcbiAgICAgICAgICAgIC8vIFdlIG1ha2Ugc3VyZSB0aGUgY2FwIHN0b3AgYXQgY3Jvc3NpbmcgZnJvbnRpZXJcXG4gICAgICAgICAgICBpZiggKGRhc2hfY2Fwcy55ICE9IDEuMCkgJiYgKGRhc2hfY2Fwcy55ICE9IDUuMCkgKSB7XFxuICAgICAgICAgICAgICAgIGlmKCAoZGFzaF9zdG9wID4gc2VnbWVudF9zdG9wICkgICYmIChhYnModl9hbmdsZXMueSkgPCBQSS8yLjApICkge1xcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgYSA9IHZfYW5nbGVzLnkvMi4wO1xcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgeCA9IChkeC1zZWdtZW50X3N0b3ApKmNvcyhhKSAtIGR5KnNpbihhKTtcXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHkgPSAoZHgtc2VnbWVudF9zdG9wKSpzaW4oYSkgKyBkeSpjb3MoYSk7XFxuICAgICAgICAgICAgICAgICAgICBpZiggeCA+IDAuMCApIGRpc2NhcmQ7XFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB0cmFuc2Zvcm0gdGhlIGNhcHMgaW50byBzcXVhcmUgdG8gYXZvaWQgaG9sZXNcXG4gICAgICAgICAgICAgICAgICAgIGRhc2hfY2Fwcy55ID0gNC4wO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gTGluZSBjYXAgYXQgc3RhcnRcXG4gICAgICAgIGlmKCAoZHggPCBsaW5lX3N0YXJ0KSAmJiAoZGFzaF9zdGFydCA8IGxpbmVfc3RhcnQpICYmIChkYXNoX3N0b3AgPiBsaW5lX3N0YXJ0KSApIHtcXG4gICAgICAgICAgICBkID0gY2FwKCBpbnQobGluZWNhcHMueCksIGR4LWxpbmVfc3RhcnQsIGR5LCB0LCB2X2xpbmV3aWR0aCk7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBMaW5lIGNhcCBhdCBzdG9wXFxuICAgICAgICBlbHNlIGlmKCAoZHggPiBsaW5lX3N0b3ApICYmIChkYXNoX3N0b3AgPiBsaW5lX3N0b3ApICYmIChkYXNoX3N0YXJ0IDwgbGluZV9zdG9wKSApIHtcXG4gICAgICAgICAgICBkID0gY2FwKCBpbnQobGluZWNhcHMueSksIGR4LWxpbmVfc3RvcCwgZHksIHQsIHZfbGluZXdpZHRoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIERhc2ggY2FwIGxlZnQgLSBkYXNoX3R5cGUgPSAtMSwgMCBvciAxLCBidXQgdGhlcmUgbWF5IGJlIHJvdW5kb2ZmIGVycm9yc1xcbiAgICAgICAgZWxzZSBpZiggZGFzaF90eXBlIDwgLTAuNSApIHtcXG4gICAgICAgICAgICBkID0gY2FwKCBpbnQoZGFzaF9jYXBzLnkpLCBhYnModS1kYXNoX2NlbnRlciksIGR5LCB0LCB2X2xpbmV3aWR0aCk7XFxuICAgICAgICAgICAgaWYoIChkeCA+IGxpbmVfc3RhcnQpICYmIChkeCA8IGxpbmVfc3RvcCkgKVxcbiAgICAgICAgICAgICAgICBkID0gbWF4KGQsZF9qb2luKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIERhc2ggY2FwIHJpZ2h0XFxuICAgICAgICBlbHNlIGlmKCBkYXNoX3R5cGUgPiAwLjUgKSB7XFxuICAgICAgICAgICAgZCA9IGNhcCggaW50KGRhc2hfY2Fwcy54KSwgYWJzKGRhc2hfY2VudGVyLXUpLCBkeSwgdCwgdl9saW5ld2lkdGgpO1xcbiAgICAgICAgICAgIGlmKCAoZHggPiBsaW5lX3N0YXJ0KSAmJiAoZHggPCBsaW5lX3N0b3ApIClcXG4gICAgICAgICAgICAgICAgZCA9IG1heChkLGRfam9pbik7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBEYXNoIGJvZHkgKHBsYWluKVxcbiAgICAgICAgZWxzZSB7Ly8gaWYoIGRhc2hfdHlwZSA+IC0wLjUgJiYgIGRhc2hfdHlwZSA8IDAuNSkge1xcbiAgICAgICAgICAgIGQgPSBhYnMoZHkpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gTGluZSBqb2luXFxuICAgICAgICBpZiggKGR4ID4gbGluZV9zdGFydCkgJiYgKGR4IDwgbGluZV9zdG9wKSkge1xcbiAgICAgICAgICAgIGlmKCAoZHggPD0gc2VnbWVudF9zdGFydCkgJiYgKGRhc2hfc3RhcnQgPD0gc2VnbWVudF9zdGFydClcXG4gICAgICAgICAgICAgICAgJiYgKGRhc2hfc3RvcCA+PSBzZWdtZW50X3N0YXJ0KSApIHtcXG4gICAgICAgICAgICAgICAgZCA9IGRfam9pbjtcXG4gICAgICAgICAgICAgICAgLy8gQW50aWFsaWFzIGF0IG91dGVyIGJvcmRlclxcbiAgICAgICAgICAgICAgICBmbG9hdCBhbmdsZSA9IFBJLzIuK3ZfYW5nbGVzLng7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGYgPSBhYnMoIChzZWdtZW50X3N0YXJ0IC0gZHgpKmNvcyhhbmdsZSkgLSBkeSpzaW4oYW5nbGUpKTtcXG4gICAgICAgICAgICAgICAgZCA9IG1heChmLGQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmKCAoZHggPiBzZWdtZW50X3N0b3ApICYmIChkYXNoX3N0YXJ0IDw9IHNlZ21lbnRfc3RvcClcXG4gICAgICAgICAgICAgICAgICAgICAmJiAoZGFzaF9zdG9wID49IHNlZ21lbnRfc3RvcCkgKSB7XFxuICAgICAgICAgICAgICAgIGQgPSBkX2pvaW47XFxuICAgICAgICAgICAgICAgIC8vIEFudGlhbGlhcyBhdCBvdXRlciBib3JkZXJcXG4gICAgICAgICAgICAgICAgZmxvYXQgYW5nbGUgPSBQSS8yLit2X2FuZ2xlcy55O1xcbiAgICAgICAgICAgICAgICBmbG9hdCBmID0gYWJzKChkeCAtIHNlZ21lbnRfc3RvcCkqY29zKGFuZ2xlKSAtIGR5KnNpbihhbmdsZSkpO1xcbiAgICAgICAgICAgICAgICBkID0gbWF4KGYsZCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYoIGR4IDwgKHNlZ21lbnRfc3RhcnQgLSB2X2xpbmV3aWR0aC8yLikpIHtcXG4gICAgICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSBpZiggZHggPiAoc2VnbWVudF9zdG9wICsgdl9saW5ld2lkdGgvMi4pKSB7XFxuICAgICAgICAgICAgICAgIGRpc2NhcmQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiggZHggPCAoc2VnbWVudF9zdGFydCAtIHZfbGluZXdpZHRoLzIuKSkge1xcbiAgICAgICAgICAgIGRpc2NhcmQ7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmKCBkeCA+IChzZWdtZW50X3N0b3AgKyB2X2xpbmV3aWR0aC8yLikpIHtcXG4gICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIERpc3RhbmNlIHRvIGJvcmRlciAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgZCA9IGQgLSB0O1xcbiAgICBpZiggZCA8IDAuMCApIHtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZCAvPSB1X2FudGlhbGlhcztcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IucmdiLCBleHAoLWQqZCkqY29sb3IuYSk7XFxuICAgIH1cXG59XCI7XG4gICAgTGluZUdMR2x5cGgucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnbDtcbiAgICAgICAgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB0aGlzLl9zY2FsZV9hc3BlY3QgPSAwO1xuICAgICAgICB0aGlzLnByb2cgPSBuZXcgZ2xvbzIuUHJvZ3JhbShnbCk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfc2hhZGVycyh0aGlzLlZFUlQsIHRoaXMuRlJBRyk7XG4gICAgICAgIHRoaXMuaW5kZXhfYnVmZmVyID0gbmV3IGdsb28yLkluZGV4QnVmZmVyKGdsKTtcbiAgICAgICAgdGhpcy52Ym9fcG9zaXRpb24gPSBuZXcgZ2xvbzIuVmVydGV4QnVmZmVyKGdsKTtcbiAgICAgICAgdGhpcy52Ym9fdGFuZ2VudHMgPSBuZXcgZ2xvbzIuVmVydGV4QnVmZmVyKGdsKTtcbiAgICAgICAgdGhpcy52Ym9fc2VnbWVudCA9IG5ldyBnbG9vMi5WZXJ0ZXhCdWZmZXIoZ2wpO1xuICAgICAgICB0aGlzLnZib19hbmdsZXMgPSBuZXcgZ2xvbzIuVmVydGV4QnVmZmVyKGdsKTtcbiAgICAgICAgdGhpcy52Ym9fdGV4Y29vcmQgPSBuZXcgZ2xvbzIuVmVydGV4QnVmZmVyKGdsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGFzaF9hdGxhcyA9IG5ldyBEYXNoQXRsYXMoZ2wpO1xuICAgIH07XG4gICAgTGluZUdMR2x5cGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoaW5kaWNlcywgbWFpbkdseXBoLCB0cmFucykge1xuICAgICAgICB2YXIgYmFrZWRfb2Zmc2V0LCBjaHVuaywgY2h1bmtzLCBjaHVua3NpemUsIGksIGwsIG1haW5HbEdseXBoLCBudmVydGljZXMsIG9mZnNldCwgcCwgcSwgcmVmLCByZWYxLCByZWYyLCByZXN1bHRzLCBzY2FsZV9sZW5ndGgsIHN4LCBzeSwgdGhlc2VfaW5kaWNlcywgdWludDE2X2luZGV4O1xuICAgICAgICBtYWluR2xHbHlwaCA9IG1haW5HbHlwaC5nbGdseXBoO1xuICAgICAgICBpZiAobWFpbkdsR2x5cGguZGF0YV9jaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAoIShpc0Zpbml0ZSh0cmFucy5keCkgJiYgaXNGaW5pdGUodHJhbnMuZHkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1haW5HbEdseXBoLl9iYWtlZF9vZmZzZXQgPSBbdHJhbnMuZHgsIHRyYW5zLmR5XTtcbiAgICAgICAgICAgIG1haW5HbEdseXBoLl9zZXRfZGF0YSgpO1xuICAgICAgICAgICAgbWFpbkdsR2x5cGguZGF0YV9jaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlzdWFsc19jaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRfdmlzdWFscygpO1xuICAgICAgICAgICAgdGhpcy52aXN1YWxzX2NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzeCA9IHRyYW5zLnN4O1xuICAgICAgICBzeSA9IHRyYW5zLnN5O1xuICAgICAgICBzY2FsZV9sZW5ndGggPSBNYXRoLnNxcnQoc3ggKiBzeCArIHN5ICogc3kpO1xuICAgICAgICBzeCAvPSBzY2FsZV9sZW5ndGg7XG4gICAgICAgIHN5IC89IHNjYWxlX2xlbmd0aDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX3NjYWxlX2FzcGVjdCAtIChzeSAvIHN4KSkgPiBNYXRoLmFicygxZS0zICogdGhpcy5fc2NhbGVfYXNwZWN0KSkge1xuICAgICAgICAgICAgbWFpbkdsR2x5cGguX3VwZGF0ZV9zY2FsZShzeCwgc3kpO1xuICAgICAgICAgICAgdGhpcy5fc2NhbGVfYXNwZWN0ID0gc3kgLyBzeDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2cuc2V0X2F0dHJpYnV0ZSgnYV9wb3NpdGlvbicsICd2ZWMyJywgbWFpbkdsR2x5cGgudmJvX3Bvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wcm9nLnNldF9hdHRyaWJ1dGUoJ2FfdGFuZ2VudHMnLCAndmVjNCcsIG1haW5HbEdseXBoLnZib190YW5nZW50cyk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfYXR0cmlidXRlKCdhX3NlZ21lbnQnLCAndmVjMicsIG1haW5HbEdseXBoLnZib19zZWdtZW50KTtcbiAgICAgICAgdGhpcy5wcm9nLnNldF9hdHRyaWJ1dGUoJ2FfYW5nbGVzJywgJ3ZlYzInLCBtYWluR2xHbHlwaC52Ym9fYW5nbGVzKTtcbiAgICAgICAgdGhpcy5wcm9nLnNldF9hdHRyaWJ1dGUoJ2FfdGV4Y29vcmQnLCAndmVjMicsIG1haW5HbEdseXBoLnZib190ZXhjb29yZCk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9sZW5ndGgnLCAnZmxvYXQnLCBbbWFpbkdsR2x5cGguY3Vtc3VtXSk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfdGV4dHVyZSgndV9kYXNoX2F0bGFzJywgdGhpcy5kYXNoX2F0bGFzLnRleCk7XG4gICAgICAgIGJha2VkX29mZnNldCA9IG1haW5HbEdseXBoLl9iYWtlZF9vZmZzZXQ7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9waXhlbF9yYXRpbycsICdmbG9hdCcsIFt0cmFucy5waXhlbF9yYXRpb10pO1xuICAgICAgICB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3VfY2FudmFzX3NpemUnLCAndmVjMicsIFt0cmFucy53aWR0aCwgdHJhbnMuaGVpZ2h0XSk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9vZmZzZXQnLCAndmVjMicsIFt0cmFucy5keCAtIGJha2VkX29mZnNldFswXSwgdHJhbnMuZHkgLSBiYWtlZF9vZmZzZXRbMV1dKTtcbiAgICAgICAgdGhpcy5wcm9nLnNldF91bmlmb3JtKCd1X3NjYWxlX2FzcGVjdCcsICd2ZWMyJywgW3N4LCBzeV0pO1xuICAgICAgICB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3Vfc2NhbGVfbGVuZ3RoJywgJ2Zsb2F0JywgW3NjYWxlX2xlbmd0aF0pO1xuICAgICAgICB0aGlzLklfdHJpYW5nbGVzID0gbWFpbkdsR2x5cGguSV90cmlhbmdsZXM7XG4gICAgICAgIGlmICh0aGlzLklfdHJpYW5nbGVzLmxlbmd0aCA8IDY1NTM1KSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4X2J1ZmZlci5zZXRfc2l6ZSh0aGlzLklfdHJpYW5nbGVzLmxlbmd0aCAqIDIpO1xuICAgICAgICAgICAgdGhpcy5pbmRleF9idWZmZXIuc2V0X2RhdGEoMCwgbmV3IFVpbnQxNkFycmF5KHRoaXMuSV90cmlhbmdsZXMpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2cuZHJhdyh0aGlzLmdsLlRSSUFOR0xFUywgdGhpcy5pbmRleF9idWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5kaWNlcyA9IHRoaXMuSV90cmlhbmdsZXM7XG4gICAgICAgICAgICBudmVydGljZXMgPSB0aGlzLklfdHJpYW5nbGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNodW5rc2l6ZSA9IDY0MDA4O1xuICAgICAgICAgICAgY2h1bmtzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBsID0gMCwgcmVmID0gTWF0aC5jZWlsKG52ZXJ0aWNlcyAvIGNodW5rc2l6ZSk7IDAgPD0gcmVmID8gbCA8IHJlZiA6IGwgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrbCA6IC0tbCkge1xuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IHAgPSAwLCByZWYxID0gaW5kaWNlcy5sZW5ndGg7IDAgPD0gcmVmMSA/IHAgPCByZWYxIDogcCA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK3AgOiAtLXApIHtcbiAgICAgICAgICAgICAgICB1aW50MTZfaW5kZXggPSBpbmRpY2VzW2ldICUgY2h1bmtzaXplO1xuICAgICAgICAgICAgICAgIGNodW5rID0gTWF0aC5mbG9vcihpbmRpY2VzW2ldIC8gY2h1bmtzaXplKTtcbiAgICAgICAgICAgICAgICBjaHVua3NbY2h1bmtdLnB1c2godWludDE2X2luZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY2h1bmsgPSBxID0gMCwgcmVmMiA9IGNodW5rcy5sZW5ndGg7IDAgPD0gcmVmMiA/IHEgPCByZWYyIDogcSA+IHJlZjI7IGNodW5rID0gMCA8PSByZWYyID8gKytxIDogLS1xKSB7XG4gICAgICAgICAgICAgICAgdGhlc2VfaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShjaHVua3NbY2h1bmtdKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBjaHVuayAqIGNodW5rc2l6ZSAqIDQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoZXNlX2luZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnByb2cuc2V0X2F0dHJpYnV0ZSgnYV9wb3NpdGlvbicsICd2ZWMyJywgbWFpbkdsR2x5cGgudmJvX3Bvc2l0aW9uLCAwLCBvZmZzZXQgKiAyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2cuc2V0X2F0dHJpYnV0ZSgnYV90YW5nZW50cycsICd2ZWM0JywgbWFpbkdsR2x5cGgudmJvX3RhbmdlbnRzLCAwLCBvZmZzZXQgKiA0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2cuc2V0X2F0dHJpYnV0ZSgnYV9zZWdtZW50JywgJ3ZlYzInLCBtYWluR2xHbHlwaC52Ym9fc2VnbWVudCwgMCwgb2Zmc2V0ICogMik7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9nLnNldF9hdHRyaWJ1dGUoJ2FfYW5nbGVzJywgJ3ZlYzInLCBtYWluR2xHbHlwaC52Ym9fYW5nbGVzLCAwLCBvZmZzZXQgKiAyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2cuc2V0X2F0dHJpYnV0ZSgnYV90ZXhjb29yZCcsICd2ZWMyJywgbWFpbkdsR2x5cGgudmJvX3RleGNvb3JkLCAwLCBvZmZzZXQgKiAyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4X2J1ZmZlci5zZXRfc2l6ZSh0aGVzZV9pbmRpY2VzLmxlbmd0aCAqIDIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhfYnVmZmVyLnNldF9kYXRhKDAsIHRoZXNlX2luZGljZXMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLnByb2cuZHJhdyh0aGlzLmdsLlRSSUFOR0xFUywgdGhpcy5pbmRleF9idWZmZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaW5lR0xHbHlwaC5wcm90b3R5cGUuX3NldF9kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iYWtlKCk7XG4gICAgICAgIHRoaXMudmJvX3Bvc2l0aW9uLnNldF9zaXplKHRoaXMuVl9wb3NpdGlvbi5sZW5ndGggKiA0KTtcbiAgICAgICAgdGhpcy52Ym9fcG9zaXRpb24uc2V0X2RhdGEoMCwgdGhpcy5WX3Bvc2l0aW9uKTtcbiAgICAgICAgdGhpcy52Ym9fdGFuZ2VudHMuc2V0X3NpemUodGhpcy5WX3RhbmdlbnRzLmxlbmd0aCAqIDQpO1xuICAgICAgICB0aGlzLnZib190YW5nZW50cy5zZXRfZGF0YSgwLCB0aGlzLlZfdGFuZ2VudHMpO1xuICAgICAgICB0aGlzLnZib19hbmdsZXMuc2V0X3NpemUodGhpcy5WX2FuZ2xlcy5sZW5ndGggKiA0KTtcbiAgICAgICAgdGhpcy52Ym9fYW5nbGVzLnNldF9kYXRhKDAsIHRoaXMuVl9hbmdsZXMpO1xuICAgICAgICB0aGlzLnZib190ZXhjb29yZC5zZXRfc2l6ZSh0aGlzLlZfdGV4Y29vcmQubGVuZ3RoICogNCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZib190ZXhjb29yZC5zZXRfZGF0YSgwLCB0aGlzLlZfdGV4Y29vcmQpO1xuICAgIH07XG4gICAgTGluZUdMR2x5cGgucHJvdG90eXBlLl9zZXRfdmlzdWFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhcCwgY29sb3IsIGRhc2hfaW5kZXgsIGRhc2hfcGF0dGVybiwgZGFzaF9wZXJpb2QsIGpvaW4sIHJlZjtcbiAgICAgICAgY29sb3IgPSBjb2xvcl8xLmNvbG9yMnJnYmEodGhpcy5nbHlwaC52aXN1YWxzLmxpbmUubGluZV9jb2xvci52YWx1ZSgpLCB0aGlzLmdseXBoLnZpc3VhbHMubGluZS5saW5lX2FscGhhLnZhbHVlKCkpO1xuICAgICAgICBjYXAgPSB0aGlzLkNBUFNbdGhpcy5nbHlwaC52aXN1YWxzLmxpbmUubGluZV9jYXAudmFsdWUoKV07XG4gICAgICAgIGpvaW4gPSB0aGlzLkpPSU5TW3RoaXMuZ2x5cGgudmlzdWFscy5saW5lLmxpbmVfam9pbi52YWx1ZSgpXTtcbiAgICAgICAgdGhpcy5wcm9nLnNldF91bmlmb3JtKCd1X2NvbG9yJywgJ3ZlYzQnLCBjb2xvcik7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9saW5ld2lkdGgnLCAnZmxvYXQnLCBbdGhpcy5nbHlwaC52aXN1YWxzLmxpbmUubGluZV93aWR0aC52YWx1ZSgpXSk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9hbnRpYWxpYXMnLCAnZmxvYXQnLCBbMC45XSk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9saW5lY2FwcycsICd2ZWMyJywgW2NhcCwgY2FwXSk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9saW5lam9pbicsICdmbG9hdCcsIFtqb2luXSk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9taXRlcl9saW1pdCcsICdmbG9hdCcsIFsxMC4wXSk7XG4gICAgICAgIGRhc2hfcGF0dGVybiA9IHRoaXMuZ2x5cGgudmlzdWFscy5saW5lLmxpbmVfZGFzaC52YWx1ZSgpO1xuICAgICAgICBkYXNoX2luZGV4ID0gMDtcbiAgICAgICAgZGFzaF9wZXJpb2QgPSAxO1xuICAgICAgICBpZiAoZGFzaF9wYXR0ZXJuLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVmID0gdGhpcy5kYXNoX2F0bGFzLmdldF9hdGxhc19kYXRhKGRhc2hfcGF0dGVybiksIGRhc2hfaW5kZXggPSByZWZbMF0sIGRhc2hfcGVyaW9kID0gcmVmWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9kYXNoX2luZGV4JywgJ2Zsb2F0JywgW2Rhc2hfaW5kZXhdKTtcbiAgICAgICAgdGhpcy5wcm9nLnNldF91bmlmb3JtKCd1X2Rhc2hfcGhhc2UnLCAnZmxvYXQnLCBbdGhpcy5nbHlwaC52aXN1YWxzLmxpbmUubGluZV9kYXNoX29mZnNldC52YWx1ZSgpXSk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9kYXNoX3BlcmlvZCcsICdmbG9hdCcsIFtkYXNoX3BlcmlvZF0pO1xuICAgICAgICB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3VfZGFzaF9jYXBzJywgJ3ZlYzInLCBbY2FwLCBjYXBdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9jbG9zZWQnLCAnZmxvYXQnLCBbMF0pO1xuICAgIH07XG4gICAgTGluZUdMR2x5cGgucHJvdG90eXBlLl9iYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgQSwgSSwgVCwgVl9hbmdsZXMsIFZfYW5nbGVzMiwgVl9wb3NpdGlvbiwgVl9wb3NpdGlvbjIsIFZfdGFuZ2VudHMsIFZfdGFuZ2VudHMyLCBWX3RleGNvb3JkLCBWX3RleGNvb3JkMiwgVnAsIFZ0LCBfeCwgX3ksIGksIGkxLCBqLCBrLCBsLCBtLCBuLCBuaSwgbywgcCwgcSwgciwgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0LCByZWY1LCByZWY2LCByZWY3LCByZXN1bHRzLCBzLCB0LCB1LCB3LCB5LCB6O1xuICAgICAgICBuID0gdGhpcy5udmVydGljZXM7XG4gICAgICAgIF94ID0gbmV3IEZsb2F0NjRBcnJheSh0aGlzLmdseXBoLl94KTtcbiAgICAgICAgX3kgPSBuZXcgRmxvYXQ2NEFycmF5KHRoaXMuZ2x5cGguX3kpO1xuICAgICAgICBWX3Bvc2l0aW9uID0gVnAgPSBuZXcgRmxvYXQzMkFycmF5KG4gKiAyKTtcbiAgICAgICAgVl9hbmdsZXMgPSBuZXcgRmxvYXQzMkFycmF5KG4gKiAyKTtcbiAgICAgICAgVl90YW5nZW50cyA9IFZ0ID0gbmV3IEZsb2F0MzJBcnJheShuICogNCk7XG4gICAgICAgIFZfdGV4Y29vcmQgPSBuZXcgRmxvYXQzMkFycmF5KG4gKiAyKTtcbiAgICAgICAgZm9yIChpID0gbCA9IDAsIHJlZiA9IG47IDAgPD0gcmVmID8gbCA8IHJlZiA6IGwgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrbCA6IC0tbCkge1xuICAgICAgICAgICAgVl9wb3NpdGlvbltpICogMiArIDBdID0gX3hbaV0gKyB0aGlzLl9iYWtlZF9vZmZzZXRbMF07XG4gICAgICAgICAgICBWX3Bvc2l0aW9uW2kgKiAyICsgMV0gPSBfeVtpXSArIHRoaXMuX2Jha2VkX29mZnNldFsxXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhbmdlbnRzID0gVCA9IG5ldyBGbG9hdDMyQXJyYXkobiAqIDIgLSAyKTtcbiAgICAgICAgZm9yIChpID0gcCA9IDAsIHJlZjEgPSBuIC0gMTsgMCA8PSByZWYxID8gcCA8IHJlZjEgOiBwID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsrcCA6IC0tcCkge1xuICAgICAgICAgICAgVFtpICogMiArIDBdID0gVnBbKGkgKyAxKSAqIDIgKyAwXSAtIFZwW2kgKiAyICsgMF07XG4gICAgICAgICAgICBUW2kgKiAyICsgMV0gPSBWcFsoaSArIDEpICogMiArIDFdIC0gVnBbaSAqIDIgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBxID0gMCwgcmVmMiA9IG4gLSAxOyAwIDw9IHJlZjIgPyBxIDwgcmVmMiA6IHEgPiByZWYyOyBpID0gMCA8PSByZWYyID8gKytxIDogLS1xKSB7XG4gICAgICAgICAgICBWX3RhbmdlbnRzWyhpICsgMSkgKiA0ICsgMF0gPSBUW2kgKiAyICsgMF07XG4gICAgICAgICAgICBWX3RhbmdlbnRzWyhpICsgMSkgKiA0ICsgMV0gPSBUW2kgKiAyICsgMV07XG4gICAgICAgICAgICBWX3RhbmdlbnRzW2kgKiA0ICsgMl0gPSBUW2kgKiAyICsgMF07XG4gICAgICAgICAgICBWX3RhbmdlbnRzW2kgKiA0ICsgM10gPSBUW2kgKiAyICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgVl90YW5nZW50c1swICogNCArIDBdID0gVFswXTtcbiAgICAgICAgVl90YW5nZW50c1swICogNCArIDFdID0gVFsxXTtcbiAgICAgICAgVl90YW5nZW50c1sobiAtIDEpICogNCArIDJdID0gVFsobiAtIDIpICogMiArIDBdO1xuICAgICAgICBWX3RhbmdlbnRzWyhuIC0gMSkgKiA0ICsgM10gPSBUWyhuIC0gMikgKiAyICsgMV07XG4gICAgICAgIEEgPSBuZXcgRmxvYXQzMkFycmF5KG4pO1xuICAgICAgICBmb3IgKGkgPSByID0gMCwgcmVmMyA9IG47IDAgPD0gcmVmMyA/IHIgPCByZWYzIDogciA+IHJlZjM7IGkgPSAwIDw9IHJlZjMgPyArK3IgOiAtLXIpIHtcbiAgICAgICAgICAgIEFbaV0gPSBNYXRoLmF0YW4yKFZ0W2kgKiA0ICsgMF0gKiBWdFtpICogNCArIDNdIC0gVnRbaSAqIDQgKyAxXSAqIFZ0W2kgKiA0ICsgMl0sIFZ0W2kgKiA0ICsgMF0gKiBWdFtpICogNCArIDJdICsgVnRbaSAqIDQgKyAxXSAqIFZ0W2kgKiA0ICsgM10pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IHMgPSAwLCByZWY0ID0gbiAtIDE7IDAgPD0gcmVmNCA/IHMgPCByZWY0IDogcyA+IHJlZjQ7IGkgPSAwIDw9IHJlZjQgPyArK3MgOiAtLXMpIHtcbiAgICAgICAgICAgIFZfYW5nbGVzW2kgKiAyICsgMF0gPSBBW2ldO1xuICAgICAgICAgICAgVl9hbmdsZXNbaSAqIDIgKyAxXSA9IEFbaSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIG0gPSA0ICogbiAtIDQ7XG4gICAgICAgIHRoaXMuVl9wb3NpdGlvbiA9IFZfcG9zaXRpb24yID0gbmV3IEZsb2F0MzJBcnJheShtICogMik7XG4gICAgICAgIHRoaXMuVl9hbmdsZXMgPSBWX2FuZ2xlczIgPSBuZXcgRmxvYXQzMkFycmF5KG0gKiAyKTtcbiAgICAgICAgdGhpcy5WX3RhbmdlbnRzID0gVl90YW5nZW50czIgPSBuZXcgRmxvYXQzMkFycmF5KG0gKiA0KTtcbiAgICAgICAgdGhpcy5WX3RleGNvb3JkID0gVl90ZXhjb29yZDIgPSBuZXcgRmxvYXQzMkFycmF5KG0gKiAyKTtcbiAgICAgICAgbyA9IDI7XG4gICAgICAgIGZvciAoaSA9IHQgPSAwLCByZWY1ID0gbjsgMCA8PSByZWY1ID8gdCA8IHJlZjUgOiB0ID4gcmVmNTsgaSA9IDAgPD0gcmVmNSA/ICsrdCA6IC0tdCkge1xuICAgICAgICAgICAgZm9yIChqID0gdSA9IDA7IHUgPCA0OyBqID0gKyt1KSB7XG4gICAgICAgICAgICAgICAgZm9yIChrID0gdyA9IDA7IHcgPCAyOyBrID0gKyt3KSB7XG4gICAgICAgICAgICAgICAgICAgIFZfcG9zaXRpb24yWyhpICogNCArIGogLSBvKSAqIDIgKyBrXSA9IFZfcG9zaXRpb25baSAqIDIgKyBrXTtcbiAgICAgICAgICAgICAgICAgICAgVl9hbmdsZXMyWyhpICogNCArIGopICogMiArIGtdID0gVl9hbmdsZXNbaSAqIDIgKyBrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChrID0geSA9IDA7IHkgPCA0OyBrID0gKyt5KSB7XG4gICAgICAgICAgICAgICAgICAgIFZfdGFuZ2VudHMyWyhpICogNCArIGogLSBvKSAqIDQgKyBrXSA9IFZfdGFuZ2VudHNbaSAqIDQgKyBrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0geiA9IDAsIHJlZjYgPSBuOyAwIDw9IHJlZjYgPyB6IDw9IHJlZjYgOiB6ID49IHJlZjY7IGkgPSAwIDw9IHJlZjYgPyArK3ogOiAtLXopIHtcbiAgICAgICAgICAgIFZfdGV4Y29vcmQyWyhpICogNCArIDApICogMiArIDBdID0gLTE7XG4gICAgICAgICAgICBWX3RleGNvb3JkMlsoaSAqIDQgKyAxKSAqIDIgKyAwXSA9IC0xO1xuICAgICAgICAgICAgVl90ZXhjb29yZDJbKGkgKiA0ICsgMikgKiAyICsgMF0gPSArMTtcbiAgICAgICAgICAgIFZfdGV4Y29vcmQyWyhpICogNCArIDMpICogMiArIDBdID0gKzE7XG4gICAgICAgICAgICBWX3RleGNvb3JkMlsoaSAqIDQgKyAwKSAqIDIgKyAxXSA9IC0xO1xuICAgICAgICAgICAgVl90ZXhjb29yZDJbKGkgKiA0ICsgMSkgKiAyICsgMV0gPSArMTtcbiAgICAgICAgICAgIFZfdGV4Y29vcmQyWyhpICogNCArIDIpICogMiArIDFdID0gLTE7XG4gICAgICAgICAgICBWX3RleGNvb3JkMlsoaSAqIDQgKyAzKSAqIDIgKyAxXSA9ICsxO1xuICAgICAgICB9XG4gICAgICAgIG5pID0gKG4gLSAxKSAqIDY7XG4gICAgICAgIHRoaXMuSV90cmlhbmdsZXMgPSBJID0gbmV3IFVpbnQzMkFycmF5KG5pKTtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBpMSA9IDAsIHJlZjcgPSBuOyAwIDw9IHJlZjcgPyBpMSA8IHJlZjcgOiBpMSA+IHJlZjc7IGkgPSAwIDw9IHJlZjcgPyArK2kxIDogLS1pMSkge1xuICAgICAgICAgICAgSVtpICogNiArIDBdID0gMCArIDQgKiBpO1xuICAgICAgICAgICAgSVtpICogNiArIDFdID0gMSArIDQgKiBpO1xuICAgICAgICAgICAgSVtpICogNiArIDJdID0gMyArIDQgKiBpO1xuICAgICAgICAgICAgSVtpICogNiArIDNdID0gMiArIDQgKiBpO1xuICAgICAgICAgICAgSVtpICogNiArIDRdID0gMCArIDQgKiBpO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKElbaSAqIDYgKyA1XSA9IDMgKyA0ICogaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBMaW5lR0xHbHlwaC5wcm90b3R5cGUuX3VwZGF0ZV9zY2FsZSA9IGZ1bmN0aW9uIChzeCwgc3kpIHtcbiAgICAgICAgdmFyIE4sIFQsIFZfc2VnbWVudCwgVl9zZWdtZW50MiwgY3Vtc3VtLCBpLCBqLCBrLCBsLCBtLCBuLCBwLCBxLCByLCByZWYsIHJlZjEsIHJlZjIsIHM7XG4gICAgICAgIG4gPSB0aGlzLm52ZXJ0aWNlcztcbiAgICAgICAgbSA9IDQgKiBuIC0gNDtcbiAgICAgICAgVCA9IHRoaXMudGFuZ2VudHM7XG4gICAgICAgIE4gPSBuZXcgRmxvYXQzMkFycmF5KG4gLSAxKTtcbiAgICAgICAgVl9zZWdtZW50ID0gbmV3IEZsb2F0MzJBcnJheShuICogMik7XG4gICAgICAgIHRoaXMuVl9zZWdtZW50ID0gVl9zZWdtZW50MiA9IG5ldyBGbG9hdDMyQXJyYXkobSAqIDIpO1xuICAgICAgICBmb3IgKGkgPSBsID0gMCwgcmVmID0gbiAtIDE7IDAgPD0gcmVmID8gbCA8IHJlZiA6IGwgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrbCA6IC0tbCkge1xuICAgICAgICAgICAgTltpXSA9IE1hdGguc3FydChNYXRoLnBvdyhUW2kgKiAyICsgMF0gKiBzeCwgMikgKyBNYXRoLnBvdyhUW2kgKiAyICsgMV0gKiBzeSwgMikpO1xuICAgICAgICB9XG4gICAgICAgIGN1bXN1bSA9IDA7XG4gICAgICAgIGZvciAoaSA9IHAgPSAwLCByZWYxID0gbiAtIDE7IDAgPD0gcmVmMSA/IHAgPCByZWYxIDogcCA+IHJlZjE7IGkgPSAwIDw9IHJlZjEgPyArK3AgOiAtLXApIHtcbiAgICAgICAgICAgIGN1bXN1bSArPSBOW2ldO1xuICAgICAgICAgICAgVl9zZWdtZW50WyhpICsgMSkgKiAyICsgMF0gPSBjdW1zdW07XG4gICAgICAgICAgICBWX3NlZ21lbnRbaSAqIDIgKyAxXSA9IGN1bXN1bTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBxID0gMCwgcmVmMiA9IG47IDAgPD0gcmVmMiA/IHEgPCByZWYyIDogcSA+IHJlZjI7IGkgPSAwIDw9IHJlZjIgPyArK3EgOiAtLXEpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IHIgPSAwOyByIDwgNDsgaiA9ICsrcikge1xuICAgICAgICAgICAgICAgIGZvciAoayA9IHMgPSAwOyBzIDwgMjsgayA9ICsrcykge1xuICAgICAgICAgICAgICAgICAgICBWX3NlZ21lbnQyWyhpICogNCArIGopICogMiArIGtdID0gVl9zZWdtZW50W2kgKiAyICsga107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3Vtc3VtID0gY3Vtc3VtO1xuICAgICAgICB0aGlzLnZib19zZWdtZW50LnNldF9zaXplKHRoaXMuVl9zZWdtZW50Lmxlbmd0aCAqIDQpO1xuICAgICAgICByZXR1cm4gdGhpcy52Ym9fc2VnbWVudC5zZXRfZGF0YSgwLCB0aGlzLlZfc2VnbWVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGluZUdMR2x5cGg7XG59KShiYXNlXzEuQmFzZUdMR2x5cGgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5yZXF1aXJlKFwiLi9pbmRleFwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE1hcmtlckdMR2x5cGgsIGV4dGVuZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHtcbiAgICBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSlcbiAgICAgICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xufSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBnbG9vMiA9IHJlcXVpcmUoXCJnbG9vMlwiKTtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiY29yZS9sb2dnaW5nXCIpO1xudmFyIGJhc2VfMSA9IHJlcXVpcmUoXCIuL2Jhc2VcIik7XG5NYXJrZXJHTEdseXBoID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKE1hcmtlckdMR2x5cGgsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIE1hcmtlckdMR2x5cGgoKSB7XG4gICAgICAgIHJldHVybiBNYXJrZXJHTEdseXBoLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBNYXJrZXJHTEdseXBoLnByb3RvdHlwZS5WRVJUID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5jb25zdCBmbG9hdCBTUVJUXzIgPSAxLjQxNDIxMzU2MjM3MzA5NTE7XFxuLy9cXG51bmlmb3JtIGZsb2F0IHVfcGl4ZWxfcmF0aW87XFxudW5pZm9ybSB2ZWMyIHVfY2FudmFzX3NpemU7XFxudW5pZm9ybSB2ZWMyIHVfb2Zmc2V0O1xcbnVuaWZvcm0gdmVjMiB1X3NjYWxlO1xcbnVuaWZvcm0gZmxvYXQgdV9hbnRpYWxpYXM7XFxuLy9cXG5hdHRyaWJ1dGUgZmxvYXQgYV94O1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3k7XFxuYXR0cmlidXRlIGZsb2F0IGFfc2l6ZTtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9hbmdsZTsgIC8vIGluIHJhZGlhbnNcXG5hdHRyaWJ1dGUgZmxvYXQgYV9saW5ld2lkdGg7XFxuYXR0cmlidXRlIHZlYzQgIGFfZmdfY29sb3I7XFxuYXR0cmlidXRlIHZlYzQgIGFfYmdfY29sb3I7XFxuLy9cXG52YXJ5aW5nIGZsb2F0IHZfbGluZXdpZHRoO1xcbnZhcnlpbmcgZmxvYXQgdl9zaXplO1xcbnZhcnlpbmcgdmVjNCAgdl9mZ19jb2xvcjtcXG52YXJ5aW5nIHZlYzQgIHZfYmdfY29sb3I7XFxudmFyeWluZyB2ZWMyICB2X3JvdGF0aW9uO1xcblxcbnZvaWQgbWFpbiAodm9pZClcXG57XFxuICAgIHZfc2l6ZSA9IGFfc2l6ZSAqIHVfcGl4ZWxfcmF0aW87XFxuICAgIHZfbGluZXdpZHRoID0gYV9saW5ld2lkdGggKiB1X3BpeGVsX3JhdGlvO1xcbiAgICB2X2ZnX2NvbG9yID0gYV9mZ19jb2xvcjtcXG4gICAgdl9iZ19jb2xvciA9IGFfYmdfY29sb3I7XFxuICAgIHZfcm90YXRpb24gPSB2ZWMyKGNvcygtYV9hbmdsZSksIHNpbigtYV9hbmdsZSkpO1xcbiAgICAvLyBDYWxjdWxhdGUgcG9zaXRpb24gLSB0aGUgLTAuNSBpcyB0byBjb3JyZWN0IGZvciBjYW52YXMgb3JpZ2luXFxuICAgIHZlYzIgcG9zID0gKHZlYzIoYV94LCBhX3kpICsgdV9vZmZzZXQpICogdV9zY2FsZTsgLy8gaW4gcGl4ZWxzXFxuICAgIHBvcyArPSAwLjU7ICAvLyBtYWtlIHVwIGZvciBCb2tlaCdzIG9mZnNldFxcbiAgICBwb3MgLz0gdV9jYW52YXNfc2l6ZSAvIHVfcGl4ZWxfcmF0aW87ICAvLyBpbiAwLi4xXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3MqMi4wLTEuMCwgMC4wLCAxLjApO1xcbiAgICBnbF9Qb3NpdGlvbi55ICo9IC0xLjA7XFxuICAgIGdsX1BvaW50U2l6ZSA9IFNRUlRfMiAqIHZfc2l6ZSArIDIuMCAqICh2X2xpbmV3aWR0aCArIDEuNSp1X2FudGlhbGlhcyk7XFxufVwiO1xuICAgIE1hcmtlckdMR2x5cGgucHJvdG90eXBlLkZSQUcgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmNvbnN0IGZsb2F0IFNRUlRfMiA9IDEuNDE0MjEzNTYyMzczMDk1MTtcXG5jb25zdCBmbG9hdCBQSSA9IDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQ7XFxuLy9cXG51bmlmb3JtIGZsb2F0IHVfYW50aWFsaWFzO1xcbi8vXFxudmFyeWluZyB2ZWM0ICB2X2ZnX2NvbG9yO1xcbnZhcnlpbmcgdmVjNCAgdl9iZ19jb2xvcjtcXG52YXJ5aW5nIGZsb2F0IHZfbGluZXdpZHRoO1xcbnZhcnlpbmcgZmxvYXQgdl9zaXplO1xcbnZhcnlpbmcgdmVjMiAgdl9yb3RhdGlvbjtcXG5cXG5NQVJLRVJDT0RFXFxuXFxudmVjNCBvdXRsaW5lKGZsb2F0IGRpc3RhbmNlLCBmbG9hdCBsaW5ld2lkdGgsIGZsb2F0IGFudGlhbGlhcywgdmVjNCBmZ19jb2xvciwgdmVjNCBiZ19jb2xvcilcXG57XFxuICAgIHZlYzQgZnJhZ19jb2xvcjtcXG4gICAgZmxvYXQgdCA9IGxpbmV3aWR0aC8yLjAgLSBhbnRpYWxpYXM7XFxuICAgIGZsb2F0IHNpZ25lZF9kaXN0YW5jZSA9IGRpc3RhbmNlO1xcbiAgICBmbG9hdCBib3JkZXJfZGlzdGFuY2UgPSBhYnMoc2lnbmVkX2Rpc3RhbmNlKSAtIHQ7XFxuICAgIGZsb2F0IGFscGhhID0gYm9yZGVyX2Rpc3RhbmNlL2FudGlhbGlhcztcXG4gICAgYWxwaGEgPSBleHAoLWFscGhhKmFscGhhKTtcXG5cXG4gICAgLy8gSWYgZmcgYWxwaGEgaXMgemVybywgaXQgcHJvYmFibHkgbWVhbnMgbm8gb3V0bGluZS4gVG8gYXZvaWQgYSBkYXJrIG91dGxpbmVcXG4gICAgLy8gc2hpbmluZyB0aHJvdWdoIGR1ZSB0byBhYSwgd2Ugc2V0IHRoZSBmZyBjb2xvciB0byB0aGUgYmcgY29sb3IuIEF2b2lkIGlmIChpLmUuIGJyYW5jaGluZykuXFxuICAgIGZsb2F0IHNlbGVjdCA9IGZsb2F0KGJvb2woZmdfY29sb3IuYSkpO1xcbiAgICBmZ19jb2xvci5yZ2IgPSBzZWxlY3QgKiBmZ19jb2xvci5yZ2IgKyAoMS4wICAtIHNlbGVjdCkgKiBiZ19jb2xvci5yZ2I7XFxuICAgIC8vIFNpbWlsYXJseSwgaWYgd2Ugd2FudCBhIHRyYW5zcGFyZW50IGJnXFxuICAgIHNlbGVjdCA9IGZsb2F0KGJvb2woYmdfY29sb3IuYSkpO1xcbiAgICBiZ19jb2xvci5yZ2IgPSBzZWxlY3QgKiBiZ19jb2xvci5yZ2IgKyAoMS4wICAtIHNlbGVjdCkgKiBmZ19jb2xvci5yZ2I7XFxuXFxuICAgIGlmKCBib3JkZXJfZGlzdGFuY2UgPCAwLjApXFxuICAgICAgICBmcmFnX2NvbG9yID0gZmdfY29sb3I7XFxuICAgIGVsc2UgaWYoIHNpZ25lZF9kaXN0YW5jZSA8IDAuMCApIHtcXG4gICAgICAgIGZyYWdfY29sb3IgPSBtaXgoYmdfY29sb3IsIGZnX2NvbG9yLCBzcXJ0KGFscGhhKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiggYWJzKHNpZ25lZF9kaXN0YW5jZSkgPCAobGluZXdpZHRoLzIuMCArIGFudGlhbGlhcykgKSB7XFxuICAgICAgICAgICAgZnJhZ19jb2xvciA9IHZlYzQoZmdfY29sb3IucmdiLCBmZ19jb2xvci5hICogYWxwaGEpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBmcmFnX2NvbG9yO1xcbn1cXG5cXG52b2lkIG1haW4oKVxcbntcXG4gICAgdmVjMiBQID0gZ2xfUG9pbnRDb29yZC54eSAtIHZlYzIoMC41LCAwLjUpO1xcbiAgICBQID0gdmVjMih2X3JvdGF0aW9uLngqUC54IC0gdl9yb3RhdGlvbi55KlAueSxcXG4gICAgICAgICAgICAgdl9yb3RhdGlvbi55KlAueCArIHZfcm90YXRpb24ueCpQLnkpO1xcbiAgICBmbG9hdCBwb2ludF9zaXplID0gU1FSVF8yKnZfc2l6ZSAgKyAyLjAgKiAodl9saW5ld2lkdGggKyAxLjUqdV9hbnRpYWxpYXMpO1xcbiAgICBmbG9hdCBkaXN0YW5jZSA9IG1hcmtlcihQKnBvaW50X3NpemUsIHZfc2l6ZSk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IG91dGxpbmUoZGlzdGFuY2UsIHZfbGluZXdpZHRoLCB1X2FudGlhbGlhcywgdl9mZ19jb2xvciwgdl9iZ19jb2xvcik7XFxuICAgIC8vZ2xfRnJhZ0NvbG9yLnJnYiAqPSBnbF9GcmFnQ29sb3IuYTsgIC8vIHByZS1tdWx0aXBseSBhbHBoYVxcbn1cIjtcbiAgICBNYXJrZXJHTEdseXBoLnByb3RvdHlwZS5NQVJLRVJDT0RFID0gXCI8ZGVmaW5lZCBpbiBzdWJjbGFzc2VzPlwiO1xuICAgIE1hcmtlckdMR2x5cGgucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmcmFnLCBnbDtcbiAgICAgICAgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBmcmFnID0gdGhpcy5GUkFHLnJlcGxhY2UoL01BUktFUkNPREUvLCB0aGlzLk1BUktFUkNPREUpO1xuICAgICAgICB0aGlzLmxhc3RfdHJhbnMgPSB7fTtcbiAgICAgICAgdGhpcy5wcm9nID0gbmV3IGdsb28yLlByb2dyYW0oZ2wpO1xuICAgICAgICB0aGlzLnByb2cuc2V0X3NoYWRlcnModGhpcy5WRVJULCBmcmFnKTtcbiAgICAgICAgdGhpcy52Ym9feCA9IG5ldyBnbG9vMi5WZXJ0ZXhCdWZmZXIoZ2wpO1xuICAgICAgICB0aGlzLnByb2cuc2V0X2F0dHJpYnV0ZSgnYV94JywgJ2Zsb2F0JywgdGhpcy52Ym9feCk7XG4gICAgICAgIHRoaXMudmJvX3kgPSBuZXcgZ2xvbzIuVmVydGV4QnVmZmVyKGdsKTtcbiAgICAgICAgdGhpcy5wcm9nLnNldF9hdHRyaWJ1dGUoJ2FfeScsICdmbG9hdCcsIHRoaXMudmJvX3kpO1xuICAgICAgICB0aGlzLnZib19zID0gbmV3IGdsb28yLlZlcnRleEJ1ZmZlcihnbCk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfYXR0cmlidXRlKCdhX3NpemUnLCAnZmxvYXQnLCB0aGlzLnZib19zKTtcbiAgICAgICAgdGhpcy52Ym9fYSA9IG5ldyBnbG9vMi5WZXJ0ZXhCdWZmZXIoZ2wpO1xuICAgICAgICB0aGlzLnByb2cuc2V0X2F0dHJpYnV0ZSgnYV9hbmdsZScsICdmbG9hdCcsIHRoaXMudmJvX2EpO1xuICAgICAgICB0aGlzLnZib19saW5ld2lkdGggPSBuZXcgZ2xvbzIuVmVydGV4QnVmZmVyKGdsKTtcbiAgICAgICAgdGhpcy52Ym9fZmdfY29sb3IgPSBuZXcgZ2xvbzIuVmVydGV4QnVmZmVyKGdsKTtcbiAgICAgICAgdGhpcy52Ym9fYmdfY29sb3IgPSBuZXcgZ2xvbzIuVmVydGV4QnVmZmVyKGdsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfYnVmZmVyID0gbmV3IGdsb28yLkluZGV4QnVmZmVyKGdsKTtcbiAgICB9O1xuICAgIE1hcmtlckdMR2x5cGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoaW5kaWNlcywgbWFpbkdseXBoLCB0cmFucykge1xuICAgICAgICB2YXIgYmFrZWRfb2Zmc2V0LCBjaHVuaywgY2h1bmtzLCBjaHVua3NpemUsIGksIGosIGssIGwsIG1haW5HbEdseXBoLCBudmVydGljZXMsIG9mZnNldCwgcmVmLCByZWYxLCByZWYyLCByZXN1bHRzLCBzLCB0aGVzZV9pbmRpY2VzLCB1YSwgdWludDE2X2luZGV4O1xuICAgICAgICBtYWluR2xHbHlwaCA9IG1haW5HbHlwaC5nbGdseXBoO1xuICAgICAgICBudmVydGljZXMgPSBtYWluR2xHbHlwaC5udmVydGljZXM7XG4gICAgICAgIGlmIChtYWluR2xHbHlwaC5kYXRhX2NoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmICghKGlzRmluaXRlKHRyYW5zLmR4KSAmJiBpc0Zpbml0ZSh0cmFucy5keSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFpbkdsR2x5cGguX2Jha2VkX29mZnNldCA9IFt0cmFucy5keCwgdHJhbnMuZHldO1xuICAgICAgICAgICAgbWFpbkdsR2x5cGguX3NldF9kYXRhKG52ZXJ0aWNlcyk7XG4gICAgICAgICAgICBtYWluR2xHbHlwaC5kYXRhX2NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodGhpcy5nbHlwaC5fcmFkaXVzICE9IG51bGwpICYmICh0cmFucy5zeCAhPT0gdGhpcy5sYXN0X3RyYW5zLnN4IHx8IHRyYW5zLnN5ICE9PSB0aGlzLmxhc3RfdHJhbnMuc3kpKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RfdHJhbnMgPSB0cmFucztcbiAgICAgICAgICAgIHRoaXMudmJvX3Muc2V0X2RhdGEoMCwgbmV3IEZsb2F0MzJBcnJheSgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBqLCBsZW4sIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZWYgPSB0aGlzLmdseXBoLnNyYWRpdXM7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBzID0gcmVmW2pdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocyAqIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pLmNhbGwodGhpcykpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aXN1YWxzX2NoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldF92aXN1YWxzKG52ZXJ0aWNlcyk7XG4gICAgICAgICAgICB0aGlzLnZpc3VhbHNfY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJha2VkX29mZnNldCA9IG1haW5HbEdseXBoLl9iYWtlZF9vZmZzZXQ7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9waXhlbF9yYXRpbycsICdmbG9hdCcsIFt0cmFucy5waXhlbF9yYXRpb10pO1xuICAgICAgICB0aGlzLnByb2cuc2V0X3VuaWZvcm0oJ3VfY2FudmFzX3NpemUnLCAndmVjMicsIFt0cmFucy53aWR0aCwgdHJhbnMuaGVpZ2h0XSk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9vZmZzZXQnLCAndmVjMicsIFt0cmFucy5keCAtIGJha2VkX29mZnNldFswXSwgdHJhbnMuZHkgLSBiYWtlZF9vZmZzZXRbMV1dKTtcbiAgICAgICAgdGhpcy5wcm9nLnNldF91bmlmb3JtKCd1X3NjYWxlJywgJ3ZlYzInLCBbdHJhbnMuc3gsIHRyYW5zLnN5XSk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfYXR0cmlidXRlKCdhX3gnLCAnZmxvYXQnLCBtYWluR2xHbHlwaC52Ym9feCk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfYXR0cmlidXRlKCdhX3knLCAnZmxvYXQnLCBtYWluR2xHbHlwaC52Ym9feSk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfYXR0cmlidXRlKCdhX3NpemUnLCAnZmxvYXQnLCBtYWluR2xHbHlwaC52Ym9fcyk7XG4gICAgICAgIHRoaXMucHJvZy5zZXRfYXR0cmlidXRlKCdhX2FuZ2xlJywgJ2Zsb2F0JywgbWFpbkdsR2x5cGgudmJvX2EpO1xuICAgICAgICBpZiAoaW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRpY2VzLmxlbmd0aCA9PT0gbnZlcnRpY2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9nLmRyYXcodGhpcy5nbC5QT0lOVFMsIFswLCBudmVydGljZXNdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudmVydGljZXMgPCA2NTUzNSkge1xuICAgICAgICAgICAgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgICAgICAgIGlmICh1YS5pbmRleE9mKFwiTVNJRSBcIikgKyB1YS5pbmRleE9mKFwiVHJpZGVudC9cIikgKyB1YS5pbmRleE9mKFwiRWRnZS9cIikgPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZ2dlci53YXJuKCdXZWJHTCB3YXJuaW5nOiBJRSBpcyBrbm93biB0byBwcm9kdWNlIDFweCBzcHJpdGVzIHdoaXRoIHNlbGVjdGlvbnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluZGV4X2J1ZmZlci5zZXRfc2l6ZShpbmRpY2VzLmxlbmd0aCAqIDIpO1xuICAgICAgICAgICAgdGhpcy5pbmRleF9idWZmZXIuc2V0X2RhdGEoMCwgbmV3IFVpbnQxNkFycmF5KGluZGljZXMpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2cuZHJhdyh0aGlzLmdsLlBPSU5UUywgdGhpcy5pbmRleF9idWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2h1bmtzaXplID0gNjQwMDA7XG4gICAgICAgICAgICBjaHVua3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBNYXRoLmNlaWwobnZlcnRpY2VzIC8gY2h1bmtzaXplKTsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZjEgPSBpbmRpY2VzLmxlbmd0aDsgMCA8PSByZWYxID8gayA8IHJlZjEgOiBrID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsrayA6IC0taykge1xuICAgICAgICAgICAgICAgIHVpbnQxNl9pbmRleCA9IGluZGljZXNbaV0gJSBjaHVua3NpemU7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBNYXRoLmZsb29yKGluZGljZXNbaV0gLyBjaHVua3NpemUpO1xuICAgICAgICAgICAgICAgIGNodW5rc1tjaHVua10ucHVzaCh1aW50MTZfaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjaHVuayA9IGwgPSAwLCByZWYyID0gY2h1bmtzLmxlbmd0aDsgMCA8PSByZWYyID8gbCA8IHJlZjIgOiBsID4gcmVmMjsgY2h1bmsgPSAwIDw9IHJlZjIgPyArK2wgOiAtLWwpIHtcbiAgICAgICAgICAgICAgICB0aGVzZV9pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KGNodW5rc1tjaHVua10pO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGNodW5rICogY2h1bmtzaXplICogNDtcbiAgICAgICAgICAgICAgICBpZiAodGhlc2VfaW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucHJvZy5zZXRfYXR0cmlidXRlKCdhX3gnLCAnZmxvYXQnLCBtYWluR2xHbHlwaC52Ym9feCwgMCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2cuc2V0X2F0dHJpYnV0ZSgnYV95JywgJ2Zsb2F0JywgbWFpbkdsR2x5cGgudmJvX3ksIDAsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9nLnNldF9hdHRyaWJ1dGUoJ2Ffc2l6ZScsICdmbG9hdCcsIG1haW5HbEdseXBoLnZib19zLCAwLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvZy5zZXRfYXR0cmlidXRlKCdhX2FuZ2xlJywgJ2Zsb2F0JywgbWFpbkdsR2x5cGgudmJvX2EsIDAsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmJvX2xpbmV3aWR0aC51c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvZy5zZXRfYXR0cmlidXRlKCdhX2xpbmV3aWR0aCcsICdmbG9hdCcsIHRoaXMudmJvX2xpbmV3aWR0aCwgMCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmJvX2ZnX2NvbG9yLnVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9nLnNldF9hdHRyaWJ1dGUoJ2FfZmdfY29sb3InLCAndmVjNCcsIHRoaXMudmJvX2ZnX2NvbG9yLCAwLCBvZmZzZXQgKiA0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmJvX2JnX2NvbG9yLnVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9nLnNldF9hdHRyaWJ1dGUoJ2FfYmdfY29sb3InLCAndmVjNCcsIHRoaXMudmJvX2JnX2NvbG9yLCAwLCBvZmZzZXQgKiA0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleF9idWZmZXIuc2V0X3NpemUodGhlc2VfaW5kaWNlcy5sZW5ndGggKiAyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4X2J1ZmZlci5zZXRfZGF0YSgwLCB0aGVzZV9pbmRpY2VzKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5wcm9nLmRyYXcodGhpcy5nbC5QT0lOVFMsIHRoaXMuaW5kZXhfYnVmZmVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWFya2VyR0xHbHlwaC5wcm90b3R5cGUuX3NldF9kYXRhID0gZnVuY3Rpb24gKG52ZXJ0aWNlcykge1xuICAgICAgICB2YXIgaSwgaiwgbiwgcmVmLCBzLCB4eCwgeXk7XG4gICAgICAgIG4gPSBudmVydGljZXMgKiA0O1xuICAgICAgICB0aGlzLnZib194LnNldF9zaXplKG4pO1xuICAgICAgICB0aGlzLnZib195LnNldF9zaXplKG4pO1xuICAgICAgICB0aGlzLnZib19hLnNldF9zaXplKG4pO1xuICAgICAgICB0aGlzLnZib19zLnNldF9zaXplKG4pO1xuICAgICAgICB4eCA9IG5ldyBGbG9hdDY0QXJyYXkodGhpcy5nbHlwaC5feCk7XG4gICAgICAgIHl5ID0gbmV3IEZsb2F0NjRBcnJheSh0aGlzLmdseXBoLl95KTtcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IG52ZXJ0aWNlczsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG4gICAgICAgICAgICB4eFtpXSArPSB0aGlzLl9iYWtlZF9vZmZzZXRbMF07XG4gICAgICAgICAgICB5eVtpXSArPSB0aGlzLl9iYWtlZF9vZmZzZXRbMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52Ym9feC5zZXRfZGF0YSgwLCBuZXcgRmxvYXQzMkFycmF5KHh4KSk7XG4gICAgICAgIHRoaXMudmJvX3kuc2V0X2RhdGEoMCwgbmV3IEZsb2F0MzJBcnJheSh5eSkpO1xuICAgICAgICBpZiAodGhpcy5nbHlwaC5fYW5nbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy52Ym9fYS5zZXRfZGF0YSgwLCBuZXcgRmxvYXQzMkFycmF5KHRoaXMuZ2x5cGguX2FuZ2xlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2x5cGguX3JhZGl1cyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52Ym9fcy5zZXRfZGF0YSgwLCBuZXcgRmxvYXQzMkFycmF5KChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGssIGxlbiwgcmVmMSwgcmVzdWx0cztcbiAgICAgICAgICAgICAgICByZWYxID0gdGhpcy5nbHlwaC5zcmFkaXVzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSByZWYxW2tdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocyAqIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pLmNhbGwodGhpcykpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZib19zLnNldF9kYXRhKDAsIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5nbHlwaC5fc2l6ZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXJrZXJHTEdseXBoLnByb3RvdHlwZS5fc2V0X3Zpc3VhbHMgPSBmdW5jdGlvbiAobnZlcnRpY2VzKSB7XG4gICAgICAgIGJhc2VfMS5hdHRhY2hfZmxvYXQodGhpcy5wcm9nLCB0aGlzLnZib19saW5ld2lkdGgsICdhX2xpbmV3aWR0aCcsIG52ZXJ0aWNlcywgdGhpcy5nbHlwaC52aXN1YWxzLmxpbmUsICdsaW5lX3dpZHRoJyk7XG4gICAgICAgIGJhc2VfMS5hdHRhY2hfY29sb3IodGhpcy5wcm9nLCB0aGlzLnZib19mZ19jb2xvciwgJ2FfZmdfY29sb3InLCBudmVydGljZXMsIHRoaXMuZ2x5cGgudmlzdWFscy5saW5lLCAnbGluZScpO1xuICAgICAgICBiYXNlXzEuYXR0YWNoX2NvbG9yKHRoaXMucHJvZywgdGhpcy52Ym9fYmdfY29sb3IsICdhX2JnX2NvbG9yJywgbnZlcnRpY2VzLCB0aGlzLmdseXBoLnZpc3VhbHMuZmlsbCwgJ2ZpbGwnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvZy5zZXRfdW5pZm9ybSgndV9hbnRpYWxpYXMnLCAnZmxvYXQnLCBbMC44XSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFya2VyR0xHbHlwaDtcbn0pKGJhc2VfMS5CYXNlR0xHbHlwaCk7XG5leHBvcnRzLkNpcmNsZUdMR2x5cGggPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoQ2lyY2xlR0xHbHlwaCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gQ2lyY2xlR0xHbHlwaCgpIHtcbiAgICAgICAgcmV0dXJuIENpcmNsZUdMR2x5cGguX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIENpcmNsZUdMR2x5cGgucHJvdG90eXBlLkdMWVBIID0gJ2NpcmNsZSc7XG4gICAgQ2lyY2xlR0xHbHlwaC5wcm90b3R5cGUuTUFSS0VSQ09ERSA9IFwiLy8gLS0tIGRpc2NcXG5mbG9hdCBtYXJrZXIodmVjMiBQLCBmbG9hdCBzaXplKVxcbntcXG4gICAgcmV0dXJuIGxlbmd0aChQKSAtIHNpemUvMi4wO1xcbn1cIjtcbiAgICByZXR1cm4gQ2lyY2xlR0xHbHlwaDtcbn0pKE1hcmtlckdMR2x5cGgpO1xuZXhwb3J0cy5TcXVhcmVHTEdseXBoID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFNxdWFyZUdMR2x5cGgsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIFNxdWFyZUdMR2x5cGgoKSB7XG4gICAgICAgIHJldHVybiBTcXVhcmVHTEdseXBoLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTcXVhcmVHTEdseXBoLnByb3RvdHlwZS5HTFlQSCA9ICdzcXVhcmUnO1xuICAgIFNxdWFyZUdMR2x5cGgucHJvdG90eXBlLk1BUktFUkNPREUgPSBcIi8vIC0tLSBzcXVhcmVcXG5mbG9hdCBtYXJrZXIodmVjMiBQLCBmbG9hdCBzaXplKVxcbntcXG4gICAgcmV0dXJuIG1heChhYnMoUC54KSwgYWJzKFAueSkpIC0gc2l6ZS8yLjA7XFxufVwiO1xuICAgIHJldHVybiBTcXVhcmVHTEdseXBoO1xufSkoTWFya2VyR0xHbHlwaCk7XG5leHBvcnRzLkFubnVsdXNHTEdseXBoID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKEFubnVsdXNHTEdseXBoLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBBbm51bHVzR0xHbHlwaCgpIHtcbiAgICAgICAgcmV0dXJuIEFubnVsdXNHTEdseXBoLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBBbm51bHVzR0xHbHlwaC5wcm90b3R5cGUuR0xZUEggPSAnYW5udWx1cyc7XG4gICAgQW5udWx1c0dMR2x5cGgucHJvdG90eXBlLk1BUktFUkNPREUgPSBcImZsb2F0IG1hcmtlcih2ZWMyIFAsIGZsb2F0IHNpemUpXFxue1xcbiAgICBmbG9hdCByMSA9IGxlbmd0aChQKSAtIHNpemUvMi4wO1xcbiAgICBmbG9hdCByMiA9IGxlbmd0aChQKSAtIHNpemUvNC4wOyAgLy8gaGFsZiB3aWR0aFxcbiAgICByZXR1cm4gbWF4KHIxLCAtcjIpO1xcbn1cIjtcbiAgICByZXR1cm4gQW5udWx1c0dMR2x5cGg7XG59KShNYXJrZXJHTEdseXBoKTtcbmV4cG9ydHMuRGlhbW9uZEdMR2x5cGggPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRGlhbW9uZEdMR2x5cGgsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERpYW1vbmRHTEdseXBoKCkge1xuICAgICAgICByZXR1cm4gRGlhbW9uZEdMR2x5cGguX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERpYW1vbmRHTEdseXBoLnByb3RvdHlwZS5HTFlQSCA9ICdkaWFtb25kJztcbiAgICBEaWFtb25kR0xHbHlwaC5wcm90b3R5cGUuTUFSS0VSQ09ERSA9IFwiLy8gLS0tIGRpYW1vbmRcXG5mbG9hdCBtYXJrZXIodmVjMiBQLCBmbG9hdCBzaXplKVxcbntcXG4gICAgZmxvYXQgeCA9IFNRUlRfMiAvIDIuMCAqIChQLnggKiAxLjUgLSBQLnkpO1xcbiAgICBmbG9hdCB5ID0gU1FSVF8yIC8gMi4wICogKFAueCAqIDEuNSArIFAueSk7XFxuICAgIGZsb2F0IHIxID0gbWF4KGFicyh4KSwgYWJzKHkpKSAtIHNpemUgLyAoMi4wICogU1FSVF8yKTtcXG4gICAgcmV0dXJuIHIxIC8gU1FSVF8yO1xcbn1cIjtcbiAgICByZXR1cm4gRGlhbW9uZEdMR2x5cGg7XG59KShNYXJrZXJHTEdseXBoKTtcbmV4cG9ydHMuVHJpYW5nbGVHTEdseXBoID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFRyaWFuZ2xlR0xHbHlwaCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gVHJpYW5nbGVHTEdseXBoKCkge1xuICAgICAgICByZXR1cm4gVHJpYW5nbGVHTEdseXBoLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBUcmlhbmdsZUdMR2x5cGgucHJvdG90eXBlLkdMWVBIID0gJ3RyaWFuZ2xlJztcbiAgICBUcmlhbmdsZUdMR2x5cGgucHJvdG90eXBlLk1BUktFUkNPREUgPSBcImZsb2F0IG1hcmtlcih2ZWMyIFAsIGZsb2F0IHNpemUpXFxue1xcbiAgICBQLnkgLT0gc2l6ZSAqIDAuMztcXG4gICAgZmxvYXQgeCA9IFNRUlRfMiAvIDIuMCAqIChQLnggKiAxLjcgLSBQLnkpO1xcbiAgICBmbG9hdCB5ID0gU1FSVF8yIC8gMi4wICogKFAueCAqIDEuNyArIFAueSk7XFxuICAgIGZsb2F0IHIxID0gbWF4KGFicyh4KSwgYWJzKHkpKSAtIHNpemUgLyAxLjY7XFxuICAgIGZsb2F0IHIyID0gUC55O1xcbiAgICByZXR1cm4gbWF4KHIxIC8gU1FSVF8yLCByMik7ICAvLyBJbnN0ZXJzZWN0IGRpYW1vbmQgd2l0aCByZWN0YW5nbGVcXG59XCI7XG4gICAgcmV0dXJuIFRyaWFuZ2xlR0xHbHlwaDtcbn0pKE1hcmtlckdMR2x5cGgpO1xuZXhwb3J0cy5JbnZlcnRlZFRyaWFuZ2xlR0xHbHlwaCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChJbnZlcnRlZFRyaWFuZ2xlR0xHbHlwaCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gSW52ZXJ0ZWRUcmlhbmdsZUdMR2x5cGgoKSB7XG4gICAgICAgIHJldHVybiBJbnZlcnRlZFRyaWFuZ2xlR0xHbHlwaC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgSW52ZXJ0ZWRUcmlhbmdsZUdMR2x5cGgucHJvdG90eXBlLkdMWVBIID0gJ2ludmVydGVkdHJpYW5nbGUnO1xuICAgIEludmVydGVkVHJpYW5nbGVHTEdseXBoLnByb3RvdHlwZS5NQVJLRVJDT0RFID0gXCJmbG9hdCBtYXJrZXIodmVjMiBQLCBmbG9hdCBzaXplKVxcbntcXG4gICAgUC55ICs9IHNpemUgKiAwLjM7XFxuICAgIGZsb2F0IHggPSBTUVJUXzIgLyAyLjAgKiAoUC54ICogMS43IC0gUC55KTtcXG4gICAgZmxvYXQgeSA9IFNRUlRfMiAvIDIuMCAqIChQLnggKiAxLjcgKyBQLnkpO1xcbiAgICBmbG9hdCByMSA9IG1heChhYnMoeCksIGFicyh5KSkgLSBzaXplIC8gMS42O1xcbiAgICBmbG9hdCByMiA9IC0gUC55O1xcbiAgICByZXR1cm4gbWF4KHIxIC8gU1FSVF8yLCByMik7ICAvLyBJbnN0ZXJzZWN0IGRpYW1vbmQgd2l0aCByZWN0YW5nbGVcXG59XCI7XG4gICAgcmV0dXJuIEludmVydGVkVHJpYW5nbGVHTEdseXBoO1xufSkoTWFya2VyR0xHbHlwaCk7XG5leHBvcnRzLkNyb3NzR0xHbHlwaCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDcm9zc0dMR2x5cGgsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENyb3NzR0xHbHlwaCgpIHtcbiAgICAgICAgcmV0dXJuIENyb3NzR0xHbHlwaC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ3Jvc3NHTEdseXBoLnByb3RvdHlwZS5HTFlQSCA9ICdjcm9zcyc7XG4gICAgQ3Jvc3NHTEdseXBoLnByb3RvdHlwZS5NQVJLRVJDT0RFID0gXCJmbG9hdCBtYXJrZXIodmVjMiBQLCBmbG9hdCBzaXplKVxcbntcXG4gICAgZmxvYXQgc3F1YXJlID0gbWF4KGFicyhQLngpLCBhYnMoUC55KSkgLSBzaXplIC8gMi41OyAgLy8gMi41IGlzIGEgdHdlYWtcXG4gICAgZmxvYXQgY3Jvc3MgPSBtaW4oYWJzKFAueCksIGFicyhQLnkpKSAtIHNpemUgLyAxMDAuMDsgIC8vIGJpdCBvZiBcXFwid2lkdGhcXFwiIGZvciBhYVxcbiAgICByZXR1cm4gbWF4KHNxdWFyZSwgY3Jvc3MpO1xcbn1cIjtcbiAgICByZXR1cm4gQ3Jvc3NHTEdseXBoO1xufSkoTWFya2VyR0xHbHlwaCk7XG5leHBvcnRzLkNpcmNsZUNyb3NzR0xHbHlwaCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDaXJjbGVDcm9zc0dMR2x5cGgsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIENpcmNsZUNyb3NzR0xHbHlwaCgpIHtcbiAgICAgICAgcmV0dXJuIENpcmNsZUNyb3NzR0xHbHlwaC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQ2lyY2xlQ3Jvc3NHTEdseXBoLnByb3RvdHlwZS5HTFlQSCA9ICdjaXJjbGVjcm9zcyc7XG4gICAgQ2lyY2xlQ3Jvc3NHTEdseXBoLnByb3RvdHlwZS5NQVJLRVJDT0RFID0gXCJmbG9hdCBtYXJrZXIodmVjMiBQLCBmbG9hdCBzaXplKVxcbntcXG4gICAgLy8gRGVmaW5lIHF1YWRyYW50c1xcbiAgICBmbG9hdCBxcyA9IHNpemUgLyAyLjA7ICAvLyBxdWFkcmFudCBzaXplXFxuICAgIGZsb2F0IHMxID0gbWF4KGFicyhQLnggLSBxcyksIGFicyhQLnkgLSBxcykpIC0gcXM7XFxuICAgIGZsb2F0IHMyID0gbWF4KGFicyhQLnggKyBxcyksIGFicyhQLnkgLSBxcykpIC0gcXM7XFxuICAgIGZsb2F0IHMzID0gbWF4KGFicyhQLnggLSBxcyksIGFicyhQLnkgKyBxcykpIC0gcXM7XFxuICAgIGZsb2F0IHM0ID0gbWF4KGFicyhQLnggKyBxcyksIGFicyhQLnkgKyBxcykpIC0gcXM7XFxuICAgIC8vIEludGVyc2VjdCBtYWluIHNoYXBlIHdpdGggcXVhZHJhbnRzICh0byBmb3JtIGNyb3NzKVxcbiAgICBmbG9hdCBjaXJjbGUgPSBsZW5ndGgoUCkgLSBzaXplLzIuMDtcXG4gICAgZmxvYXQgYzEgPSBtYXgoY2lyY2xlLCBzMSk7XFxuICAgIGZsb2F0IGMyID0gbWF4KGNpcmNsZSwgczIpO1xcbiAgICBmbG9hdCBjMyA9IG1heChjaXJjbGUsIHMzKTtcXG4gICAgZmxvYXQgYzQgPSBtYXgoY2lyY2xlLCBzNCk7XFxuICAgIC8vIFVuaW9uXFxuICAgIHJldHVybiBtaW4obWluKG1pbihjMSwgYzIpLCBjMyksIGM0KTtcXG59XCI7XG4gICAgcmV0dXJuIENpcmNsZUNyb3NzR0xHbHlwaDtcbn0pKE1hcmtlckdMR2x5cGgpO1xuZXhwb3J0cy5TcXVhcmVDcm9zc0dMR2x5cGggPSAoZnVuY3Rpb24gKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU3F1YXJlQ3Jvc3NHTEdseXBoLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTcXVhcmVDcm9zc0dMR2x5cGgoKSB7XG4gICAgICAgIHJldHVybiBTcXVhcmVDcm9zc0dMR2x5cGguX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNxdWFyZUNyb3NzR0xHbHlwaC5wcm90b3R5cGUuR0xZUEggPSAnc3F1YXJlY3Jvc3MnO1xuICAgIFNxdWFyZUNyb3NzR0xHbHlwaC5wcm90b3R5cGUuTUFSS0VSQ09ERSA9IFwiZmxvYXQgbWFya2VyKHZlYzIgUCwgZmxvYXQgc2l6ZSlcXG57XFxuICAgIC8vIERlZmluZSBxdWFkcmFudHNcXG4gICAgZmxvYXQgcXMgPSBzaXplIC8gMi4wOyAgLy8gcXVhZHJhbnQgc2l6ZVxcbiAgICBmbG9hdCBzMSA9IG1heChhYnMoUC54IC0gcXMpLCBhYnMoUC55IC0gcXMpKSAtIHFzO1xcbiAgICBmbG9hdCBzMiA9IG1heChhYnMoUC54ICsgcXMpLCBhYnMoUC55IC0gcXMpKSAtIHFzO1xcbiAgICBmbG9hdCBzMyA9IG1heChhYnMoUC54IC0gcXMpLCBhYnMoUC55ICsgcXMpKSAtIHFzO1xcbiAgICBmbG9hdCBzNCA9IG1heChhYnMoUC54ICsgcXMpLCBhYnMoUC55ICsgcXMpKSAtIHFzO1xcbiAgICAvLyBJbnRlcnNlY3QgbWFpbiBzaGFwZSB3aXRoIHF1YWRyYW50cyAodG8gZm9ybSBjcm9zcylcXG4gICAgZmxvYXQgc3F1YXJlID0gbWF4KGFicyhQLngpLCBhYnMoUC55KSkgLSBzaXplLzIuMDtcXG4gICAgZmxvYXQgYzEgPSBtYXgoc3F1YXJlLCBzMSk7XFxuICAgIGZsb2F0IGMyID0gbWF4KHNxdWFyZSwgczIpO1xcbiAgICBmbG9hdCBjMyA9IG1heChzcXVhcmUsIHMzKTtcXG4gICAgZmxvYXQgYzQgPSBtYXgoc3F1YXJlLCBzNCk7XFxuICAgIC8vIFVuaW9uXFxuICAgIHJldHVybiBtaW4obWluKG1pbihjMSwgYzIpLCBjMyksIGM0KTtcXG59XCI7XG4gICAgcmV0dXJuIFNxdWFyZUNyb3NzR0xHbHlwaDtcbn0pKE1hcmtlckdMR2x5cGgpO1xuZXhwb3J0cy5EaWFtb25kQ3Jvc3NHTEdseXBoID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKERpYW1vbmRDcm9zc0dMR2x5cGgsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIERpYW1vbmRDcm9zc0dMR2x5cGgoKSB7XG4gICAgICAgIHJldHVybiBEaWFtb25kQ3Jvc3NHTEdseXBoLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEaWFtb25kQ3Jvc3NHTEdseXBoLnByb3RvdHlwZS5HTFlQSCA9ICdkaWFtb25kY3Jvc3MnO1xuICAgIERpYW1vbmRDcm9zc0dMR2x5cGgucHJvdG90eXBlLk1BUktFUkNPREUgPSBcImZsb2F0IG1hcmtlcih2ZWMyIFAsIGZsb2F0IHNpemUpXFxue1xcbiAgICAvLyBEZWZpbmUgcXVhZHJhbnRzXFxuICAgIGZsb2F0IHFzID0gc2l6ZSAvIDIuMDsgIC8vIHF1YWRyYW50IHNpemVcXG4gICAgZmxvYXQgczEgPSBtYXgoYWJzKFAueCAtIHFzKSwgYWJzKFAueSAtIHFzKSkgLSBxcztcXG4gICAgZmxvYXQgczIgPSBtYXgoYWJzKFAueCArIHFzKSwgYWJzKFAueSAtIHFzKSkgLSBxcztcXG4gICAgZmxvYXQgczMgPSBtYXgoYWJzKFAueCAtIHFzKSwgYWJzKFAueSArIHFzKSkgLSBxcztcXG4gICAgZmxvYXQgczQgPSBtYXgoYWJzKFAueCArIHFzKSwgYWJzKFAueSArIHFzKSkgLSBxcztcXG4gICAgLy8gSW50ZXJzZWN0IG1haW4gc2hhcGUgd2l0aCBxdWFkcmFudHMgKHRvIGZvcm0gY3Jvc3MpXFxuICAgIGZsb2F0IHggPSBTUVJUXzIgLyAyLjAgKiAoUC54ICogMS41IC0gUC55KTtcXG4gICAgZmxvYXQgeSA9IFNRUlRfMiAvIDIuMCAqIChQLnggKiAxLjUgKyBQLnkpO1xcbiAgICBmbG9hdCBkaWFtb25kID0gbWF4KGFicyh4KSwgYWJzKHkpKSAtIHNpemUgLyAoMi4wICogU1FSVF8yKTtcXG4gICAgZGlhbW9uZCAvPSBTUVJUXzI7XFxuICAgIGZsb2F0IGMxID0gbWF4KGRpYW1vbmQsIHMxKTtcXG4gICAgZmxvYXQgYzIgPSBtYXgoZGlhbW9uZCwgczIpO1xcbiAgICBmbG9hdCBjMyA9IG1heChkaWFtb25kLCBzMyk7XFxuICAgIGZsb2F0IGM0ID0gbWF4KGRpYW1vbmQsIHM0KTtcXG4gICAgLy8gVW5pb25cXG4gICAgcmV0dXJuIG1pbihtaW4obWluKGMxLCBjMiksIGMzKSwgYzQpO1xcbn1cIjtcbiAgICByZXR1cm4gRGlhbW9uZENyb3NzR0xHbHlwaDtcbn0pKE1hcmtlckdMR2x5cGgpO1xuZXhwb3J0cy5YR0xHbHlwaCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYR0xHbHlwaCwgc3VwZXJDbGFzcyk7XG4gICAgZnVuY3Rpb24gWEdMR2x5cGgoKSB7XG4gICAgICAgIHJldHVybiBYR0xHbHlwaC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgWEdMR2x5cGgucHJvdG90eXBlLkdMWVBIID0gJ3gnO1xuICAgIFhHTEdseXBoLnByb3RvdHlwZS5NQVJLRVJDT0RFID0gXCJmbG9hdCBtYXJrZXIodmVjMiBQLCBmbG9hdCBzaXplKVxcbntcXG4gICAgZmxvYXQgY2lyY2xlID0gbGVuZ3RoKFApIC0gc2l6ZSAvIDEuNjtcXG4gICAgZmxvYXQgWCA9IG1pbihhYnMoUC54IC0gUC55KSwgYWJzKFAueCArIFAueSkpIC0gc2l6ZSAvIDEwMC4wOyAgLy8gYml0IG9mIFxcXCJ3aWR0aFxcXCIgZm9yIGFhXFxuICAgIHJldHVybiBtYXgoY2lyY2xlLCBYKTtcXG59XCI7XG4gICAgcmV0dXJuIFhHTEdseXBoO1xufSkoTWFya2VyR0xHbHlwaCk7XG5leHBvcnRzLkNpcmNsZVhHTEdseXBoID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKENpcmNsZVhHTEdseXBoLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBDaXJjbGVYR0xHbHlwaCgpIHtcbiAgICAgICAgcmV0dXJuIENpcmNsZVhHTEdseXBoLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDaXJjbGVYR0xHbHlwaC5wcm90b3R5cGUuR0xZUEggPSAnY2lyY2xleCc7XG4gICAgQ2lyY2xlWEdMR2x5cGgucHJvdG90eXBlLk1BUktFUkNPREUgPSBcImZsb2F0IG1hcmtlcih2ZWMyIFAsIGZsb2F0IHNpemUpXFxue1xcbiAgICBmbG9hdCB4ID0gUC54IC0gUC55O1xcbiAgICBmbG9hdCB5ID0gUC54ICsgUC55O1xcbiAgICAvLyBEZWZpbmUgcXVhZHJhbnRzXFxuICAgIGZsb2F0IHFzID0gc2l6ZSAvIDIuMDsgIC8vIHF1YWRyYW50IHNpemVcXG4gICAgZmxvYXQgczEgPSBtYXgoYWJzKHggLSBxcyksIGFicyh5IC0gcXMpKSAtIHFzO1xcbiAgICBmbG9hdCBzMiA9IG1heChhYnMoeCArIHFzKSwgYWJzKHkgLSBxcykpIC0gcXM7XFxuICAgIGZsb2F0IHMzID0gbWF4KGFicyh4IC0gcXMpLCBhYnMoeSArIHFzKSkgLSBxcztcXG4gICAgZmxvYXQgczQgPSBtYXgoYWJzKHggKyBxcyksIGFicyh5ICsgcXMpKSAtIHFzO1xcbiAgICAvLyBJbnRlcnNlY3QgbWFpbiBzaGFwZSB3aXRoIHF1YWRyYW50cyAodG8gZm9ybSBjcm9zcylcXG4gICAgZmxvYXQgY2lyY2xlID0gbGVuZ3RoKFApIC0gc2l6ZS8yLjA7XFxuICAgIGZsb2F0IGMxID0gbWF4KGNpcmNsZSwgczEpO1xcbiAgICBmbG9hdCBjMiA9IG1heChjaXJjbGUsIHMyKTtcXG4gICAgZmxvYXQgYzMgPSBtYXgoY2lyY2xlLCBzMyk7XFxuICAgIGZsb2F0IGM0ID0gbWF4KGNpcmNsZSwgczQpO1xcbiAgICAvLyBVbmlvblxcbiAgICBmbG9hdCBhbG1vc3QgPSBtaW4obWluKG1pbihjMSwgYzIpLCBjMyksIGM0KTtcXG4gICAgLy8gSW4gdGhpcyBjYXNlLCB0aGUgWCBpcyBhbHNvIG91dHNpZGUgb2YgdGhlIG1haW4gc2hhcGVcXG4gICAgZmxvYXQgWG1hc2sgPSBsZW5ndGgoUCkgLSBzaXplIC8gMS42OyAgLy8gYSBjaXJjbGVcXG4gICAgZmxvYXQgWCA9IG1pbihhYnMoUC54IC0gUC55KSwgYWJzKFAueCArIFAueSkpIC0gc2l6ZSAvIDEwMC4wOyAgLy8gYml0IG9mIFxcXCJ3aWR0aFxcXCIgZm9yIGFhXFxuICAgIHJldHVybiBtaW4obWF4KFgsIFhtYXNrKSwgYWxtb3N0KTtcXG59XCI7XG4gICAgcmV0dXJuIENpcmNsZVhHTEdseXBoO1xufSkoTWFya2VyR0xHbHlwaCk7XG5leHBvcnRzLlNxdWFyZVhHTEdseXBoID0gKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFNxdWFyZVhHTEdseXBoLCBzdXBlckNsYXNzKTtcbiAgICBmdW5jdGlvbiBTcXVhcmVYR0xHbHlwaCgpIHtcbiAgICAgICAgcmV0dXJuIFNxdWFyZVhHTEdseXBoLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTcXVhcmVYR0xHbHlwaC5wcm90b3R5cGUuR0xZUEggPSAnc3F1YXJleCc7XG4gICAgU3F1YXJlWEdMR2x5cGgucHJvdG90eXBlLk1BUktFUkNPREUgPSBcImZsb2F0IG1hcmtlcih2ZWMyIFAsIGZsb2F0IHNpemUpXFxue1xcbiAgICBmbG9hdCB4ID0gUC54IC0gUC55O1xcbiAgICBmbG9hdCB5ID0gUC54ICsgUC55O1xcbiAgICAvLyBEZWZpbmUgcXVhZHJhbnRzXFxuICAgIGZsb2F0IHFzID0gc2l6ZSAvIDIuMDsgIC8vIHF1YWRyYW50IHNpemVcXG4gICAgZmxvYXQgczEgPSBtYXgoYWJzKHggLSBxcyksIGFicyh5IC0gcXMpKSAtIHFzO1xcbiAgICBmbG9hdCBzMiA9IG1heChhYnMoeCArIHFzKSwgYWJzKHkgLSBxcykpIC0gcXM7XFxuICAgIGZsb2F0IHMzID0gbWF4KGFicyh4IC0gcXMpLCBhYnMoeSArIHFzKSkgLSBxcztcXG4gICAgZmxvYXQgczQgPSBtYXgoYWJzKHggKyBxcyksIGFicyh5ICsgcXMpKSAtIHFzO1xcbiAgICAvLyBJbnRlcnNlY3QgbWFpbiBzaGFwZSB3aXRoIHF1YWRyYW50cyAodG8gZm9ybSBjcm9zcylcXG4gICAgZmxvYXQgc3F1YXJlID0gbWF4KGFicyhQLngpLCBhYnMoUC55KSkgLSBzaXplLzIuMDtcXG4gICAgZmxvYXQgYzEgPSBtYXgoc3F1YXJlLCBzMSk7XFxuICAgIGZsb2F0IGMyID0gbWF4KHNxdWFyZSwgczIpO1xcbiAgICBmbG9hdCBjMyA9IG1heChzcXVhcmUsIHMzKTtcXG4gICAgZmxvYXQgYzQgPSBtYXgoc3F1YXJlLCBzNCk7XFxuICAgIC8vIFVuaW9uXFxuICAgIHJldHVybiBtaW4obWluKG1pbihjMSwgYzIpLCBjMyksIGM0KTtcXG59XCI7XG4gICAgcmV0dXJuIFNxdWFyZVhHTEdseXBoO1xufSkoTWFya2VyR0xHbHlwaCk7XG5leHBvcnRzLkFzdGVyaXNrR0xHbHlwaCA9IChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChBc3Rlcmlza0dMR2x5cGgsIHN1cGVyQ2xhc3MpO1xuICAgIGZ1bmN0aW9uIEFzdGVyaXNrR0xHbHlwaCgpIHtcbiAgICAgICAgcmV0dXJuIEFzdGVyaXNrR0xHbHlwaC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQXN0ZXJpc2tHTEdseXBoLnByb3RvdHlwZS5HTFlQSCA9ICdhc3Rlcmlzayc7XG4gICAgQXN0ZXJpc2tHTEdseXBoLnByb3RvdHlwZS5NQVJLRVJDT0RFID0gXCJmbG9hdCBtYXJrZXIodmVjMiBQLCBmbG9hdCBzaXplKVxcbntcXG4gICAgLy8gTWFza3NcXG4gICAgZmxvYXQgZGlhbW9uZCA9IG1heChhYnMoU1FSVF8yIC8gMi4wICogKFAueCAtIFAueSkpLCBhYnMoU1FSVF8yIC8gMi4wICogKFAueCArIFAueSkpKSAtIHNpemUgLyAoMi4wICogU1FSVF8yKTtcXG4gICAgZmxvYXQgc3F1YXJlID0gbWF4KGFicyhQLngpLCBhYnMoUC55KSkgLSBzaXplIC8gKDIuMCAqIFNRUlRfMik7XFxuICAgIC8vIFNoYXBlc1xcbiAgICBmbG9hdCBYID0gbWluKGFicyhQLnggLSBQLnkpLCBhYnMoUC54ICsgUC55KSkgLSBzaXplIC8gMTAwLjA7ICAvLyBiaXQgb2YgXFxcIndpZHRoXFxcIiBmb3IgYWFcXG4gICAgZmxvYXQgY3Jvc3MgPSBtaW4oYWJzKFAueCksIGFicyhQLnkpKSAtIHNpemUgLyAxMDAuMDsgIC8vIGJpdCBvZiBcXFwid2lkdGhcXFwiIGZvciBhYVxcbiAgICAvLyBSZXN1bHQgaXMgdW5pb24gb2YgbWFza2VkIHNoYXBlc1xcbiAgICByZXR1cm4gbWluKG1heChYLCBkaWFtb25kKSwgbWF4KGNyb3NzLCBzcXVhcmUpKTtcXG59XCI7XG4gICAgcmV0dXJuIEFzdGVyaXNrR0xHbHlwaDtcbn0pKE1hcmtlckdMR2x5cGgpO1xuIiwiLyogRG8gbm90IGVkaXQsIGF1dG9nZW5lcmF0ZWQgYnkgZmxleHgucHlzY3JpcHQgKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gTm9kZSBvciBDb21tb25KU1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByb290Lmdsb28yID0gbW9kdWxlLmV4cG9ydHM7ICAvLyBhbHNvIGNyZWF0ZSBnbG9iYWwgbW9kdWxlIGluIE5vZGVcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgICAgIHJvb3QuZ2xvbzIgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9weWZ1bmNfYWRkID0gZnVuY3Rpb24gKGEsIGIpIHsgLy8gbmFyZ3M6IDJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgICB9IHJldHVybiBhICsgYjtcbiAgICB9O1xuICAgIHZhciBfcHlmdW5jX2FsbCA9IGZ1bmN0aW9uICh4KSB7IC8vIG5hcmdzOiAxXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTx4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIV9weWZ1bmNfdHJ1dGh5KHhbaV0pKXtyZXR1cm4gZmFsc2U7fVxuICAgICAgICB9IHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgdmFyIF9weWZ1bmNfY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyAoYSwgYikgeyAvLyBuYXJnczogMlxuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGIubGVuZ3RoOyBpKyspIHtpZiAoX3B5ZnVuY19lcXVhbHMoYSwgYltpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO31cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChiLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYikge2lmIChhID09IGspIHJldHVybiB0cnVlO31cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChiLmNvbnN0cnVjdG9yID09IFN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGIuaW5kZXhPZihhKSA+PSAwO1xuICAgICAgICB9IHZhciBlID0gRXJyb3IoJ05vdCBhIGNvbnRhaW5lcjogJyArIGIpOyBlLm5hbWU9J1R5cGVFcnJvcic7IHRocm93IGU7XG4gICAgfTtcbiAgICB2YXIgX3B5ZnVuY19lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGEsIGIpIHsgLy8gbmFyZ3M6IDJcbiAgICAgICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgICAgIHZhciBpID0gMCwgaXNlcSA9IGEubGVuZ3RoID09IGIubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGlzZXEgJiYgaSA8IGEubGVuZ3RoKSB7aXNlcSA9IGVxdWFscyhhW2ldLCBiW2ldKTsgaSs9MTt9XG4gICAgICAgICAgICByZXR1cm4gaXNlcTtcbiAgICAgICAgfSBlbHNlIGlmIChhLmNvbnN0cnVjdG9yID09PSBPYmplY3QgJiYgYi5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgYWtleXMgPSBPYmplY3Qua2V5cyhhKSwgYmtleXMgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgICAgIGFrZXlzLnNvcnQoKTsgYmtleXMuc29ydCgpO1xuICAgICAgICAgICAgdmFyIGk9MCwgaywgaXNlcSA9IGVxdWFscyhha2V5cywgYmtleXMpO1xuICAgICAgICAgICAgd2hpbGUgKGlzZXEgJiYgaSA8IGFrZXlzLmxlbmd0aCkge2s9YWtleXNbaV07IGlzZXEgPSBlcXVhbHMoYVtrXSwgYltrXSk7IGkrPTE7fVxuICAgICAgICAgICAgcmV0dXJuIGlzZXE7XG4gICAgICAgIH0gcmV0dXJuIGEgPT0gYjtcbiAgICB9O1xuICAgIHZhciBfcHlmdW5jX2luc3RhbnRpYXRlID0gZnVuY3Rpb24gKG9iLCBhcmdzKSB7IC8vIG5hcmdzOiAyXG4gICAgICAgIGlmICgodHlwZW9mIG9iID09PSBcInVuZGVmaW5lZFwiKSB8fFxuICAgICAgICAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyA9PT0gb2IpIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsID09PSBvYikpXG4gICAgICAgICAgICAgICAge3Rocm93IFwiQ2xhc3MgY29uc3RydWN0b3IgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCI7fVxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9iKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0W25hbWVdID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb2JbbmFtZV0gPT09ICdmdW5jdGlvbicgJiYgIW9iW25hbWVdLm5vYmluZCkge1xuICAgICAgICAgICAgICAgIG9iW25hbWVdID0gb2JbbmFtZV0uYmluZChvYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iLl9faW5pdF9fKSB7XG4gICAgICAgICAgICBvYi5fX2luaXRfXy5hcHBseShvYiwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBfcHlmdW5jX211bHQgPSBmdW5jdGlvbiAoYSwgYikgeyAvLyBuYXJnczogMlxuICAgICAgICBpZiAoKHR5cGVvZiBhID09PSAnbnVtYmVyJykgKyAodHlwZW9mIGIgPT09ICdudW1iZXInKSA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFN0cmluZykgcmV0dXJuIF9weW1ldGhfcmVwZWF0LmNhbGwoYSwgYik7XG4gICAgICAgICAgICBpZiAoYi5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSByZXR1cm4gX3B5bWV0aF9yZXBlYXQuY2FsbChiLCBhKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGIpKSB7dmFyIHQ9YTsgYT1iOyBiPXQ7fVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gW107IGZvciAodmFyIGk9MDsgaTxiOyBpKyspIHJlcyA9IHJlcy5jb25jYXQoYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSByZXR1cm4gYSAqIGI7XG4gICAgfTtcbiAgICB2YXIgX3B5ZnVuY19yYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICB2YXIgdmFsID0gc3RhcnQ7XG4gICAgICAgIHZhciBuID0gKGVuZCAtIHN0YXJ0KSAvIHN0ZXA7XG4gICAgICAgIGZvciAoaT0wOyBpPG47IGkrKykge1xuICAgICAgICAgICAgcmVzLnB1c2godmFsKTtcbiAgICAgICAgICAgIHZhbCArPSBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICB2YXIgX3B5ZnVuY190cnV0aHkgPSBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB0eXBlb2YgdiAhPT0gXCJvYmplY3RcIikge3JldHVybiB2O31cbiAgICAgICAgZWxzZSBpZiAodi5sZW5ndGggIT09IHVuZGVmaW5lZCkge3JldHVybiB2Lmxlbmd0aCA/IHYgOiBmYWxzZTt9XG4gICAgICAgIGVsc2UgaWYgKHYuYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7cmV0dXJuIHYuYnl0ZUxlbmd0aCA/IHYgOiBmYWxzZTt9XG4gICAgICAgIGVsc2UgaWYgKHYuY29uc3RydWN0b3IgIT09IE9iamVjdCkge3JldHVybiB0cnVlO31cbiAgICAgICAgZWxzZSB7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHYpLmxlbmd0aCA/IHYgOiBmYWxzZTt9XG4gICAgfTtcbiAgICB2YXIgX3B5bWV0aF9hcHBlbmQgPSBmdW5jdGlvbiAoeCkgeyAvLyBuYXJnczogMVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcykpIHJldHVybiB0aGlzLmFwcGVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnB1c2goeCk7XG4gICAgfTtcbiAgICB2YXIgX3B5bWV0aF9nZXQgPSBmdW5jdGlvbiAoa2V5LCBkKSB7IC8vIG5hcmdzOiAxIDJcbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgIT09IE9iamVjdCkgcmV0dXJuIHRoaXMuZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aGlzW2tleV0gIT09IHVuZGVmaW5lZCkge3JldHVybiB0aGlzW2tleV07fVxuICAgICAgICBlbHNlIGlmIChkICE9PSB1bmRlZmluZWQpIHtyZXR1cm4gZDt9XG4gICAgICAgIGVsc2Uge3JldHVybiBudWxsO31cbiAgICB9O1xuICAgIHZhciBfcHltZXRoX2tleXMgPSBmdW5jdGlvbiAoKSB7IC8vIG5hcmdzOiAwXG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1sna2V5cyddID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5rZXlzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzKTtcbiAgICB9O1xuICAgIHZhciBfcHltZXRoX2xzdHJpcCA9IGZ1bmN0aW9uIChjaGFycykgeyAvLyBuYXJnczogMCAxXG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSBTdHJpbmcpIHJldHVybiB0aGlzLmxzdHJpcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBjaGFycyA9IChjaGFycyA9PT0gdW5kZWZpbmVkKSA/ICcgXFx0XFxyXFxuJyA6IGNoYXJzO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNoYXJzLmluZGV4T2YodGhpc1tpXSkgPCAwKSByZXR1cm4gdGhpcy5zbGljZShpKTtcbiAgICAgICAgfSByZXR1cm4gJyc7XG4gICAgfTtcbiAgICB2YXIgX3B5bWV0aF9yZW1vdmUgPSBmdW5jdGlvbiAoeCkgeyAvLyBuYXJnczogMVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcykpIHJldHVybiB0aGlzLnJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKF9weWZ1bmNfZXF1YWxzKHRoaXNbaV0sIHgpKSB7dGhpcy5zcGxpY2UoaSwgMSk7IHJldHVybjt9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGUgPSBFcnJvcih4KTsgZS5uYW1lPSdWYWx1ZUVycm9yJzsgdGhyb3cgZTtcbiAgICB9O1xuICAgIHZhciBfcHltZXRoX3JlcGVhdCA9IGZ1bmN0aW9uKGNvdW50KSB7IC8vIG5hcmdzOiAwXG4gICAgICAgIGlmICh0aGlzLnJlcGVhdCkgcmV0dXJuIHRoaXMucmVwZWF0KGNvdW50KTtcbiAgICAgICAgaWYgKGNvdW50IDwgMSkgcmV0dXJuICcnO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJycsIHBhdHRlcm4gPSB0aGlzLnZhbHVlT2YoKTtcbiAgICAgICAgd2hpbGUgKGNvdW50ID4gMSkge1xuICAgICAgICAgICAgaWYgKGNvdW50ICYgMSkgcmVzdWx0ICs9IHBhdHRlcm47XG4gICAgICAgICAgICBjb3VudCA+Pj0gMSwgcGF0dGVybiArPSBwYXR0ZXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBwYXR0ZXJuO1xuICAgIH07XG4gICAgdmFyIF9weW1ldGhfc3RhcnRzd2l0aCA9IGZ1bmN0aW9uICh4KSB7IC8vIG5hcmdzOiAxXG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSBTdHJpbmcpIHJldHVybiB0aGlzLnN0YXJ0c3dpdGguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZih4KSA9PSAwO1xuICAgIH07XG4gICAgdmFyIEJ1ZmZlciwgR2xvb09iamVjdCwgSW5kZXhCdWZmZXIsIFByb2dyYW0sIFRleHR1cmUyRCwgVGV4dHVyZTNETGlrZSwgVmVydGV4QnVmZmVyLCBfX3ZlcnNpb25fXywgY2hlY2tfZXJyb3IsIGNvbnNvbGU7XG4gICAgLy8gUHlTY3JpcHQgbW9kdWxlIGZvciBnbG9vMi5qcyAtIGxpZ2h0d2VpZ2h0IG9iamVjdCBvcmllbnRlZCBHTC5cblxuICAgIHsgLyogaWYgdGhpc19pc19qcygpICovXG4gICAgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlO1xuICAgIH1cbiAgICBfX3ZlcnNpb25fXyA9IFwiMC4zXCI7XG4gICAgY2hlY2tfZXJyb3IgPSBmdW5jdGlvbiAoZ2wsIHdoZW4pIHtcbiAgICAgICAgdmFyIGUsIGVyciwgZXJyXzMsIGVycm9ycywgbXNnLCBzdHViMV9zZXEsIHN0dWIyX2l0cjtcbiAgICAgICAgd2hlbiA9ICh3aGVuID09PSB1bmRlZmluZWQpID8gXCJwZXJpb2RpYyBjaGVja1wiOiB3aGVuO1xuICAgICAgICAvLyBDaGVjayB0aGlzIGZyb20gdGltZSB0byB0aW1lIHRvIGRldGVjdCBHTCBlcnJvcnMuXG4gICAgICAgIC8vIFxuICAgICAgICAvLyAgICAgUGFyYW1ldGVyc1xuICAgICAgICAvLyAgICAgLS0tLS0tLS0tLVxuICAgICAgICAvLyAgICAgd2hlbiA6IHN0clxuICAgICAgICAvLyAgICAgICAgIFNob3duIGluIHRoZSBleGNlcHRpb24gdG8gaGVscCB0aGUgZGV2ZWxvcGVyIGRldGVybWluZSB3aGVuXG4gICAgICAgIC8vICAgICAgICAgdGhpcyBjaGVjayB3YXMgZG9uZS5cbiAgICAgICAgZXJyb3JzID0gW107XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBlcnIgPSBnbC5nZXRFcnJvcigpO1xuICAgICAgICAgICAgaWYgKChfcHlmdW5jX2VxdWFscyhlcnIsIGdsLk5PX0VSUk9SKSB8fCAoX3B5ZnVuY190cnV0aHkoZXJyb3JzKSAmJiBfcHlmdW5jX2VxdWFscyhlcnIsIGVycm9yc1tlcnJvcnMubGVuZ3RoIC0xXSkpKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3B5bWV0aF9hcHBlbmQuY2FsbChlcnJvcnMsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1zZyA9IFwiXCI7XG4gICAgICAgICAgICBzdHViMV9zZXEgPSBlcnJvcnM7XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBzdHViMV9zZXEgPT09IFwib2JqZWN0XCIpICYmICghQXJyYXkuaXNBcnJheShzdHViMV9zZXEpKSkge1xuICAgICAgICAgICAgICAgIHN0dWIxX3NlcSA9IE9iamVjdC5rZXlzKHN0dWIxX3NlcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHN0dWIyX2l0ciA9IDA7IHN0dWIyX2l0ciA8IHN0dWIxX3NlcS5sZW5ndGg7IHN0dWIyX2l0ciArPSAxKSB7XG4gICAgICAgICAgICAgICAgZSA9IHN0dWIxX3NlcVtzdHViMl9pdHJdO1xuICAgICAgICAgICAgICAgIG1zZz1fcHlmdW5jX2FkZChtc2csIGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJfMyA9IG5ldyBFcnJvcignUnVudGltZUVycm9yOicgKyAoXCJPcGVuR0wgZ290IGVycm9ycyAoXCIgKyB3aGVuICsgXCIpOiBcIiArIG1zZyArIFwiXCIpKTsgZXJyXzMubmFtZSA9IFwiUnVudGltZUVycm9yXCI7IHRocm93IGVycl8zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBHbG9vT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBhbGwgR2xvbyBjbGFzc2VzLlxuICAgICAgICBfcHlmdW5jX2luc3RhbnRpYXRlKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEdsb29PYmplY3QucHJvdG90eXBlLl9iYXNlX2NsYXNzID0gT2JqZWN0O1xuICAgIEdsb29PYmplY3QucHJvdG90eXBlLl9jbGFzc19uYW1lID0gXCJHbG9vT2JqZWN0XCI7XG4gICAgXG4gICAgR2xvb09iamVjdC5wcm90b3R5cGUuX19pbml0X18gPSBmdW5jdGlvbiAoZ2wpIHtcbiAgICAgICAgLy8gSW5pdCBieSBwYXNzaW5nIHRoZSB3ZWJnbCBjb250ZXh0IG9iamVjdC5cbiAgICAgICAgdGhpcy5fZ2wgPSBnbDtcbiAgICAgICAgdGhpcy5oYW5kbGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9jcmVhdGUoKTtcbiAgICAgICAgaWYgKCEodGhpcy5oYW5kbGUgIT09IG51bGwpKSB7dGhyb3cgXCJBc3NlcnRpb25FcnJvcjogXCIgKyBcInRoaXMuaGFuZGxlICE9PSBudWxsXCI7fVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgR2xvb09iamVjdC5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVycl8yO1xuICAgICAgICBlcnJfMiA9IG5ldyBFcnJvcignTm90SW1wbGVtZW50ZWRFcnJvcjonICsgXCJcIik7IGVycl8yLm5hbWUgPSBcIk5vdEltcGxlbWVudGVkRXJyb3JcIjsgdGhyb3cgZXJyXzI7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cblxuICAgIFByb2dyYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRoZSBwcm9ncmFtIGlzIHRoZSBjZW50cmFsIGNvbXBvbmVudCB0byBjb25uZWN0IGdsb28gb2JqZWN0cyBhbmQgc2hhZGVycy5cbiAgICAgICAgX3B5ZnVuY19pbnN0YW50aWF0ZSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBQcm9ncmFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR2xvb09iamVjdC5wcm90b3R5cGUpO1xuICAgIFByb2dyYW0ucHJvdG90eXBlLl9iYXNlX2NsYXNzID0gR2xvb09iamVjdC5wcm90b3R5cGU7XG4gICAgUHJvZ3JhbS5wcm90b3R5cGUuX2NsYXNzX25hbWUgPSBcIlByb2dyYW1cIjtcbiAgICBcbiAgICBQcm9ncmFtLnByb3RvdHlwZS5VVFlQRU1BUCA9IHtcImZsb2F0XCI6IFwidW5pZm9ybTFmdlwiLCBcInZlYzJcIjogXCJ1bmlmb3JtMmZ2XCIsIFwidmVjM1wiOiBcInVuaWZvcm0zZnZcIiwgXCJ2ZWM0XCI6IFwidW5pZm9ybTRmdlwiLCBcImludFwiOiBcInVuaWZvcm0xaXZcIiwgXCJpdmVjMlwiOiBcInVuaWZvcm0yaXZcIiwgXCJpdmVjM1wiOiBcInVuaWZvcm0zaXZcIiwgXCJpdmVjNFwiOiBcInVuaWZvcm00aXZcIiwgXCJib29sXCI6IFwidW5pZm9ybTFpdlwiLCBcImJ2ZWMyXCI6IFwidW5pZm9ybTJpdlwiLCBcImJ2ZWMzXCI6IFwidW5pZm9ybTNpdlwiLCBcImJ2ZWM0XCI6IFwidW5pZm9ybTRpdlwiLCBcIm1hdDJcIjogXCJ1bmlmb3JtTWF0cml4MmZ2XCIsIFwibWF0M1wiOiBcInVuaWZvcm1NYXRyaXgzZnZcIiwgXCJtYXQ0XCI6IFwidW5pZm9ybU1hdHJpeDRmdlwiLCBcInNhbXBsZXIxRFwiOiBcInVuaWZvcm0xaVwiLCBcInNhbXBsZXIyRFwiOiBcInVuaWZvcm0xaVwiLCBcInNhbXBsZXIzRFwiOiBcInVuaWZvcm0xaVwifTtcbiAgICBQcm9ncmFtLnByb3RvdHlwZS5BVFlQRU1BUCA9IHtcImZsb2F0XCI6IFwidmVydGV4QXR0cmliMWZcIiwgXCJ2ZWMyXCI6IFwidmVydGV4QXR0cmliMmZcIiwgXCJ2ZWMzXCI6IFwidmVydGV4QXR0cmliM2ZcIiwgXCJ2ZWM0XCI6IFwidmVydGV4QXR0cmliNGZcIn07XG4gICAgUHJvZ3JhbS5wcm90b3R5cGUuQVRZUEVJTkZPID0ge1wiZmxvYXRcIjogWzEsIDUxMjZdLCBcInZlYzJcIjogWzIsIDUxMjZdLCBcInZlYzNcIjogWzMsIDUxMjZdLCBcInZlYzRcIjogWzQsIDUxMjZdfTtcbiAgICBQcm9ncmFtLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhbmRsZSA9IHRoaXMuX2dsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5fdW5zZXRfdmFyaWFibGVzID0gW107XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zYW1wbGVycyA9IHt9O1xuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzID0ge307XG4gICAgICAgIHRoaXMuX2tub3duX2ludmFsaWQgPSBbXTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIFByb2dyYW0ucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRGVsZXRlIHRoZSBwcm9ncmFtLlxuICAgICAgICB0aGlzLl9nbC5kZWxldGVQcm9ncmFtKHRoaXMuaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIFByb2dyYW0ucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBY3RpdmF0ZSB0aGUgcHJvZ3JhbS5cbiAgICAgICAgdGhpcy5fZ2wudXNlUHJvZ3JhbSh0aGlzLmhhbmRsZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBQcm9ncmFtLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEaXNhYmxlIHRoZSBwcm9ncmFtLlxuICAgICAgICB0aGlzLl9nbC51c2VQcm9ncmFtKDApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgUHJvZ3JhbS5wcm90b3R5cGUuc2V0X3NoYWRlcnMgPSBmdW5jdGlvbiAodmVydCwgZnJhZykge1xuICAgICAgICB2YXIgY29kZSwgZXJyXzMsIGVycl80LCBlcnJvcnMsIGZyYWdfaGFuZGxlLCBnbCwgaGFuZGxlLCBpLCBzdGF0dXMsIHN0dWIzXywgdG1wLCB0eXBlXywgdmVydF9oYW5kbGU7XG4gICAgICAgIC8vIFNldCBHTFNMIGNvZGUgZm9yIHRoZSB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlci5cbiAgICAgICAgLy8gXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgY2FyZSBvZiBzZXR0aW5nIHRoZSBzaGFkaW5nIGNvZGUgYW5kXG4gICAgICAgIC8vIGNvbXBpbGluZytsaW5raW5nIGl0IGludG8gYSB3b3JraW5nIHByb2dyYW0gb2JqZWN0IHRoYXQgaXMgcmVhZHlcbiAgICAgICAgLy8gdG8gdXNlLlxuICAgICAgICAvLyBcbiAgICAgICAgLy8gUGFyYW1ldGVyc1xuICAgICAgICAvLyAtLS0tLS0tLS0tXG4gICAgICAgIC8vIHZlcnQgOiBzdHJcbiAgICAgICAgLy8gICAgIEdMU0wgY29kZSBmb3IgdGhlIHZlcnRleCBzaGFkZXIuXG4gICAgICAgIC8vIGZyYWcgOiBzdHJcbiAgICAgICAgLy8gICAgIEdMU0wgY29kZSBmb3IgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAgICAgICAgZ2wgPSB0aGlzLl9nbDtcbiAgICAgICAgdGhpcy5fbGlua2VkID0gZmFsc2U7XG4gICAgICAgIHZlcnRfaGFuZGxlID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuICAgICAgICBmcmFnX2hhbmRsZSA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgICAgICB0bXAgPSBbW3ZlcnQsIHZlcnRfaGFuZGxlLCBcInZlcnRleFwiXSwgW2ZyYWcsIGZyYWdfaGFuZGxlLCBcImZyYWdtZW50XCJdXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI7IGkgKz0gMSkge1xuICAgICAgICAgICAgc3R1YjNfID0gdG1wW2ldO1xuICAgICAgICAgICAgY29kZSA9IHN0dWIzX1swXTtoYW5kbGUgPSBzdHViM19bMV07dHlwZV8gPSBzdHViM19bMl07XG4gICAgICAgICAgICBnbC5zaGFkZXJTb3VyY2UoaGFuZGxlLCBjb2RlKTtcbiAgICAgICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoaGFuZGxlKTtcbiAgICAgICAgICAgIHN0YXR1cyA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihoYW5kbGUsIGdsLkNPTVBJTEVfU1RBVFVTKTtcbiAgICAgICAgICAgIGlmICgoIV9weWZ1bmNfdHJ1dGh5KHN0YXR1cykpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhoYW5kbGUpO1xuICAgICAgICAgICAgICAgIGVycl80ID0gbmV3IEVycm9yKCdSdW50aW1lRXJyb3I6JyArIChfcHlmdW5jX2FkZCgoKFwiZXJyb3JzIGluIFwiICsgdHlwZV8pICsgXCIgc2hhZGVyOlxcblwiKSwgZXJyb3JzKSkpOyBlcnJfNC5uYW1lID0gXCJSdW50aW1lRXJyb3JcIjsgdGhyb3cgZXJyXzQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHRoaXMuaGFuZGxlLCB2ZXJ0X2hhbmRsZSk7XG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcih0aGlzLmhhbmRsZSwgZnJhZ19oYW5kbGUpO1xuICAgICAgICBnbC5saW5rUHJvZ3JhbSh0aGlzLmhhbmRsZSk7XG4gICAgICAgIGlmICgoIV9weWZ1bmNfdHJ1dGh5KGdsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5oYW5kbGUsIGdsLkxJTktfU1RBVFVTKSkpKSB7XG4gICAgICAgICAgICBlcnJfMyA9IG5ldyBFcnJvcignUnVudGltZUVycm9yOicgKyAoXCJQcm9ncmFtIGxpbmsgZXJyb3I6XFxuXCIgKyBnbC5nZXRQcm9ncmFtSW5mb0xvZyh0aGlzLmhhbmRsZSkpKTsgZXJyXzMubmFtZSA9IFwiUnVudGltZUVycm9yXCI7IHRocm93IGVycl8zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Vuc2V0X3ZhcmlhYmxlcyA9IHRoaXMuX2dldF9hY3RpdmVfYXR0cmlidXRlc19hbmRfdW5pZm9ybXMoKTtcbiAgICAgICAgZ2wuZGV0YWNoU2hhZGVyKHRoaXMuaGFuZGxlLCB2ZXJ0X2hhbmRsZSk7XG4gICAgICAgIGdsLmRldGFjaFNoYWRlcih0aGlzLmhhbmRsZSwgZnJhZ19oYW5kbGUpO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIodmVydF9oYW5kbGUpO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ19oYW5kbGUpO1xuICAgICAgICB0aGlzLl9rbm93bl9pbnZhbGlkID0gW107XG4gICAgICAgIHRoaXMuX2xpbmtlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBQcm9ncmFtLnByb3RvdHlwZS5fZ2V0X2FjdGl2ZV9hdHRyaWJ1dGVzX2FuZF91bmlmb3JtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMsIGNhLCBjb250YWluZXIsIGNvdW50LCBjdSwgZ2V0QWN0aXZlLCBnZXRMb2NhdGlvbiwgZ2wsIGksIGluZm8sIGosIG0sIG5hbWUsIHJlZ2V4LCBzdHViNF8sIHN0dWI1X3NlcSwgc3R1YjZfaXRyLCB1bmlmb3JtcywgeDtcbiAgICAgICAgLy8gUmV0cmlldmUgYWN0aXZlIGF0dHJpYnV0ZXMgYW5kIHVuaWZvcm1zIHRvIGJlIGFibGUgdG8gY2hlY2sgdGhhdFxuICAgICAgICAvLyBhbGwgdW5pZm9ybXMvYXR0cmlidXRlcyBhcmUgc2V0IGJ5IHRoZSB1c2VyLlxuICAgICAgICBnbCA9IHRoaXMuX2dsO1xuICAgICAgICB0aGlzLmxvY2F0aW9ucyA9IHt9O1xuICAgICAgICByZWdleCA9IG5ldyB3aW5kb3cuUmVnRXhwKFwiKFxcXFx3KylcXFxccyooXFxcXFsoXFxcXGQrKVxcXFxdKVxcXFxzKlwiKTtcbiAgICAgICAgY3UgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMuaGFuZGxlLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xuICAgICAgICBjYSA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5oYW5kbGUsIGdsLkFDVElWRV9BVFRSSUJVVEVTKTtcbiAgICAgICAgYXR0cmlidXRlcyA9IFtdO1xuICAgICAgICB1bmlmb3JtcyA9IFtdO1xuICAgICAgICBzdHViNV9zZXEgPSBbW2F0dHJpYnV0ZXMsIGNhLCBnbC5nZXRBY3RpdmVBdHRyaWIsIGdsLmdldEF0dHJpYkxvY2F0aW9uXSwgW3VuaWZvcm1zLCBjdSwgZ2wuZ2V0QWN0aXZlVW5pZm9ybSwgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uXV07XG4gICAgICAgIGlmICgodHlwZW9mIHN0dWI1X3NlcSA9PT0gXCJvYmplY3RcIikgJiYgKCFBcnJheS5pc0FycmF5KHN0dWI1X3NlcSkpKSB7XG4gICAgICAgICAgICBzdHViNV9zZXEgPSBPYmplY3Qua2V5cyhzdHViNV9zZXEpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoc3R1YjZfaXRyID0gMDsgc3R1YjZfaXRyIDwgc3R1YjVfc2VxLmxlbmd0aDsgc3R1YjZfaXRyICs9IDEpIHtcbiAgICAgICAgICAgIHggPSBzdHViNV9zZXFbc3R1YjZfaXRyXTtcbiAgICAgICAgICAgIHN0dWI0XyA9IHg7XG4gICAgICAgICAgICBjb250YWluZXIgPSBzdHViNF9bMF07Y291bnQgPSBzdHViNF9bMV07Z2V0QWN0aXZlID0gc3R1YjRfWzJdO2dldExvY2F0aW9uID0gc3R1YjRfWzNdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpbmZvID0gZ2V0QWN0aXZlLmNhbGwoZ2wsIHRoaXMuaGFuZGxlLCBpKTtcbiAgICAgICAgICAgICAgICBuYW1lID0gaW5mby5uYW1lO1xuICAgICAgICAgICAgICAgIG0gPSBuYW1lLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgICAgICBpZiAoX3B5ZnVuY190cnV0aHkobSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG1bMV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBpbmZvLnNpemU7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3B5bWV0aF9hcHBlbmQuY2FsbChjb250YWluZXIsIChbXCJcIiArIG5hbWUgKyBcIltcIiArIGogKyBcIl1cIiwgaW5mby50eXBlXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3B5bWV0aF9hcHBlbmQuY2FsbChjb250YWluZXIsIFtuYW1lLCBpbmZvLnR5cGVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbnNbbmFtZV0gPSBnZXRMb2NhdGlvbi5jYWxsKGdsLCB0aGlzLmhhbmRsZSwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9weWZ1bmNfYWRkKCgoZnVuY3Rpb24gbGlzdF9jb21wcmVoZW5zb24gKCkge3ZhciByZXMgPSBbXTt2YXIgdiwgaXRlcjAsIGkwO2l0ZXIwID0gYXR0cmlidXRlcztpZiAoKHR5cGVvZiBpdGVyMCA9PT0gXCJvYmplY3RcIikgJiYgKCFBcnJheS5pc0FycmF5KGl0ZXIwKSkpIHtpdGVyMCA9IE9iamVjdC5rZXlzKGl0ZXIwKTt9Zm9yIChpMD0wOyBpMDxpdGVyMC5sZW5ndGg7IGkwKyspIHt2ID0gaXRlcjBbaTBdO3tyZXMucHVzaCh2WzBdKTt9fXJldHVybiByZXM7fSkuYXBwbHkodGhpcykpLCAoKGZ1bmN0aW9uIGxpc3RfY29tcHJlaGVuc29uICgpIHt2YXIgcmVzID0gW107dmFyIHYsIGl0ZXIwLCBpMDtpdGVyMCA9IHVuaWZvcm1zO2lmICgodHlwZW9mIGl0ZXIwID09PSBcIm9iamVjdFwiKSAmJiAoIUFycmF5LmlzQXJyYXkoaXRlcjApKSkge2l0ZXIwID0gT2JqZWN0LmtleXMoaXRlcjApO31mb3IgKGkwPTA7IGkwPGl0ZXIwLmxlbmd0aDsgaTArKykge3YgPSBpdGVyMFtpMF07e3Jlcy5wdXNoKHZbMF0pO319cmV0dXJuIHJlczt9KS5hcHBseSh0aGlzKSkpO1xuICAgIH07XG5cbiAgICBQcm9ncmFtLnByb3RvdHlwZS5zZXRfdGV4dHVyZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZXJyXzMsIGhhbmRsZSwgdW5pdDtcbiAgICAgICAgLy8gU2V0IGEgdGV4dHVyZSBzYW1wbGVyLlxuICAgICAgICAvLyBcbiAgICAgICAgLy8gQSB0ZXh0dXJlIGlzIGEgMiBkaW1lbnNpb25hbCBncmlkIG9mIGNvbG9ycy9pbnRlbnNpdGllcyB0aGF0XG4gICAgICAgIC8vIGNhbiBiZSBhcHBsaWVkIHRvIGEgZmFjZSAob3IgdXNlZCBmb3Igb3RoZXIgbWVhbnMgYnkgcHJvdmlkaW5nXG4gICAgICAgIC8vIGEgcmVndWxhciBncmlkIG9mIGRhdGEpLlxuICAgICAgICAvLyBcbiAgICAgICAgLy8gUGFyYW1ldGVyc1xuICAgICAgICAvLyAtLS0tLS0tLS0tXG4gICAgICAgIC8vIG5hbWUgOiBzdHJcbiAgICAgICAgLy8gICAgIFRoZSBuYW1lIGJ5IHdoaWNoIHRoZSB0ZXh0dXJlIGlzIGtub3duIGluIHRoZSBHTFNMIGNvZGUuXG4gICAgICAgIC8vIHZhbHVlIDogVGV4dHVyZTJEXG4gICAgICAgIC8vICAgICBUaGUgZ2xvbyBUZXh0dXJlMkQgb2JqZWN0IHRvIGJpbmQuXG4gICAgICAgIGlmICgoIV9weWZ1bmNfdHJ1dGh5KHRoaXMuX2xpbmtlZCkpKSB7XG4gICAgICAgICAgICBlcnJfMyA9IG5ldyBFcnJvcignUnVudGltZUVycm9yOicgKyBcIkNhbm5vdCBzZXQgdW5pZm9ybSB3aGVuIHByb2dyYW0gaGFzIG5vIGNvZGVcIik7IGVycl8zLm5hbWUgPSBcIlJ1bnRpbWVFcnJvclwiOyB0aHJvdyBlcnJfMztcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGUgPSBfcHltZXRoX2dldC5jYWxsKHRoaXMubG9jYXRpb25zLCBuYW1lLCAoLTEpKTtcbiAgICAgICAgaWYgKF9weWZ1bmNfdHJ1dGh5KGhhbmRsZSA8IDApKSB7XG4gICAgICAgICAgICBpZiAoKCFfcHlmdW5jX2NvbnRhaW5zKG5hbWUsIHRoaXMuX2tub3duX2ludmFsaWQpKSkge1xuICAgICAgICAgICAgICAgIF9weW1ldGhfYXBwZW5kLmNhbGwodGhpcy5fa25vd25faW52YWxpZCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJWYXJpYWJsZSBcIiArIG5hbWUgKyBcIiBpcyBub3QgYW4gYWN0aXZlIHRleHR1cmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3B5ZnVuY19jb250YWlucyhuYW1lLCB0aGlzLl91bnNldF92YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICBfcHltZXRoX3JlbW92ZS5jYWxsKHRoaXMuX3Vuc2V0X3ZhcmlhYmxlcywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgdW5pdCA9IF9weW1ldGhfa2V5cy5jYWxsKHRoaXMuX3NhbXBsZXJzKS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoX3B5ZnVuY19jb250YWlucyhuYW1lLCB0aGlzLl9zYW1wbGVycykpIHtcbiAgICAgICAgICAgICAgICB1bml0ID0gdGhpcy5fc2FtcGxlcnNbbmFtZV1bdGhpcy5fc2FtcGxlcnNbbmFtZV0ubGVuZ3RoIC0xXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NhbXBsZXJzW25hbWVdID0gW3ZhbHVlLl90YXJnZXQsIHZhbHVlLmhhbmRsZSwgdW5pdF07XG4gICAgICAgICAgICB0aGlzLl9nbC51bmlmb3JtMWkoaGFuZGxlLCB1bml0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgUHJvZ3JhbS5wcm90b3R5cGUuc2V0X3VuaWZvcm0gPSBmdW5jdGlvbiAobmFtZSwgdHlwZV8sIHZhbHVlKSB7XG4gICAgICAgIHZhciBhX3R5cGUsIGNvdW50LCBlcnJfMywgZnVuY25hbWUsIGhhbmRsZSwgaiwgbmFtZV87XG4gICAgICAgIC8vIFNldCBhIHVuaWZvcm0gdmFsdWUuXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBBIHVuaWZvcm0gaXMgYSB2YWx1ZSB0aGF0IGlzIGdsb2JhbCB0byBib3RoIHRoZSB2ZXJ0ZXggYW5kXG4gICAgICAgIC8vIGZyYWdtZW50IHNoYWRlci5cbiAgICAgICAgLy8gXG4gICAgICAgIC8vIFBhcmFtZXRlcnNcbiAgICAgICAgLy8gLS0tLS0tLS0tLVxuICAgICAgICAvLyBuYW1lIDogc3RyXG4gICAgICAgIC8vICAgICBUaGUgbmFtZSBieSB3aGljaCB0aGUgdW5pZm9ybSBpcyBrbm93biBpbiB0aGUgR0xTTCBjb2RlLlxuICAgICAgICAvLyB0eXBlXyA6IHN0clxuICAgICAgICAvLyAgICAgVGhlIHR5cGUgb2YgdGhlIHVuaWZvcm0sIGUuZy4gJ2Zsb2F0JywgJ3ZlYzInLCBldGMuXG4gICAgICAgIC8vIHZhbHVlIDogbGlzdCBvZiBzY2FsYXJzXG4gICAgICAgIC8vICAgICBUaGUgdmFsdWUgZm9yIHRoZSB1bmlmb3JtLiBTaG91bGQgYmUgYSBsaXN0IGV2ZW4gZm9yIHR5cGUgZmxvYXQuXG4gICAgICAgIGlmICgoIV9weWZ1bmNfdHJ1dGh5KHRoaXMuX2xpbmtlZCkpKSB7XG4gICAgICAgICAgICBlcnJfMyA9IG5ldyBFcnJvcignUnVudGltZUVycm9yOicgKyBcIkNhbm5vdCBzZXQgdW5pZm9ybSB3aGVuIHByb2dyYW0gaGFzIG5vIGNvZGVcIik7IGVycl8zLm5hbWUgPSBcIlJ1bnRpbWVFcnJvclwiOyB0aHJvdyBlcnJfMztcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGUgPSBfcHltZXRoX2dldC5jYWxsKHRoaXMubG9jYXRpb25zLCBuYW1lLCAoLTEpKTtcbiAgICAgICAgaWYgKF9weWZ1bmNfdHJ1dGh5KGhhbmRsZSA8IDApKSB7XG4gICAgICAgICAgICBpZiAoKCFfcHlmdW5jX2NvbnRhaW5zKG5hbWUsIHRoaXMuX2tub3duX2ludmFsaWQpKSkge1xuICAgICAgICAgICAgICAgIF9weW1ldGhfYXBwZW5kLmNhbGwodGhpcy5fa25vd25faW52YWxpZCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJWYXJpYWJsZSBcIiArIG5hbWUgKyBcIiBpcyBub3QgYW4gYWN0aXZlIHVuaWZvcm1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3B5ZnVuY19jb250YWlucyhuYW1lLCB0aGlzLl91bnNldF92YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICBfcHltZXRoX3JlbW92ZS5jYWxsKHRoaXMuX3Vuc2V0X3ZhcmlhYmxlcywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY291bnQgPSAxO1xuICAgICAgICBpZiAoKCFfcHltZXRoX3N0YXJ0c3dpdGguY2FsbCh0eXBlXywgXCJtYXRcIikpKSB7XG4gICAgICAgICAgICBhX3R5cGUgPSBfcHltZXRoX2dldC5jYWxsKHtcImludFwiOiBcImZsb2F0XCIsIFwiYm9vbFwiOiBcImZsb2F0XCJ9LCB0eXBlXywgX3B5bWV0aF9sc3RyaXAuY2FsbCh0eXBlXywgXCJpYlwiKSk7XG4gICAgICAgICAgICBjb3VudCA9IE1hdGguZmxvb3IodmFsdWUubGVuZ3RoLyh0aGlzLkFUWVBFSU5GT1thX3R5cGVdWzBdKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9weWZ1bmNfdHJ1dGh5KGNvdW50ID4gMSkpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKChfcHlmdW5jX2NvbnRhaW5zKChcIlwiICsgbmFtZSArIFwiW1wiICsgaiArIFwiXVwiKSwgdGhpcy5fdW5zZXRfdmFyaWFibGVzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZV8gPSBcIlwiICsgbmFtZSArIFwiW1wiICsgaiArIFwiXVwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3B5ZnVuY19jb250YWlucyhuYW1lXywgdGhpcy5fdW5zZXRfdmFyaWFibGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3B5bWV0aF9yZW1vdmUuY2FsbCh0aGlzLl91bnNldF92YXJpYWJsZXMsIG5hbWVfKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jbmFtZSA9IHRoaXMuVVRZUEVNQVBbdHlwZV9dO1xuICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICAgIGlmIChfcHltZXRoX3N0YXJ0c3dpdGguY2FsbCh0eXBlXywgXCJtYXRcIikpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsW2Z1bmNuYW1lXShoYW5kbGUsIGZhbHNlLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9nbFtmdW5jbmFtZV0oaGFuZGxlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIFByb2dyYW0ucHJvdG90eXBlLnNldF9hdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSwgdHlwZV8sIHZhbHVlLCBzdHJpZGUsIG9mZnNldCkge1xuICAgICAgICB2YXIgYXJncywgZXJyXzMsIGZ1bmNuYW1lLCBndHlwZSwgaGFuZGxlLCBpc192Ym8sIHNpemUsIHN0dWI3XztcbiAgICAgICAgc3RyaWRlID0gKHN0cmlkZSA9PT0gdW5kZWZpbmVkKSA/IDA6IHN0cmlkZTtcbiAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA9PT0gdW5kZWZpbmVkKSA/IDA6IG9mZnNldDtcbiAgICAgICAgLy8gU2V0IGFuIGF0dHJpYnV0ZSB2YWx1ZS4gXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBBbiBhdHRyaWJ1dGUgcmVwcmVzZW50cyBwZXItdmVydGV4IGRhdGEgYW5kIGNhbiBvbmx5IGJlIHVzZWRcbiAgICAgICAgLy8gaW4gdGhlIHZlcnRleCBzaGFkZXIuXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBQYXJhbWV0ZXJzXG4gICAgICAgIC8vIC0tLS0tLS0tLS1cbiAgICAgICAgLy8gbmFtZSA6IHN0clxuICAgICAgICAvLyAgICAgVGhlIG5hbWUgYnkgd2hpY2ggdGhlIGF0dHJpYnV0ZSBpcyBrbm93biBpbiB0aGUgR0xTTCBjb2RlLlxuICAgICAgICAvLyB0eXBlXyA6IHN0clxuICAgICAgICAvLyAgICAgVGhlIHR5cGUgb2YgdGhlIGF0dHJpYnV0ZSwgZS5nLiAnZmxvYXQnLCAndmVjMicsIGV0Yy5cbiAgICAgICAgLy8gdmFsdWUgOiBWZXJ0ZXhCdWZmZXIsIGFycmF5XG4gICAgICAgIC8vICAgICBJZiB2YWx1ZSBpcyBhIFZlcnRleEJ1ZmZlciwgaXQgaXMgdXNlZCAod2l0aCBzdHJpZGUgYW5kIG9mZnNldClcbiAgICAgICAgLy8gICAgIGZvciB0aGUgdmVydGV4IGRhdGEuIElmIHZhbHVlIGlzIGFuIGFycmF5LCBpdHMgdXNlZCB0byBzZXRcbiAgICAgICAgLy8gICAgIHRoZSB2YWx1ZSBvZiBhbGwgdmVydGljZXMgKHNpbWlsYXIgdG8gYSB1bmlmb3JtKS5cbiAgICAgICAgLy8gc3RpZGUgOiBpbnQsIGRlZmF1bHQgMFxuICAgICAgICAvLyAgICAgVGhlIHN0cmlkZSB0byBcInNhbXBsZVwiIHRoZSB2ZXJ0ZXggZGF0YSBpbnNpZGUgdGhlIGJ1ZmZlci4gVW5sZXNzXG4gICAgICAgIC8vICAgICBtdWx0aXBsZSB2ZXJ0ZXggZGF0YSBhcmUgcGFja2VkIGludG8gYSBzaW5nbGUgYnVmZmVyLCB0aGlzIHNob3VsZFxuICAgICAgICAvLyAgICAgYmUgemVyby5cbiAgICAgICAgLy8gb2Zmc2V0IDogaW50LCBkZWZhdWx0IDBcbiAgICAgICAgLy8gICAgIFRoZSBvZmZzZXQgdG8gXCJzYW1wbGVcIiB0aGUgdmVydGV4IGRhdGEgaW5zaWRlIHRoZSBidWZmZXIuIFVubGVzc1xuICAgICAgICAvLyAgICAgbXVsdGlwbGUgdmVydGV4IGRhdGEgYXJlIHBhY2tlZCBpbnRvIGEgc2luZ2xlIGJ1ZmZlciwgb3Igb25seVxuICAgICAgICAvLyAgICAgYSBwYXJ0IG9mIHRoZSBkYXRhIG11c3QgYmUgdXNlZCwgdGhpcyBzaG91bGQgcHJvYmFibHkgYmUgemVyby5cbiAgICAgICAgaWYgKCghX3B5ZnVuY190cnV0aHkodGhpcy5fbGlua2VkKSkpIHtcbiAgICAgICAgICAgIGVycl8zID0gbmV3IEVycm9yKCdSdW50aW1lRXJyb3I6JyArIFwiQ2Fubm90IHNldCBhdHRyaWJ1dGUgd2hlbiBwcm9ncmFtIGhhcyBubyBjb2RlXCIpOyBlcnJfMy5uYW1lID0gXCJSdW50aW1lRXJyb3JcIjsgdGhyb3cgZXJyXzM7XG4gICAgICAgIH1cbiAgICAgICAgaXNfdmJvID0gdmFsdWUgaW5zdGFuY2VvZiBWZXJ0ZXhCdWZmZXI7XG4gICAgICAgIGhhbmRsZSA9IF9weW1ldGhfZ2V0LmNhbGwodGhpcy5sb2NhdGlvbnMsIG5hbWUsICgtMSkpO1xuICAgICAgICBpZiAoX3B5ZnVuY190cnV0aHkoaGFuZGxlIDwgMCkpIHtcbiAgICAgICAgICAgIGlmICgoIV9weWZ1bmNfY29udGFpbnMobmFtZSwgdGhpcy5fa25vd25faW52YWxpZCkpKSB7XG4gICAgICAgICAgICAgICAgX3B5bWV0aF9hcHBlbmQuY2FsbCh0aGlzLl9rbm93bl9pbnZhbGlkLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoKF9weWZ1bmNfdHJ1dGh5KGlzX3ZibykgJiYgX3B5ZnVuY190cnV0aHkob2Zmc2V0ID4gMCkpKSB7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJWYXJpYWJsZSBcIiArIG5hbWUgKyBcIiBpcyBub3QgYW4gYWN0aXZlIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3B5ZnVuY19jb250YWlucyhuYW1lLCB0aGlzLl91bnNldF92YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICBfcHltZXRoX3JlbW92ZS5jYWxsKHRoaXMuX3Vuc2V0X3ZhcmlhYmxlcywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICBpZiAoKCFfcHlmdW5jX3RydXRoeShpc192Ym8pKSkge1xuICAgICAgICAgICAgZnVuY25hbWUgPSB0aGlzLkFUWVBFTUFQW3R5cGVfXTtcbiAgICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV0gPSBbMCwgaGFuZGxlLCBmdW5jbmFtZSwgdmFsdWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R1YjdfID0gdGhpcy5BVFlQRUlORk9bdHlwZV9dO1xuICAgICAgICAgICAgc2l6ZSA9IHN0dWI3X1swXTtndHlwZSA9IHN0dWI3X1sxXTtcbiAgICAgICAgICAgIGZ1bmNuYW1lID0gXCJ2ZXJ0ZXhBdHRyaWJQb2ludGVyXCI7XG4gICAgICAgICAgICBhcmdzID0gW3NpemUsIGd0eXBlLCB0aGlzLl9nbC5GQUxTRSwgc3RyaWRlLCBvZmZzZXRdO1xuICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlc1tuYW1lXSA9IFt2YWx1ZS5oYW5kbGUsIGhhbmRsZSwgZnVuY25hbWUsIGFyZ3NdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBQcm9ncmFtLnByb3RvdHlwZS5fcHJlX2RyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzLCBhdHRyX2hhbmRsZSwgZnVuY25hbWUsIHN0dWIxMF8sIHN0dWIxMV9zZXEsIHN0dWI4Xywgc3R1Yjlfc2VxLCB0ZXhfaGFuZGxlLCB0ZXhfdGFyZ2V0LCB1bml0LCB2Ym9faGFuZGxlLCB4O1xuICAgICAgICAvLyBQcmVwYXJlIGZvciBkcmF3aW5nLlxuICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICAgIHN0dWI5X3NlcSA9IHRoaXMuX3NhbXBsZXJzO1xuICAgICAgICBmb3IgKHggaW4gc3R1Yjlfc2VxKSB7XG4gICAgICAgICAgICBpZiAoIXN0dWI5X3NlcS5oYXNPd25Qcm9wZXJ0eSh4KSl7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICB4ID0gc3R1Yjlfc2VxW3hdO1xuICAgICAgICAgICAgc3R1YjhfID0geDtcbiAgICAgICAgICAgIHRleF90YXJnZXQgPSBzdHViOF9bMF07dGV4X2hhbmRsZSA9IHN0dWI4X1sxXTt1bml0ID0gc3R1YjhfWzJdO1xuICAgICAgICAgICAgdGhpcy5fZ2wuYWN0aXZlVGV4dHVyZShfcHlmdW5jX2FkZCh0aGlzLl9nbC5URVhUVVJFMCwgdW5pdCkpO1xuICAgICAgICAgICAgdGhpcy5fZ2wuYmluZFRleHR1cmUodGV4X3RhcmdldCwgdGV4X2hhbmRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3R1YjExX3NlcSA9IHRoaXMuX2F0dHJpYnV0ZXM7XG4gICAgICAgIGZvciAoeCBpbiBzdHViMTFfc2VxKSB7XG4gICAgICAgICAgICBpZiAoIXN0dWIxMV9zZXEuaGFzT3duUHJvcGVydHkoeCkpeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgeCA9IHN0dWIxMV9zZXFbeF07XG4gICAgICAgICAgICBzdHViMTBfID0geDtcbiAgICAgICAgICAgIHZib19oYW5kbGUgPSBzdHViMTBfWzBdO2F0dHJfaGFuZGxlID0gc3R1YjEwX1sxXTtmdW5jbmFtZSA9IHN0dWIxMF9bMl07YXJncyA9IHN0dWIxMF9bM107XG4gICAgICAgICAgICBpZiAoX3B5ZnVuY190cnV0aHkodmJvX2hhbmRsZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5iaW5kQnVmZmVyKHRoaXMuX2dsLkFSUkFZX0JVRkZFUiwgdmJvX2hhbmRsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0cl9oYW5kbGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsW2Z1bmNuYW1lXS5hcHBseSh0aGlzLl9nbCwgW10uY29uY2F0KFthdHRyX2hhbmRsZV0sIGFyZ3MpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyX2hhbmRsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2xbZnVuY25hbWVdLmFwcGx5KHRoaXMuX2dsLCBbXS5jb25jYXQoW2F0dHJfaGFuZGxlXSwgYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgoIV9weWZ1bmNfdHJ1dGh5KHRoaXMuX3ZhbGlkYXRlZCkpKSB7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgUHJvZ3JhbS5wcm90b3R5cGUuX3ZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXJyXzM7XG4gICAgICAgIGlmICh0aGlzLl91bnNldF92YXJpYWJsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlByb2dyYW0gaGFzIHVuc2V0IHZhcmlhYmxlczogXCIgKyB0aGlzLl91bnNldF92YXJpYWJsZXMgKyBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9nbC52YWxpZGF0ZVByb2dyYW0odGhpcy5oYW5kbGUpO1xuICAgICAgICBpZiAoKCFfcHlmdW5jX3RydXRoeSh0aGlzLl9nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMuaGFuZGxlLCB0aGlzLl9nbC5WQUxJREFURV9TVEFUVVMpKSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuX2dsLmdldFByb2dyYW1JbmZvTG9nKHRoaXMuaGFuZGxlKSk7XG4gICAgICAgICAgICBlcnJfMyA9IG5ldyBFcnJvcignUnVudGltZUVycm9yOicgKyBcIlByb2dyYW0gdmFsaWRhdGlvbiBlcnJvclwiKTsgZXJyXzMubmFtZSA9IFwiUnVudGltZUVycm9yXCI7IHRocm93IGVycl8zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBQcm9ncmFtLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKG1vZGUsIHNlbGVjdGlvbikge1xuICAgICAgICB2YXIgY291bnQsIGVycl8zLCBmaXJzdCwgZ3R5cGUsIHN0dWIxMl87XG4gICAgICAgIC8vIERyYXcgdGhlIGN1cnJlbnQgdmlzdWFsaXphdGlvbiBkZWZpbmVkIGJ5IHRoZSBwcm9ncmFtLlxuICAgICAgICAvLyBcbiAgICAgICAgLy8gUGFyYW1ldGVyc1xuICAgICAgICAvLyAtLS0tLS0tLS0tXG4gICAgICAgIC8vIG1vZGUgOiBHTCBlbnVtXG4gICAgICAgIC8vICAgICBDYW4gYmUgUE9JTlRTLCBMSU5FUywgTElORV9MT09QLCBMSU5FX1NUUklQLCBMSU5FX0ZBTiwgVFJJQU5HTEVTXG4gICAgICAgIC8vIHNlbGVjdGlvbiA6IDItZWxlbWVudCB0dXBsZSBvciBJbmRleEJ1ZmZlclxuICAgICAgICAvLyAgICAgVGhlIHNlbGVjdGlvbiB0byBkcmF3LCBzcGVjaWZpZWQgZWl0aGVyIGFzIChmaXJzdCwgY291bnQpIG9yIGFuXG4gICAgICAgIC8vICAgICBJbmRleEJ1ZmZlciBvYmplY3QuXG4gICAgICAgIGlmICgoIV9weWZ1bmNfdHJ1dGh5KHRoaXMuX2xpbmtlZCkpKSB7XG4gICAgICAgICAgICBlcnJfMyA9IG5ldyBFcnJvcignUnVudGltZUVycm9yOicgKyBcIkNhbm5vdCBkcmF3IHByb2dyYW0gaWYgY29kZSBoYXMgbm90IGJlZW4gc2V0XCIpOyBlcnJfMy5uYW1lID0gXCJSdW50aW1lRXJyb3JcIjsgdGhyb3cgZXJyXzM7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tfZXJyb3IodGhpcy5fZ2wsIFwiYmVmb3JlIGRyYXdcIik7XG4gICAgICAgIGlmIChfcHlmdW5jX3RydXRoeShzZWxlY3Rpb24gaW5zdGFuY2VvZiBJbmRleEJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZV9kcmF3KCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uYWN0aXZhdGUoKTtcbiAgICAgICAgICAgIGNvdW50ID0gc2VsZWN0aW9uLl9idWZmZXJfc2l6ZSAvIDI7XG4gICAgICAgICAgICBndHlwZSA9IHRoaXMuX2dsLlVOU0lHTkVEX1NIT1JUO1xuICAgICAgICAgICAgdGhpcy5fZ2wuZHJhd0VsZW1lbnRzKG1vZGUsIGNvdW50LCBndHlwZSwgMCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uZGVhY3RpdmF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R1YjEyXyA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgIGZpcnN0ID0gc3R1YjEyX1swXTtjb3VudCA9IHN0dWIxMl9bMV07XG4gICAgICAgICAgICBpZiAoX3B5ZnVuY190cnV0aHkoY291bnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlX2RyYXcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5kcmF3QXJyYXlzKG1vZGUsIGZpcnN0LCBjb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tfZXJyb3IodGhpcy5fZ2wsIFwiYWZ0ZXIgZHJhd1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuXG4gICAgQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBCYXNlIGJ1ZmZlciBjbGFzcyBmb3IgdmVydGV4IGRhdGEgb3IgaW5kZXggZGF0YS5cbiAgICAgICAgX3B5ZnVuY19pbnN0YW50aWF0ZSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHbG9vT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgQnVmZmVyLnByb3RvdHlwZS5fYmFzZV9jbGFzcyA9IEdsb29PYmplY3QucHJvdG90eXBlO1xuICAgIEJ1ZmZlci5wcm90b3R5cGUuX2NsYXNzX25hbWUgPSBcIkJ1ZmZlclwiO1xuICAgIFxuICAgIEJ1ZmZlci5wcm90b3R5cGUuX3RhcmdldCA9IG51bGw7XG4gICAgQnVmZmVyLnByb3RvdHlwZS5fdXNhZ2UgPSAzNTA0ODtcbiAgICBCdWZmZXIucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlID0gdGhpcy5fZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcl9zaXplID0gMDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIEJ1ZmZlci5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEZWxldGUgdGhlIGJ1ZmZlci5cbiAgICAgICAgdGhpcy5fZ2wuZGVsZXRlQnVmZmVyKHRoaXMuaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIEJ1ZmZlci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEFjdGl2ZXRlIHRoZSBidWZmZXIuXG4gICAgICAgIHRoaXMuX2dsLmJpbmRCdWZmZXIodGhpcy5fdGFyZ2V0LCB0aGlzLmhhbmRsZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBCdWZmZXIucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIERpc2FibGUgdGhlIGJ1ZmZlci5cbiAgICAgICAgdGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl90YXJnZXQsIG51bGwpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgQnVmZmVyLnByb3RvdHlwZS5zZXRfc2l6ZSA9IGZ1bmN0aW9uIChuYnl0ZXMpIHtcbiAgICAgICAgLy8gU2V0IHRoZSBzaXplIG9mIHRoZSBidWZmZXIgaW4gYnl0ZXMuXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBQYXJhbWV0ZXJzXG4gICAgICAgIC8vIC0tLS0tLS0tLS1cbiAgICAgICAgLy8gbmJ5dGVzIDogaW50XG4gICAgICAgIC8vICAgICBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgdGhlIGJ1ZmZlciBuZWVkcyB0byBob2xkLlxuICAgICAgICBpZiAoKCFfcHlmdW5jX2VxdWFscyhuYnl0ZXMsIHRoaXMuX2J1ZmZlcl9zaXplKSkpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2dsLmJ1ZmZlckRhdGEodGhpcy5fdGFyZ2V0LCBuYnl0ZXMsIHRoaXMuX3VzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlcl9zaXplID0gbmJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBCdWZmZXIucHJvdG90eXBlLnNldF9kYXRhID0gZnVuY3Rpb24gKG9mZnNldCwgZGF0YSkge1xuICAgICAgICAvLyBTZXQgdGhlIGJ1ZmZlciBkYXRhLlxuICAgICAgICAvLyBcbiAgICAgICAgLy8gUGFyYW1ldGVyc1xuICAgICAgICAvLyAtLS0tLS0tLS0tXG4gICAgICAgIC8vIG9mZnNldCA6IGludFxuICAgICAgICAvLyAgICAgVGhlIG9mZnNldCBpbiBieXRlcyBmb3IgdGhlIG5ldyBkYXRhLlxuICAgICAgICAvLyBkYXRhIDogdHlwZWQgYXJyYXlcbiAgICAgICAgLy8gICAgIFRoZSBkYXRhIHRvIHVwbG9hZC5cbiAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICB0aGlzLl9nbC5idWZmZXJTdWJEYXRhKHRoaXMuX3RhcmdldCwgb2Zmc2V0LCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuXG4gICAgVmVydGV4QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBIGJ1ZmZlciBmb3IgdmVydGV4IGRhdGEuXG4gICAgICAgIF9weWZ1bmNfaW5zdGFudGlhdGUodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgVmVydGV4QnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSk7XG4gICAgVmVydGV4QnVmZmVyLnByb3RvdHlwZS5fYmFzZV9jbGFzcyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gICAgVmVydGV4QnVmZmVyLnByb3RvdHlwZS5fY2xhc3NfbmFtZSA9IFwiVmVydGV4QnVmZmVyXCI7XG4gICAgXG4gICAgVmVydGV4QnVmZmVyLnByb3RvdHlwZS5fdGFyZ2V0ID0gMzQ5NjI7XG5cbiAgICBJbmRleEJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQSBidWZmZXIgZm9yIGluZGV4IGRhdGEuXG4gICAgICAgIF9weWZ1bmNfaW5zdGFudGlhdGUodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgSW5kZXhCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKTtcbiAgICBJbmRleEJ1ZmZlci5wcm90b3R5cGUuX2Jhc2VfY2xhc3MgPSBCdWZmZXIucHJvdG90eXBlO1xuICAgIEluZGV4QnVmZmVyLnByb3RvdHlwZS5fY2xhc3NfbmFtZSA9IFwiSW5kZXhCdWZmZXJcIjtcbiAgICBcbiAgICBJbmRleEJ1ZmZlci5wcm90b3R5cGUuX3RhcmdldCA9IDM0OTYzO1xuXG4gICAgVGV4dHVyZTJEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBIDIgZGltZW5zaW9uYWwgcmVndWxhciBncmlkLlxuICAgICAgICBfcHlmdW5jX2luc3RhbnRpYXRlKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRleHR1cmUyRC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdsb29PYmplY3QucHJvdG90eXBlKTtcbiAgICBUZXh0dXJlMkQucHJvdG90eXBlLl9iYXNlX2NsYXNzID0gR2xvb09iamVjdC5wcm90b3R5cGU7XG4gICAgVGV4dHVyZTJELnByb3RvdHlwZS5fY2xhc3NfbmFtZSA9IFwiVGV4dHVyZTJEXCI7XG4gICAgXG4gICAgVGV4dHVyZTJELnByb3RvdHlwZS5fdGFyZ2V0ID0gMzU1MztcbiAgICBUZXh0dXJlMkQucHJvdG90eXBlLl90eXBlcyA9IHtcIkludDhBcnJheVwiOiA1MTIwLCBcIlVpbnQ4QXJyYXlcIjogNTEyMSwgXCJJbnQxNkFycmF5XCI6IDUxMjIsIFwiVWludDE2QXJyYXlcIjogNTEyMywgXCJJbnQzMkFycmF5XCI6IDUxMjQsIFwiVWludDMyQXJyYXlcIjogNTEyNSwgXCJGbG9hdDMyQXJyYXlcIjogNTEyNn07XG4gICAgVGV4dHVyZTJELnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhbmRsZSA9IHRoaXMuX2dsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgdGhpcy5fc2hhcGVfZm9ybWF0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIFRleHR1cmUyRC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEZWxldGUgdGhlIHRleHR1cmUuXG4gICAgICAgIHRoaXMuX2dsLmRlbGV0ZVRleHR1cmUodGhpcy5oYW5kbGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgVGV4dHVyZTJELnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQWN0aXZhdGUgdGhlIHRleHR1cmUuXG4gICAgICAgIHRoaXMuX2dsLmJpbmRUZXh0dXJlKHRoaXMuX3RhcmdldCwgdGhpcy5oYW5kbGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgVGV4dHVyZTJELnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEaXNhYmxlIHRoZSB0ZXh0dXJlLlxuICAgICAgICB0aGlzLl9nbC5iaW5kVGV4dHVyZSh0aGlzLl90YXJnZXQsIDApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgVGV4dHVyZTJELnByb3RvdHlwZS5fZ2V0X2FsaWdubWVudCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICAgICAgICB2YXIgYWxpZ25tZW50LCBhbGlnbm1lbnRzLCBzdHViMTNfc2VxLCBzdHViMTRfaXRyO1xuICAgICAgICAvLyBEZXRlcm1pbmVzIGEgdGV4dHVyZXMgYnl0ZSBhbGlnbm1lbnQuIElmIHRoZSB3aWR0aCBpc24ndCBhXG4gICAgICAgIC8vICAgICAgICAgcG93ZXIgb2YgMiB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgYnl0ZSBhbGlnbm1lbnQgb2YgdGhlIGltYWdlLlxuICAgICAgICAvLyAgICAgICAgIFRoZSBpbWFnZSBoZWlnaHQgaXMgdW5pbXBvcnRhbnQuXG4gICAgICAgIC8vIFxuICAgICAgICAvLyAgICAgICAgIHd3dy5vcGVuZ2wub3JnL3dpa2kvQ29tbW9uX01pc3Rha2VzI1RleHR1cmVfdXBsb2FkX2FuZF9waXhlbF9yZWFkc1xuICAgICAgICBhbGlnbm1lbnRzID0gWzQsIDgsIDIsIDFdO1xuICAgICAgICBzdHViMTNfc2VxID0gYWxpZ25tZW50cztcbiAgICAgICAgaWYgKCh0eXBlb2Ygc3R1YjEzX3NlcSA9PT0gXCJvYmplY3RcIikgJiYgKCFBcnJheS5pc0FycmF5KHN0dWIxM19zZXEpKSkge1xuICAgICAgICAgICAgc3R1YjEzX3NlcSA9IE9iamVjdC5rZXlzKHN0dWIxM19zZXEpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoc3R1YjE0X2l0ciA9IDA7IHN0dWIxNF9pdHIgPCBzdHViMTNfc2VxLmxlbmd0aDsgc3R1YjE0X2l0ciArPSAxKSB7XG4gICAgICAgICAgICBhbGlnbm1lbnQgPSBzdHViMTNfc2VxW3N0dWIxNF9pdHJdO1xuICAgICAgICAgICAgaWYgKChfcHlmdW5jX2VxdWFscygod2lkdGggJSBhbGlnbm1lbnQpLCAwKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxpZ25tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBUZXh0dXJlMkQucHJvdG90eXBlLnNldF93cmFwcGluZyA9IGZ1bmN0aW9uICh3cmFwX3MsIHdyYXBfdCkge1xuICAgICAgICAvLyBTZXQgdGhlIHRleHR1cmUgd3JhcHBpbmcgbW9kZS5cbiAgICAgICAgLy8gXG4gICAgICAgIC8vIFBhcmFtZXRlcnNcbiAgICAgICAgLy8gLS0tLS0tLS0tLVxuICAgICAgICAvLyB3cmFwX3MgOiBHTCBlbnVtXG4gICAgICAgIC8vICAgICBUaGUgbW9kZSB0byB3cmFwIHRoZSB4IGRpbWVuc2lvbi4gVmFsaWQgdmFsdWVzIGFyZSBSRVBFQVRcbiAgICAgICAgLy8gICAgIENMQU1QX1RPX0VER0UgTUlSUk9SRURfUkVQRUFUXG4gICAgICAgIC8vIHdyYXBfdCA6IEdMIGVudW1cbiAgICAgICAgLy8gICAgIFRoZSBtb2RlIHRvIHdyYXAgdGhlIHkgZGltZW5zaW9uLiBTYW1lIG9wdGlvbnMgYXMgZm9yIHdyYXBfcy5cbiAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJmKHRoaXMuX3RhcmdldCwgdGhpcy5fZ2wuVEVYVFVSRV9XUkFQX1MsIHdyYXBfcyk7XG4gICAgICAgIHRoaXMuX2dsLnRleFBhcmFtZXRlcmYodGhpcy5fdGFyZ2V0LCB0aGlzLl9nbC5URVhUVVJFX1dSQVBfVCwgd3JhcF90KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIFRleHR1cmUyRC5wcm90b3R5cGUuc2V0X2ludGVycG9sYXRpb24gPSBmdW5jdGlvbiAobWluLCBtYWcpIHtcbiAgICAgICAgLy8gU2V0IHRoZSB0ZXh0dXJlIGludGVycG9sYXRpb24gbW9kZVxuICAgICAgICAvLyBcbiAgICAgICAgLy8gUGFyYW1ldGVyc1xuICAgICAgICAvLyAtLS0tLS0tLS0tXG4gICAgICAgIC8vIG1pbiA6IEdMIGVudW1cbiAgICAgICAgLy8gICAgIFRoZSBpbnRlcnBvbGF0aW9uIG1vZGUgd2hlbiBtaW5pZnlpbmcgKGkuZS4gem9vbWVkIG91dCkuIFZhbGlkXG4gICAgICAgIC8vICAgICB2YWx1ZXMgYXJlIExJTkVBUiBhbmQgTkVBUkVTVC5cbiAgICAgICAgLy8gbWF4IDogR0wgZW51bVxuICAgICAgICAvLyAgICAgVGhlIGludGVycG9sYXRpb24gbW9kZSB3aGVuIG1hZ25pZnlpbmcgKGkuZS4gem9vbWVkIGluKS4gVmFsaWRcbiAgICAgICAgLy8gICAgIHZhbHVlcyBhcmUgTElORUFSLCBORUFSRVNULCBORUFSRVNUX01JUE1BUF9ORUFSRVNULFxuICAgICAgICAvLyAgICAgTElORUFSX01JUE1BUF9ORUFSRVNULCBORUFSRVNUX01JUE1BUF9MSU5FQVIsIExJTkVBUl9NSVBNQVBfTElORUFSLlxuICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICAgIHRoaXMuX2dsLnRleFBhcmFtZXRlcmYodGhpcy5fdGFyZ2V0LCB0aGlzLl9nbC5URVhUVVJFX01JTl9GSUxURVIsIG1pbik7XG4gICAgICAgIHRoaXMuX2dsLnRleFBhcmFtZXRlcmYodGhpcy5fdGFyZ2V0LCB0aGlzLl9nbC5URVhUVVJFX01BR19GSUxURVIsIG1hZyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBUZXh0dXJlMkQucHJvdG90eXBlLnNldF9zaXplID0gZnVuY3Rpb24gKHNoYXBlLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIGhlaWdodCwgc3R1YjE1Xywgd2lkdGg7XG4gICAgICAgIC8vIFNldCB0aGUgc2l6ZSBvZiB0aGUgMkQgdGV4dHVyZS5cbiAgICAgICAgLy8gXG4gICAgICAgIC8vIFBhcmFtZXRlcnNcbiAgICAgICAgLy8gLS0tLS0tLS0tLVxuICAgICAgICAvLyBzaGFwZSA6IHR1cGxlIG9mIGludHNcbiAgICAgICAgLy8gICAgIFRoZSBzaGFwZSBvZiB0aGUgZGF0YSB0byB1cGxvYWRcbiAgICAgICAgLy8gZm9ybWF0IDogR0wgZW51bVxuICAgICAgICAvLyAgICAgVGhlIGZvcm1hdCBvZiB0aGUgdGV4dHVyZSBkYXRhLiBDYW4gYmUgTFVNSU5BTkNFLCBMVU1JTkFOQ0VfQUxQSEEsXG4gICAgICAgIC8vICAgICBSR0IsIGFuZCBSR0JBLlxuICAgICAgICBzdHViMTVfID0gc2hhcGU7XG4gICAgICAgIGhlaWdodCA9IHN0dWIxNV9bMF07d2lkdGggPSBzdHViMTVfWzFdO1xuICAgICAgICBpZiAoKCFfcHlmdW5jX2VxdWFscyhbaGVpZ2h0LCB3aWR0aCwgZm9ybWF0XSwgdGhpcy5fc2hhcGVfZm9ybWF0KSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoYXBlX2Zvcm1hdCA9IFtoZWlnaHQsIHdpZHRoLCBmb3JtYXRdO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5fZ2wudGV4SW1hZ2UyRCh0aGlzLl90YXJnZXQsIDAsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0aGlzLl9nbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVfc2hhcGUgPSBbaGVpZ2h0LCB3aWR0aF07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBUZXh0dXJlMkQucHJvdG90eXBlLnNldF9kYXRhID0gZnVuY3Rpb24gKG9mZnNldCwgc2hhcGUsIGRhdGEpIHtcbiAgICAgICAgdmFyIF8sIGFsaWdubWVudCwgZXJyXzMsIGZvcm1hdCwgZ3R5cGUsIGhlaWdodCwgc3R1YjE2Xywgc3R1YjE3Xywgd2lkdGgsIHgsIHk7XG4gICAgICAgIC8vIFNldCB0aGUgMkQgdGV4dHVyZSBkYXRhLlxuICAgICAgICAvLyBcbiAgICAgICAgLy8gUGFyYW1ldGVyc1xuICAgICAgICAvLyAtLS0tLS0tLS0tXG4gICAgICAgIC8vIG9mZnNldCA6IHR1cGxlIG9mIGludHNcbiAgICAgICAgLy8gICAgIE9mZnNldCBpbiBwaXhlbHMgZm9yIGVhY2ggZGltZW5zaW9uLlxuICAgICAgICAvLyBzaGFwZSA6IHR1cGxlIG9mIGludHNcbiAgICAgICAgLy8gICAgIFRoZSBzaGFwZSBvZiB0aGUgZGF0YSB0byB1cGxvYWRcbiAgICAgICAgLy8gZGF0YSA6IHR5cGVkIGFycmF5XG4gICAgICAgIC8vICAgICBUaGUgYWN0dWFsIHBpeGVsIGRhdGEuIENhbiBiZSBvZiBhbnkgdHlwZSwgYnV0IG9uIHRoZSBHUFUgdGhlXG4gICAgICAgIC8vICAgICBkYXQgaXMgc3RvcmVkIGluIDggYml0IHByZWNpc2lvbi5cbiAgICAgICAgaWYgKF9weWZ1bmNfZXF1YWxzKHNoYXBlLmxlbmd0aCwgMikpIHtcbiAgICAgICAgICAgIHNoYXBlID0gW3NoYXBlWzBdLCBzaGFwZVsxXSwgMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICBmb3JtYXQgPSB0aGlzLl9zaGFwZV9mb3JtYXRbMl07XG4gICAgICAgIHN0dWIxNl8gPSBzaGFwZTtcbiAgICAgICAgaGVpZ2h0ID0gc3R1YjE2X1swXTt3aWR0aCA9IHN0dWIxNl9bMV07XyA9IHN0dWIxNl9bMl07XG4gICAgICAgIHN0dWIxN18gPSBvZmZzZXQ7XG4gICAgICAgIHkgPSBzdHViMTdfWzBdO3ggPSBzdHViMTdfWzFdO1xuICAgICAgICBndHlwZSA9IF9weW1ldGhfZ2V0LmNhbGwodGhpcy5fdHlwZXMsIGRhdGEuY29uc3RydWN0b3IubmFtZSwgbnVsbCk7XG4gICAgICAgIGlmICgoZ3R5cGUgPT09IG51bGwpKSB7XG4gICAgICAgICAgICBlcnJfMyA9IG5ldyBFcnJvcignVmFsdWVFcnJvcjonICsgKFwiVHlwZSBcIiArIGRhdGEuY29uc3RydWN0b3IubmFtZSArIFwiIG5vdCBhbGxvd2VkIGZvciB0ZXh0dXJlXCIpKTsgZXJyXzMubmFtZSA9IFwiVmFsdWVFcnJvclwiOyB0aHJvdyBlcnJfMztcbiAgICAgICAgfVxuICAgICAgICBhbGlnbm1lbnQgPSB0aGlzLl9nZXRfYWxpZ25tZW50KF9weWZ1bmNfbXVsdChzaGFwZVtzaGFwZS5sZW5ndGggLTJdLCBzaGFwZVtzaGFwZS5sZW5ndGggLTFdKSk7XG4gICAgICAgIGlmICgoIV9weWZ1bmNfZXF1YWxzKGFsaWdubWVudCwgNCkpKSB7XG4gICAgICAgICAgICB0aGlzLl9nbC5waXhlbFN0b3JlaSh0aGlzLl9nbC5VTlBBQ0tfQUxJR05NRU5ULCBhbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dsLnRleFN1YkltYWdlMkQodGhpcy5fdGFyZ2V0LCAwLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIGd0eXBlLCBkYXRhKTtcbiAgICAgICAgaWYgKCghX3B5ZnVuY19lcXVhbHMoYWxpZ25tZW50LCA0KSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsLnBpeGVsU3RvcmVpKHRoaXMuX2dsLlVOUEFDS19BTElHTk1FTlQsIDQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cblxuICAgIFRleHR1cmUzRExpa2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEEgMkQgdGV4dHVyZSB3aXRoIHN1cHBvcnQgdG8gc2ltdWxhdGUgYSAzRCB0ZXh0dXJlLlxuICAgICAgICAvLyBcbiAgICAgICAgLy8gVG8gdXNlIHRoaXMgY2xhc3MsIHVzZSBzZXRfc2l6ZSgpIGFuZCBzZXRfZGF0YSgpIGFzIGlmIGl0IHdhcyBhIDNEXG4gICAgICAgIC8vIHRleHR1cmUuIEFkZCB0aGUgR0xTTF9TQU1QTEVfTkVBUkVTVCBvciBHTFNMX1NBTVBMRV9MSU5FQVIgdG8gdGhlXG4gICAgICAgIC8vIHNoYWRlciB0byBhZGQgdGhlIHNhbXBsZTNEKCkgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIHRleHR1cmUyRCgpLiBUaGlzIGZ1bmN0aW9uIG5lZWRzIGBgc2hhcGVgYCBhbmQgYGB0aWxlc2BgIGFyZ3VtZW50c1xuICAgICAgICAvLyB3aGljaCBjYW4gYmUgc2V0IHZpYSB1bmlmb3JtcywgdXNpbmcgdGhlIGBgdV9zaGFwZWBgIGFuZCBgYHVfdGlsZXNgYFxuICAgICAgICAvLyBhdHRyaWJ1dGVzIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICBfcHlmdW5jX2luc3RhbnRpYXRlKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFRleHR1cmUzRExpa2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUZXh0dXJlMkQucHJvdG90eXBlKTtcbiAgICBUZXh0dXJlM0RMaWtlLnByb3RvdHlwZS5fYmFzZV9jbGFzcyA9IFRleHR1cmUyRC5wcm90b3R5cGU7XG4gICAgVGV4dHVyZTNETGlrZS5wcm90b3R5cGUuX2NsYXNzX25hbWUgPSBcIlRleHR1cmUzRExpa2VcIjtcbiAgICBcbiAgICBUZXh0dXJlM0RMaWtlLnByb3RvdHlwZS5HTFNMX1NBTVBMRV9ORUFSRVNUID0gXCJcXG4gICAgICAgIHZlYzQgc2FtcGxlM0Qoc2FtcGxlcjJEIHRleCwgdmVjMyB0ZXhjb29yZCwgdmVjMyBzaGFwZSwgdmVjMiB0aWxlcykge1xcbiAgICAgICAgICAgIHNoYXBlLnh5eiA9IHNoYXBlLnp5eDsgIC8vIHNpbGx5IHJvdy1tYWpvciBjb252ZW50aW9uXFxuICAgICAgICAgICAgZmxvYXQgbnJvd3MgPSB0aWxlcy55LCBuY29scyA9IHRpbGVzLng7XFxuICAgICAgICAgICAgLy8gRG9uJ3QgbGV0IGFkamFjZW50IGZyYW1lcyBiZSBpbnRlcnBvbGF0ZWQgaW50byB0aGlzIG9uZVxcbiAgICAgICAgICAgIHRleGNvb3JkLnggPSBtaW4odGV4Y29vcmQueCAqIHNoYXBlLngsIHNoYXBlLnggLSAwLjUpO1xcbiAgICAgICAgICAgIHRleGNvb3JkLnggPSBtYXgoMC41LCB0ZXhjb29yZC54KSAvIHNoYXBlLng7XFxuICAgICAgICAgICAgdGV4Y29vcmQueSA9IG1pbih0ZXhjb29yZC55ICogc2hhcGUueSwgc2hhcGUueSAtIDAuNSk7XFxuICAgICAgICAgICAgdGV4Y29vcmQueSA9IG1heCgwLjUsIHRleGNvb3JkLnkpIC8gc2hhcGUueTtcXG5cXG4gICAgICAgICAgICBmbG9hdCB6aW5kZXggPSBmbG9vcih0ZXhjb29yZC56ICogc2hhcGUueik7XFxuXFxuICAgICAgICAgICAgLy8gRG8gYSBsb29rdXAgaW4gdGhlIDJEIHRleHR1cmVcXG4gICAgICAgICAgICBmbG9hdCB1ID0gKG1vZCh6aW5kZXgsIG5jb2xzKSArIHRleGNvb3JkLngpIC8gbmNvbHM7XFxuICAgICAgICAgICAgZmxvYXQgdiA9IChmbG9vcih6aW5kZXggLyBuY29scykgKyB0ZXhjb29yZC55KSAvIG5yb3dzO1xcblxcbiAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlMkQodGV4LCB2ZWMyKHUsdikpO1xcbiAgICAgICAgfVxcbiAgICBcIjtcbiAgICBUZXh0dXJlM0RMaWtlLnByb3RvdHlwZS5HTFNMX1NBTVBMRV9MSU5FQVIgPSBcIlxcbiAgICAgICAgdmVjNCBzYW1wbGUzRChzYW1wbGVyMkQgdGV4LCB2ZWMzIHRleGNvb3JkLCB2ZWMzIHNoYXBlLCB2ZWMyIHRpbGVzKSB7XFxuICAgICAgICAgICAgc2hhcGUueHl6ID0gc2hhcGUuenl4OyAgLy8gc2lsbHkgcm93LW1ham9yIGNvbnZlbnRpb25cXG4gICAgICAgICAgICBmbG9hdCBucm93cyA9IHRpbGVzLnksIG5jb2xzID0gdGlsZXMueDtcXG4gICAgICAgICAgICAvLyBEb24ndCBsZXQgYWRqYWNlbnQgZnJhbWVzIGJlIGludGVycG9sYXRlZCBpbnRvIHRoaXMgb25lXFxuICAgICAgICAgICAgdGV4Y29vcmQueCA9IG1pbih0ZXhjb29yZC54ICogc2hhcGUueCwgc2hhcGUueCAtIDAuNSk7XFxuICAgICAgICAgICAgdGV4Y29vcmQueCA9IG1heCgwLjUsIHRleGNvb3JkLngpIC8gc2hhcGUueDtcXG4gICAgICAgICAgICB0ZXhjb29yZC55ID0gbWluKHRleGNvb3JkLnkgKiBzaGFwZS55LCBzaGFwZS55IC0gMC41KTtcXG4gICAgICAgICAgICB0ZXhjb29yZC55ID0gbWF4KDAuNSwgdGV4Y29vcmQueSkgLyBzaGFwZS55O1xcblxcbiAgICAgICAgICAgIGZsb2F0IHogPSB0ZXhjb29yZC56ICogc2hhcGUuejtcXG4gICAgICAgICAgICBmbG9hdCB6aW5kZXgxID0gZmxvb3Ioeik7XFxuICAgICAgICAgICAgZmxvYXQgdTEgPSAobW9kKHppbmRleDEsIG5jb2xzKSArIHRleGNvb3JkLngpIC8gbmNvbHM7XFxuICAgICAgICAgICAgZmxvYXQgdjEgPSAoZmxvb3IoemluZGV4MSAvIG5jb2xzKSArIHRleGNvb3JkLnkpIC8gbnJvd3M7XFxuXFxuICAgICAgICAgICAgZmxvYXQgemluZGV4MiA9IHppbmRleDEgKyAxLjA7XFxuICAgICAgICAgICAgZmxvYXQgdTIgPSAobW9kKHppbmRleDIsIG5jb2xzKSArIHRleGNvb3JkLngpIC8gbmNvbHM7XFxuICAgICAgICAgICAgZmxvYXQgdjIgPSAoZmxvb3IoemluZGV4MiAvIG5jb2xzKSArIHRleGNvb3JkLnkpIC8gbnJvd3M7XFxuXFxuICAgICAgICAgICAgdmVjNCBzMSA9IHRleHR1cmUyRCh0ZXgsIHZlYzIodTEsIHYxKSk7XFxuICAgICAgICAgICAgdmVjNCBzMiA9IHRleHR1cmUyRCh0ZXgsIHZlYzIodTIsIHYyKSk7XFxuXFxuICAgICAgICAgICAgcmV0dXJuIHMxICogKHppbmRleDIgLSB6KSArIHMyICogKHogLSB6aW5kZXgxKTtcXG4gICAgICAgIH1cXG4gICAgXCI7XG4gICAgVGV4dHVyZTNETGlrZS5wcm90b3R5cGUuX2dldF90aWxlX2luZm8gPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgdmFyIGVycl8zLCBtYXhfc2l6ZSwgbmNvbHMsIG5yb3dzO1xuICAgICAgICBtYXhfc2l6ZSA9IHRoaXMuX2dsLmdldFBhcmFtZXRlcih0aGlzLl9nbC5NQVhfVEVYVFVSRV9TSVpFKTtcbiAgICAgICAgbnJvd3MgPSBNYXRoLmZsb29yKG1heF9zaXplL3NoYXBlWzFdKTtcbiAgICAgICAgbnJvd3MgPSBNYXRoLm1pbihucm93cywgc2hhcGVbMF0pO1xuICAgICAgICBuY29scyA9IHdpbmRvdy5NYXRoLmNlaWwoc2hhcGVbMF0gLyBucm93cyk7XG4gICAgICAgIGlmIChfcHlmdW5jX3RydXRoeShfcHlmdW5jX211bHQobmNvbHMsIHNoYXBlWzJdKSA+IG1heF9zaXplKSkge1xuICAgICAgICAgICAgZXJyXzMgPSBuZXcgRXJyb3IoJ1J1bnRpbWVFcnJvcjonICsgKFwiQ2Fubm90IGZpdCAzRCBkYXRhIHdpdGggc2hhcGUgXCIgKyBzaGFwZSArIFwiIG9udG8gc2ltdWxhdGVkIDJEIHRleHR1cmUuXCIpKTsgZXJyXzMubmFtZSA9IFwiUnVudGltZUVycm9yXCI7IHRocm93IGVycl8zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbnJvd3MsIG5jb2xzXTtcbiAgICB9O1xuXG4gICAgVGV4dHVyZTNETGlrZS5wcm90b3R5cGUuc2V0X3NpemUgPSBmdW5jdGlvbiAoc2hhcGUsIGZvcm1hdCkge1xuICAgICAgICB2YXIgbmNvbHMsIG5yb3dzLCBzaW1fc2hhcGUsIHN0dWIxOF87XG4gICAgICAgIC8vIFNldCB0aGUgc2l6ZSBvZiB0aGUgM0QgdGV4dHVyZS5cbiAgICAgICAgLy8gXG4gICAgICAgIC8vIFBhcmFtZXRlcnNcbiAgICAgICAgLy8gLS0tLS0tLS0tLVxuICAgICAgICAvLyBzaGFwZSA6IHR1cGxlIG9mIGludHNcbiAgICAgICAgLy8gICAgIFRoZSBzaGFwZSBvZiB0aGUgZGF0YSB0byB1cGxvYWRcbiAgICAgICAgLy8gZm9ybWF0IDogR0wgZW51bVxuICAgICAgICAvLyAgICAgVGhlIGZvcm1hdCBvZiB0aGUgdGV4dHVyZSBkYXRhLiBDYW4gYmUgTFVNSU5BTkNFLCBMVU1JTkFOQ0VfQUxQSEEsXG4gICAgICAgIC8vICAgICBSR0IsIGFuZCBSR0JBLlxuICAgICAgICBzdHViMThfID0gdGhpcy5fZ2V0X3RpbGVfaW5mbyhzaGFwZSk7XG4gICAgICAgIG5yb3dzID0gc3R1YjE4X1swXTtuY29scyA9IHN0dWIxOF9bMV07XG4gICAgICAgIHNpbV9zaGFwZSA9IFtfcHlmdW5jX211bHQoc2hhcGVbMV0sIG5yb3dzKSwgX3B5ZnVuY19tdWx0KHNoYXBlWzJdLCBuY29scyldO1xuICAgICAgICBUZXh0dXJlM0RMaWtlLnByb3RvdHlwZS5fYmFzZV9jbGFzcy5zZXRfc2l6ZS5jYWxsKHRoaXMsIHNpbV9zaGFwZSwgZm9ybWF0KTtcbiAgICAgICAgdGhpcy51X3NoYXBlID0gW3NoYXBlWzBdLCBzaGFwZVsxXSwgc2hhcGVbMl1dO1xuICAgICAgICB0aGlzLnVfdGlsZXMgPSBbbmNvbHMsIG5yb3dzXTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIFRleHR1cmUzRExpa2UucHJvdG90eXBlLnNldF9kYXRhID0gZnVuY3Rpb24gKG9mZnNldCwgc2hhcGUsIGRhdGEpIHtcbiAgICAgICAgdmFyIFR5cGUsIGNvbCwgZWxlbWVudHNfcGVyX3RpbGUsIGVycl8zLCBuY29scywgbnJvd3MsIHJvdywgc2ltX3NoYXBlLCBzdHViMTlfLCBzdHViMjBfLCB0aWxlLCB6LCB6ZXJvcztcbiAgICAgICAgLy8gU2V0IHRoZSAzRCB0ZXh0dXJlIGRhdGEuXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBQYXJhbWV0ZXJzXG4gICAgICAgIC8vIC0tLS0tLS0tLS1cbiAgICAgICAgLy8gb2Zmc2V0IDogdHVwbGUgb2YgaW50c1xuICAgICAgICAvLyAgICAgT2Zmc2V0IGluIHBpeGVscyBmb3IgZWFjaCBkaW1lbnNpb24uXG4gICAgICAgIC8vIHNoYXBlIDogdHVwbGUgb2YgaW50c1xuICAgICAgICAvLyAgICAgVGhlIHNoYXBlIG9mIHRoZSBkYXRhIHRvIHVwbG9hZFxuICAgICAgICAvLyBkYXRhIDogdHlwZWQgYXJyYXlcbiAgICAgICAgLy8gICAgIFRoZSBhY3R1YWwgcGl4ZWwgZGF0YS4gQ2FuIGJlIG9mIGFueSB0eXBlLCBidXQgb24gdGhlIEdQVSB0aGVcbiAgICAgICAgLy8gICAgIGRhdCBpcyBzdG9yZWQgaW4gOCBiaXQgcHJlY2lzaW9uLlxuICAgICAgICBpZiAoX3B5ZnVuY19lcXVhbHMoc2hhcGUubGVuZ3RoLCAzKSkge1xuICAgICAgICAgICAgc2hhcGUgPSBbc2hhcGVbMF0sIHNoYXBlWzFdLCBzaGFwZVsyXSwgMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghKF9weWZ1bmNfYWxsKCgoZnVuY3Rpb24gbGlzdF9jb21wcmVoZW5zb24gKCkge3ZhciByZXMgPSBbXTt2YXIgaSwgaXRlcjAsIGkwO2l0ZXIwID0gb2Zmc2V0O2lmICgodHlwZW9mIGl0ZXIwID09PSBcIm9iamVjdFwiKSAmJiAoIUFycmF5LmlzQXJyYXkoaXRlcjApKSkge2l0ZXIwID0gT2JqZWN0LmtleXMoaXRlcjApO31mb3IgKGkwPTA7IGkwPGl0ZXIwLmxlbmd0aDsgaTArKykge2kgPSBpdGVyMFtpMF07e3Jlcy5wdXNoKF9weWZ1bmNfZXF1YWxzKGksIDApKTt9fXJldHVybiByZXM7fSkuYXBwbHkodGhpcykpKSkpKSB7XG4gICAgICAgICAgICBlcnJfMyA9IG5ldyBFcnJvcignVmFsdWVFcnJvcjonICsgXCJUZXh0dXJlM0RMaWtlIGRvZXMgbm90IHN1cHBvcnQgbm9uemVybyBvZmZzZXQgKGZvciBub3cpXCIpOyBlcnJfMy5uYW1lID0gXCJWYWx1ZUVycm9yXCI7IHRocm93IGVycl8zO1xuICAgICAgICB9XG4gICAgICAgIHN0dWIxOV8gPSB0aGlzLl9nZXRfdGlsZV9pbmZvKHNoYXBlKTtcbiAgICAgICAgbnJvd3MgPSBzdHViMTlfWzBdO25jb2xzID0gc3R1YjE5X1sxXTtcbiAgICAgICAgc2ltX3NoYXBlID0gW19weWZ1bmNfbXVsdChzaGFwZVsxXSwgbnJvd3MpLCBfcHlmdW5jX211bHQoc2hhcGVbMl0sIG5jb2xzKSwgc2hhcGVbM11dO1xuICAgICAgICBpZiAoX3B5ZnVuY19lcXVhbHMobmNvbHMsIDEpKSB7XG4gICAgICAgICAgICBUZXh0dXJlM0RMaWtlLnByb3RvdHlwZS5fYmFzZV9jbGFzcy5zZXRfZGF0YS5jYWxsKHRoaXMsIFswLCAwXSwgc2ltX3NoYXBlLCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFR5cGUgPSBkYXRhLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgemVyb3MgPSBuZXcgVHlwZShfcHlmdW5jX211bHQoX3B5ZnVuY19tdWx0KHNpbV9zaGFwZVswXSwgc2ltX3NoYXBlWzFdKSwgc2ltX3NoYXBlWzJdKSk7XG4gICAgICAgICAgICBUZXh0dXJlM0RMaWtlLnByb3RvdHlwZS5fYmFzZV9jbGFzcy5zZXRfZGF0YS5jYWxsKHRoaXMsIFswLCAwXSwgc2ltX3NoYXBlLCB6ZXJvcyk7XG4gICAgICAgICAgICBmb3IgKHogPSAwOyB6IDwgc2hhcGVbMF07IHogKz0gMSkge1xuICAgICAgICAgICAgICAgIHN0dWIyMF8gPSBbTWF0aC5mbG9vcih6L25jb2xzKSwgeiAlIG5jb2xzXTtcbiAgICAgICAgICAgICAgICByb3cgPSBzdHViMjBfWzBdO2NvbCA9IHN0dWIyMF9bMV07XG4gICAgICAgICAgICAgICAgZWxlbWVudHNfcGVyX3RpbGUgPSBNYXRoLmZsb29yKGRhdGEubGVuZ3RoL3NoYXBlWzBdKTtcbiAgICAgICAgICAgICAgICB0aWxlID0gZGF0YS5zbGljZShfcHlmdW5jX211bHQoeiwgZWxlbWVudHNfcGVyX3RpbGUpLF9weWZ1bmNfbXVsdCgoeiArIDEpLCBlbGVtZW50c19wZXJfdGlsZSkpO1xuICAgICAgICAgICAgICAgIFRleHR1cmUzRExpa2UucHJvdG90eXBlLl9iYXNlX2NsYXNzLnNldF9kYXRhLmNhbGwodGhpcywgW19weWZ1bmNfbXVsdChyb3csIHNoYXBlWzFdKSwgX3B5ZnVuY19tdWx0KGNvbCwgc2hhcGVbMl0pXSwgc2hhcGUuc2xpY2UoMSksIHRpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cblxuICAgIHJldHVybiB7XCJCdWZmZXJcIjogQnVmZmVyLCBcIkdsb29PYmplY3RcIjogR2xvb09iamVjdCwgXCJJbmRleEJ1ZmZlclwiOiBJbmRleEJ1ZmZlciwgXCJQcm9ncmFtXCI6IFByb2dyYW0sIFwiVGV4dHVyZTJEXCI6IFRleHR1cmUyRCwgXCJUZXh0dXJlM0RMaWtlXCI6IFRleHR1cmUzRExpa2UsIFwiVmVydGV4QnVmZmVyXCI6IFZlcnRleEJ1ZmZlciwgXCJjaGVja19lcnJvclwiOiBjaGVja19lcnJvciwgXCJjb25zb2xlXCI6IGNvbnNvbGV9O1xufSkpO1xuIl19"}